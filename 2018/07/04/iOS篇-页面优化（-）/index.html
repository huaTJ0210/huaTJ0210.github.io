<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>  · 華</title><meta name="description" content=" - 华子"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/timg.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="華"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/timg.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/huatianjie1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/huaTJ0210" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title"></h1><div class="post-info">Jul 4, 2018</div><div class="post-content"><p>title: iOS篇-页面优化(一)<br>date: 2018-07-04 22:17:22<br>categories: iOS </p>
<h2 id="tags-iOS页面优化"><a href="#tags-iOS页面优化" class="headerlink" title="tags:[iOS页面优化]  "></a>tags:[iOS页面优化]  </h2><h3 id="本文主要涉及到的知识点："><a href="#本文主要涉及到的知识点：" class="headerlink" title="本文主要涉及到的知识点："></a>本文主要涉及到的知识点：</h3><ul>
<li>图像显示原理  </li>
<li>CPU和GPU的职责</li>
<li>UI卡顿掉帧的原因</li>
<li>视图的绘制</li>
<li>视图的异步绘制</li>
<li>离屏渲染</li>
<li>性能优化的集合  </li>
</ul>
<a id="more"></a>
<h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><p>CPU和GPU两个硬件通过总线相连接，CPU负责视图的计算，GPU负责视图渲染，GPU将渲染的位图提交给帧缓冲区（frame buffer），视频控制器接收到VSync信号后将位图在显示器上显示；<br><img src="https://upload-images.jianshu.io/upload_images/117735-1f696b1bc58ad56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图像显示原理.png">    </p>
<p><strong>对应具体视图的显示</strong><br><img src="https://upload-images.jianshu.io/upload_images/117735-b1a696a84cd46d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.39.30.png"></p>
<h3 id="CPU和GPU的职责"><a href="#CPU和GPU的职责" class="headerlink" title="CPU和GPU的职责"></a>CPU和GPU的职责</h3><p> <strong>CPU的主要职责</strong>    </p>
<ul>
<li>Layout -&gt; UI布局【自动布局】、文本计算</li>
<li>Display -&gt; 绘制【Core Graphics绘制：为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢】</li>
<li>Prepare -&gt; 图片的编解码【PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸;iOS只有在真正绘制的时候才去解压】</li>
<li>Commit -&gt; 将位图提交给GPU  </li>
</ul>
<p><strong>GPU的主要职责</strong>   </p>
<ul>
<li>将图层内容渲染到屏幕上   </li>
</ul>
<p><strong>影响GPU的操作</strong>    </p>
<ul>
<li>太多的几何结构，视图层级复杂</li>
<li>重绘：由重叠的半透明图层引起 </li>
<li>离屏绘制：不能直接在屏幕上绘制，必须绘制到离屏图片上下文中  </li>
<li>过大的图片  </li>
</ul>
<h3 id="UI卡顿掉帧的原因"><a href="#UI卡顿掉帧的原因" class="headerlink" title="UI卡顿掉帧的原因"></a>UI卡顿掉帧的原因</h3><p>在页面滑动流畅一般是60FPS，也就是16.7ms要产生一帧的图像渲染出来，如果CPU+GPU在一次VSync信号结束的16.7ms内没有产生一个帧图像在屏幕中显示就会产生卡顿掉帧；<br><img src="https://upload-images.jianshu.io/upload_images/117735-a22f468c86495bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.44.28.png">  </p>
<h3 id="视图的绘制"><a href="#视图的绘制" class="headerlink" title="视图的绘制"></a>视图的绘制</h3><p>如下图所示，UIView在接收到setNeedsDisplay的时候并不会直接进行视图的绘制工作，而是等整个流程走完，在当前runloop快结束的时候才会调用setNeedsDisplay标记的视图的drawRect方法<br><img src="https://upload-images.jianshu.io/upload_images/117735-4977b484d21e0045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.54.03.png">  </p>
<p><img src="https://upload-images.jianshu.io/upload_images/117735-8b1ebc403dec24c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午10.02.06.png"></p>
<h3 id="视图的异步绘制"><a href="#视图的异步绘制" class="headerlink" title="视图的异步绘制"></a>视图的异步绘制</h3><p><img src="https://upload-images.jianshu.io/upload_images/117735-52c1e98b800ef016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午10.06.29.png"></p>
<h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p><strong>GPU的渲染分为两种</strong>   </p>
<ul>
<li>On-Screen Rendering (当前屏幕渲染)：GPU的渲染是在当前用于显示的屏幕缓冲区进行的  </li>
<li>Off-Screen Rendering（离屏渲染）：GPU在当前屏幕缓冲区以外开辟一个缓存区进行渲染操作</li>
</ul>
<p><strong>离屏渲染的坏处</strong>  </p>
<ul>
<li>创建新缓冲区：要进行离屏渲染，首先要创建一个新的缓冲区  </li>
<li>上下文切换：离屏渲染的整个过程，要多次切换上下文，On-Screen -&gt; Off-Screen ,当离屏渲染结束后要将渲染结果显示，需要将上下文再次切换回来，而上下文的切换代价很大  </li>
</ul>
<p><strong>会触发离屏渲染的操作</strong>   </p>
<ul>
<li>为图层设置遮罩（layer.mask）</li>
<li>layer.masksToBounds/view.clipsToBounds 设置为true</li>
<li>layer.opacity小于1.0</li>
<li>layer.shadow</li>
<li>layer.cornerRadius</li>
<li>drawRect中进行绘制  </li>
</ul>
<p><strong>如何优化离屏渲染</strong>  </p>
<ul>
<li>控件圆角的设置：CAShaperLayer/Core Graphics 结合UIBezierPath 绘制圆角 </li>
<li>阴影的绘制：设置shadowPath</li>
<li>使用instrument的Core Animation检测：图层的离屏渲染、图层是否透明</li>
</ul>
<h3 id="性能优化的集合"><a href="#性能优化的集合" class="headerlink" title="性能优化的集合"></a>性能优化的集合</h3><ul>
<li>避免使用CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:<br>原因：实现这两个方法中的其中之一就必须需要一个绘制上下文，这个上下文的大小基本和原有图层的内存占有量一致；所以重绘的代价太高 </li>
<li>对于Core Graphics 可以使用CAShapLayer来替换绘制图形、直线和曲线，使用CATextLayer绘制文本，CAGradientLayer绘制渐变 </li>
<li>列表加载远程图片，直接加载会导致界面卡顿；因为图片资源大，导致加载时间长；在另外的线程中加载图片，在主线程中更新显示内容【SDWebImageView】</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/04/生活篇--说说三观/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">华子</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>