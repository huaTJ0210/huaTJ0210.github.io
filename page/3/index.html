<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 華</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/timg.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="華"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/timg.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/huatianjie1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/huaTJ0210" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/06/20/OC基础之消息传递/" class="post-title-link">OC基础之消息传递</a></h2><div class="post-info">Jun 20, 2015</div><div class="post-content"><blockquote>
<p>文章参考 <a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a></p>
</blockquote>
<p>在项目编码中最为常见的就是[object message];这种形式的消息发送，对于其他面向对象语言来说就是实例对象调用类中实现的实例方法；[object message]这种形式到底做了什么呢？<br></div><a href="/2015/06/20/OC基础之消息传递/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/05/05/OC基础之内存管理篇/" class="post-title-link">OC基础之内存管理篇</a></h2><div class="post-info">May 5, 2015</div><div class="post-content"><h3 id="为什么要进行内存管理"><a href="#为什么要进行内存管理" class="headerlink" title="为什么要进行内存管理"></a>为什么要进行内存管理</h3><ul>
<li>Objective-C不像JAVA和C#等语言，内存管理依赖垃圾回收(GC)机制;它需要开发者自己管理内存，即便目前的ARC机制也只是编译器帮助开发者完成一部分工作，实际开发中还是需要时刻关注创建对象之间关系、是否出现引用循环等问题；</li>
<li>iOS程序员创建的对象大多分配在堆上，存储空间有限，在iOS系统中如果app内存使用量过大，会收到内存预警的消息，不作处理的情况下系统可能会强制清理程序；因此内存管理对移动端开发尤为重要；</div><a href="/2015/05/05/OC基础之内存管理篇/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/04/06/iOS篇-视图/" class="post-title-link">iOS篇-视图</a></h2><div class="post-info">Apr 6, 2015</div><div class="post-content"><h4 id="视图基础"><a href="#视图基础" class="headerlink" title="视图基础"></a>视图基础</h4><ul>
<li>视图是UIView对象，或是UIView的子类对象；</li>
<li>视图知道如何绘制自己；</li>
<li>视图可以处理事件，例如触摸（touch）；</li>
<li>视图会按照层次结构排列，位于视图层次结构顶端的是应用窗口；</div><a href="/2015/04/06/iOS篇-视图/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/25/OC基础之NSTimer和CADisplayLink/" class="post-title-link">OC基础之NSTimer和CADisplayLink</a></h2><div class="post-info">Mar 25, 2015</div><div class="post-content"><p>不同的编程语言在构造软件系统的时候都会遇到定时执行某项Task的需求，这就涉及到timer的使用！<br></div><a href="/2015/03/25/OC基础之NSTimer和CADisplayLink/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/14/OC基础之属性篇/" class="post-title-link">Objective-C 属性篇</a></h2><div class="post-info">Mar 14, 2015</div><div class="post-content"></div><a href="/2015/03/14/OC基础之属性篇/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/03/版本控制工具之Git/" class="post-title-link">版本控制工具之Git</a></h2><div class="post-info">Mar 3, 2015</div><div class="post-content"><p>目前公司代码的版本控制使用的是svn，但平时自己提交github的代码使用可视化的SourceTree；对于Git命令早些时间也有过接触但是一直没有总结过，这次用思维导图的方式便于以后查看；</p>
<blockquote>
<p>git是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计 –wiki</p>
</blockquote></div><a href="/2015/03/03/版本控制工具之Git/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/02/03/OC基础之内存管理篇(2)/" class="post-title-link">OC基础之内存管理篇(2)</a></h2><div class="post-info">Feb 3, 2015</div><div class="post-content"><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><blockquote>
<p>Cocoa环境的一个特点是它可以管理动态分配的内存。Cocoa中绝大部分类的基类都是NSObject，它实现了引用计数的内存管理模型。从NSObject继承的类可以响应retain和release消息，以增减其引用计数；也可以通过发送retainCount消息来获取其引用计数。一个以alloc，copy或Objective-C 2.0中增加的new所创建的对象的引用计数为1；向对象发送retain消息会将计数加1，而发送release消息则会将计数减1。若对象的引用计数减少到了0，则它会被销毁。dealloc消息类似于C++中的析构函数，在对象被销毁之前可能会被调用，但系统不保证会发送该消息。这种引用计数的模型与微软的COM中的IUnknown接口特性十分相似，它提供了AddRef和Release接口，与retain和release对应。（wiki 百科）  </p>
</blockquote></div><a href="/2015/02/03/OC基础之内存管理篇(2)/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/01/05/iOS篇之CocoaPods/" class="post-title-link">iOS篇之CocoaPods</a></h2><div class="post-info">Jan 5, 2015</div><div class="post-content"><h3 id="CocoaPods-上手体验："><a href="#CocoaPods-上手体验：" class="headerlink" title="CocoaPods 上手体验："></a>CocoaPods 上手体验：</h3><blockquote>
<p>当开发环境已经具备CocoaPods功能，再次引入三方库，只需要在工程目录文件Podfile中添加 pod  ’Three party libraries Name’,’~&gt;versionCode’ 然后 pod update ；Duang~项目就集成了你的需要；再也不要傻帽似的去github上download到本地，手动拖入工程，配置各种framework，不是ARC的还要……..<br></div><a href="/2015/01/05/iOS篇之CocoaPods/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/01/01/iOS篇--推送/" class="post-title-link">iOS篇--推送</a></h2><div class="post-info">Jan 1, 2015</div><div class="post-content"><h3 id="本地通知"><a href="#本地通知" class="headerlink" title="本地通知"></a>本地通知</h3><p>目前市面是存在很多的app可以根据用户的时间设置提供定时提醒功能，通常提醒的消息会从状态栏顶部弹出，几秒后消失，并且在通知中心中能够停留，用户点击通知内容会拉起app；这个功能通常的实现是用到了<strong>UILocalNotification</strong>；<br></div><a href="/2015/01/01/iOS篇--推送/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/12/06/数据结构之排序/" class="post-title-link">排序之冒泡、选择、插入篇</a></h2><div class="post-info">Dec 6, 2014</div><div class="post-content"></div><a href="/2014/12/06/数据结构之排序/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="prev">PREV</a><a href="/page/4/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">华子</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>