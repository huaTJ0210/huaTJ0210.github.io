<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OC基础之面向切面编程 · 華</title><meta name="description" content="OC基础之面向切面编程 - 华子"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/timg.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="華"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/timg.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/huatianjie1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/huaTJ0210" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OC基础之面向切面编程</h1><div class="post-info">Feb 24, 2016</div><div class="post-content"><ul>
<li>面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。   <a id="more"></a> 
<ul>
<li>但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。<br>也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 </li>
<li>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</li>
<li>这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br>AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。<a href="https://www.zhihu.com/question/24863332/answer/48376158" target="_blank" rel="external">面向切面编程-知乎</a>   </li>
</ul>
</li>
</ul>
<p>实际开发中会有运营统计当前界面打开数统计，button按钮的点击事件统计等等一系列的需求；编程过程很容易自定义收集工具类在实现的代码逻辑中调用，但是整个项目中编码文件众多，每个实现逻辑中都穿插这样的收集逻辑实在无法忍受，在查找资料中发现<a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Glow的工程师的 Method Swizzling 和 AOP 实践</a>通过利用objective-c动态语言的特性再加上AOP的编程思想，在运行时中将要实现的逻辑代码插入到指定的位置中去；</p>
<h4 id="使用Method-Swizzling来实现在-void-viewWillAppear-BOOL-animated中实现日志收集逻辑"><a href="#使用Method-Swizzling来实现在-void-viewWillAppear-BOOL-animated中实现日志收集逻辑" class="headerlink" title="使用Method Swizzling来实现在-(void)viewWillAppear:(BOOL)animated中实现日志收集逻辑"></a>使用Method Swizzling来实现在<code>-(void)viewWillAppear:(BOOL)animated</code>中实现日志收集逻辑</h4><p>首先我们希望在程序启动的时候将要执行的日志逻辑插入到 <code>-(void)viewWillAppear:(BOOL)animated</code>中，同时还要保证正常调用<code>-(void)viewWillAppear:(BOOL)animated</code>不受到影响；所以可以在UIViewController的类别中实现<code>-(void)viewWillAppear:(BOOL)animated</code>和自定义方法的互换；下面是具体的实现逻辑</p>
<pre><code>#import &quot;UIViewController+Logging.h&quot;
#import &lt;objc/objc-runtime.h&gt;
#import &quot;Logging.h&quot;

@implementation UIViewController (Logging)
// 保证程序一运行就能实现方法的互换
+(void)load{
    swizzleMethod([self class], @selector(viewWillAppear:), @selector(swizzled_viewDidAppear:));
}

//  交换两个指定的方法
void swizzleMethod(Class class,SEL originalSelector,SEL swizzledSelector){
    Method originalMethod  = class_getInstanceMethod(class, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
    // 
    BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));
    if (didAddMethod) {
        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    }else{
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}

// 切入执行逻辑
-(void)swizzled_viewDidAppear:(BOOL)animated{
    // 下面调用的其实是 -(void)viewWillAppear:(BOOL)animated
    [self swizzled_viewDidAppear:animated];
    //log逻辑
    [Logging logWithEventName:NSStringFromClass([self class])];
}

@end
</code></pre><p><strong>Glow的工程师</strong>在文章中介绍<code>Aspect</code>框架提供的API能更加简单的实现统计埋点的需求；同时segmentfault有篇<a href="https://segmentfault.com/a/1190000003499895" target="_blank" rel="external">Aspect入门实践讲的很详细</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/03/01/UIKIT-UIButton事件解析/" class="prev">PREV</a><a href="/2016/01/09/OC基础之load和initialize/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">华子</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>