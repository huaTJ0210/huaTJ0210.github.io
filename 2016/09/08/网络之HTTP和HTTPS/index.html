<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 网络之HTTP和HTTPS · 華</title><meta name="description" content="网络之HTTP和HTTPS - 华子"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/timg.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="華"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/timg.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/huatianjie1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/huaTJ0210" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">网络之HTTP和HTTPS</h1><div class="post-info">Sep 8, 2016</div><div class="post-content"><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>iOS网络编程中会涉及一些协议（HTTP/HTTPS）和计算机网络相关概念，只有了解它们的相关机制和概念才能在实际的编程中解决一些出现的问题。本文主要会讲解HTTP、HTTPS、Cookie、Session等概念。    </p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP是超文本传输协议,是用于从服务器传输超文本到本地浏览器的传送协议,它是基于TCP实现的，由于TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。移动端可通过HTTP向服务端请求数据(JSON/XML)或者下载上传二进制数据等，那么HTTP是如何工作的？<br><a id="more"></a></p>
<h5 id="HTTP的工作流程"><a href="#HTTP的工作流程" class="headerlink" title="HTTP的工作流程"></a>HTTP的工作流程</h5><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p>
<ul>
<li>首先客户端与服务器需要建立连接。只要出发一个HTTP请求，HTTP的工作开始。</li>
<li>建立连接（建立连接的过程涉及到TCP的三次握手操作）后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和其他的内容。 </li>
<li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 </li>
<li>客户端接收服务器所返回的信息进行解析操作，然后客户机与服务器断开连接。  </li>
</ul>
<h5 id="HTTP请求报文和响应报文的格式"><a href="#HTTP请求报文和响应报文的格式" class="headerlink" title="HTTP请求报文和响应报文的格式"></a>HTTP请求报文和响应报文的格式</h5><ul>
<li>起始行：如 GET / HTTP/1.0 （请求的方法  请求的URL 请求所使用的协议）</li>
<li>头部信息：User-Agent  Host等成对出现的值</li>
<li>主体       </li>
</ul>
<p>GET 请求报文  </p>
<pre><code>GET /books/?sex=man&amp;name=Professional HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
</code></pre><p>POST 请求报文  </p>
<pre><code>POST / HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive  

sex=man&amp;name=Professional      
</code></pre><p>响应报文</p>
<pre><code>HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

&lt;html&gt;...  
</code></pre><h5 id="GET-与-POST-的区别"><a href="#GET-与-POST-的区别" class="headerlink" title="GET 与 POST 的区别"></a>GET 与 POST 的区别</h5><p>GET提交的数据会受到长度限制，GET和POST提交的数据存放位置一个在URL中一个在HTTP Body中；  </p>
<h6 id="HTTP-请求的错误码"><a href="#HTTP-请求的错误码" class="headerlink" title="HTTP 请求的错误码"></a>HTTP 请求的错误码</h6><ul>
<li>2xx : 成功状态码</li>
<li>3xx : 重定向 </li>
<li>4xx : 客户端状态错误码</li>
<li>5xx : 服务端错误状态吗 <ul>
<li>500 : 服务器内部错误</li>
<li>502 : 代理服务器连接不到后端的服务器</li>
<li>504 : 后端服务器给代理服务器的响应超时     </li>
</ul>
</li>
</ul>
<h5 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h5><ul>
<li>Accept  就是告诉服务器端，我接受那些MIME类型</li>
<li>Accept-Encoding  这个看起来是接受那些压缩方式的文件</li>
<li>Accept-Lanague   告诉服务器能够发送哪些语言</li>
<li>Connection       告诉服务器支持keep-alive特性</li>
<li>Cookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端</li>
<li>Host             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多个虚拟主机,那这里就是用来标识要访问那个虚拟主机。<ul>
<li>User-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等     </li>
</ul>
</li>
</ul>
<h4 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h4><ul>
<li>什么是会话: 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话;</li>
<li>什么是会话跟踪: 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。<br>-为什么需要会话跟踪: 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。  </li>
</ul>
<h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><ul>
<li>什么是cookie:  cookie 实际上是包含用户信息的一小段文本信息   </li>
<li>为什么会使用cookie: HTTP的无状态性,服务端想记住某一个访问者只能通过某中标识来判断，cookie就作为服务端颁发给客户端的证书，作为继续请求的凭证   </li>
<li>cookie的局限性: cookie保存在本地，存储信息不能超过3K，易于被伪造造成安全问题；所以敏感信息不能存储   </li>
</ul>
<h5 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h5><ul>
<li>什么是Session: Session是服务端记录用户信息的一种机制；Session相当于在服务器上建立了一个客户档案，通过SessionID来确定用户的信息  </li>
<li>Session的有效期和过期时间: Session清理掉；一般被服务端放在内存中，但是大量访问会可能造成内存溢出的情况，所以超过设定时间的session会被清理掉！   </li>
</ul>
<h4 id="密文处理"><a href="#密文处理" class="headerlink" title="密文处理"></a>密文处理</h4><p> 由于目前的app绝大多数已经切换到HTTPS协议，也就是传输的报文都是经过加密的，这其中包含一些相关概念需要讲述。   </p>
<ul>
<li>公钥密码机制: 该机制包含公钥、私钥、加密算法；并且最重要的是只有私钥才能解析出密文的信息；  </li>
<li>对称与非对称加密算法: 公钥和私钥相同的机密算法叫对称加密算法(例如DES/AES等)，公钥和私钥不相同的算法叫做非对称加密算法   </li>
<li>签名<br>在传输的信息后面加上一段传输信息的hash后的内容，这样能够保证信息的完整和安全性； </li>
<li>数字证书<br>CA机构颁发的一个凭证，包含颁发机构、有效期、公钥、加密算法; </li>
</ul>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTPS被称为安全的HTTP原因在与它被SSL/TSL包裹了一层，客户端与服务端进行通讯是两者之间共同商议的加密机制对传输报文进行加密操作；  </p>
<h5 id="发起一个HTTPS请求，客户端和服务端进行了哪些沟通"><a href="#发起一个HTTPS请求，客户端和服务端进行了哪些沟通" class="headerlink" title="发起一个HTTPS请求，客户端和服务端进行了哪些沟通"></a>发起一个HTTPS请求，客户端和服务端进行了哪些沟通</h5><p><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http协议学习和总结系列-3-5.jpg" alt="HTTPS请求客户端和服务端之间的交互">  </p>
<ul>
<li>client发送’我是客户端’的请求给server端，server接到请求返回自己的数字证书（CA机构颁发的）； </li>
<li>client验证数字证书的真伪(由客户端的TSL完成)，client生成一个随机数(使用证书的公钥加密)发给服务端；  </li>
<li>server接收到请求后使用私钥解密随机数，sever将随机数hash计算用私钥加密后传给客户端</li>
<li>client使用公钥解密和本身的随机数hash值做比较，确定是server的身份；client此时用公钥加密一套对称加密算法和密钥给server用于以后的数据传输；  </li>
<li>server和client就能进行正常的数据传输了   </li>
</ul>
<h4 id="TCP协议和UDP协议"><a href="#TCP协议和UDP协议" class="headerlink" title="TCP协议和UDP协议"></a>TCP协议和UDP协议</h4><p><img src="http://upload-images.jianshu.io/upload_images/117735-b7d77ab5724c9560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机网络层级">     </p>
<h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><p>TCP协议是面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达)传输层协议。  </p>
<h5 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h5><p> UDP协议也是传输层协议，它是无连接，不保证可靠的传输层协议   </p>
<h5 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h5><p>I P是T C P / I P协议族中最为核心的协议。所有的T C P、U D P、I C M P及I G M P数据都以I P数据<br>报格式传输。它的特点不可靠无连接；</p>
<h5 id="TCP的三次握手操作"><a href="#TCP的三次握手操作" class="headerlink" title="TCP的三次握手操作"></a>TCP的三次握手操作</h5><p>SYN（synchronous）是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息<br><img src="http://upload-images.jianshu.io/upload_images/117735-31ba059b7a617177.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP的三次握手操作">   </p>
<ul>
<li>客户端发送syn报文并将序列号X放在Sequence Number字段中 ；</li>
<li>服务端接收到请求，发送确认报文(Acknowledgement Number)X+1,将序列号Y放在Sequence Number字段中，SYN标志位仍旧为1；</li>
<li>客户端收到响应再次发送确认报文Y+1,将序列号Z放在Sequence Number字段中；三次握手完成   </li>
</ul>
<h5 id="TCP的四次挥手操作"><a href="#TCP的四次挥手操作" class="headerlink" title="TCP的四次挥手操作"></a>TCP的四次挥手操作</h5><p><img src="http://upload-images.jianshu.io/upload_images/117735-3f11e03900b70a75.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP的四次挥手操作">   </p>
<h5 id="客户端基于Token的身份验证"><a href="#客户端基于Token的身份验证" class="headerlink" title="客户端基于Token的身份验证"></a>客户端基于Token的身份验证</h5><ul>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 </li>
</ul>
<p>文章参照 </p>
<blockquote>
<p>   <a href="http://www.blogjava.net/zjusuyong/articles/304788.html" target="_blank" rel="external">HTTP协议详解</a><br>   <a href="http://www.cnblogs.com/zmlctt/p/3690998.html" target="_blank" rel="external">TCP三次握手和四次挥手</a><br>   <a href="http://blog.chinaunix.net/uid-26833883-id-3627644.html" target="_blank" rel="external">TCP与UDP详解</a><br>   <a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="external">HTTP</a><br>   <a href="http://ninghao.net/blog/2834" target="_blank" rel="external">基于 Token 的身份验证</a></p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2016/10/20/OC基础之引用循环/" class="prev">PREV</a><a href="/2016/03/20/iOS篇-测试/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">华子</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>