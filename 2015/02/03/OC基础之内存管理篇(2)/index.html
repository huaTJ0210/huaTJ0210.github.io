<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OC基础之内存管理篇(2) · 華</title><meta name="description" content="OC基础之内存管理篇(2) - 华子"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/timg.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="華"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/timg.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/huatianjie1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/huaTJ0210" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OC基础之内存管理篇(2)</h1><div class="post-info">Feb 3, 2015</div><div class="post-content"><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><blockquote>
<p>Cocoa环境的一个特点是它可以管理动态分配的内存。Cocoa中绝大部分类的基类都是NSObject，它实现了引用计数的内存管理模型。从NSObject继承的类可以响应retain和release消息，以增减其引用计数；也可以通过发送retainCount消息来获取其引用计数。一个以alloc，copy或Objective-C 2.0中增加的new所创建的对象的引用计数为1；向对象发送retain消息会将计数加1，而发送release消息则会将计数减1。若对象的引用计数减少到了0，则它会被销毁。dealloc消息类似于C++中的析构函数，在对象被销毁之前可能会被调用，但系统不保证会发送该消息。这种引用计数的模型与微软的COM中的IUnknown接口特性十分相似，它提供了AddRef和Release接口，与retain和release对应。（wiki 百科）  </p>
</blockquote>
<a id="more"></a>   
<h4 id="内存的几大区域简介"><a href="#内存的几大区域简介" class="headerlink" title="内存的几大区域简介"></a>内存的几大区域简介</h4><ul>
<li>栈区：存放局部变量，函数的返回值，局部只读变量（const），指针变量；编译器自动分配和释放栈内存储的值；</li>
<li>堆区：存放手动分配的变量，也需要手动的释放申请的空间；C语言中使用malloc(); free();objective-C中使用alloc、new、copy等在堆区为对象开辟空间；</li>
<li>代码区：c语言的程序经过编译器编译为可执行的代码后就会以顺序的格式存在代码区，如：<code>char* str = &quot;hello&quot;;</code>字符串常量“hello”就存在于代码区;</li>
<li>全局区: 全局变量、全局只读, static修饰的变量和函数;   </li>
</ul>
<h4 id="ARC和内存管理"><a href="#ARC和内存管理" class="headerlink" title="ARC和内存管理"></a>ARC和内存管理</h4><h5 id="指针变量和对象所有权"><a href="#指针变量和对象所有权" class="headerlink" title="指针变量和对象所有权"></a>指针变量和对象所有权</h5><blockquote>
<p>指针变量就暗含了对其所指对象的所有权  </p>
</blockquote>
<h5 id="哪些情况会使得对象失去所有者"><a href="#哪些情况会使得对象失去所有者" class="headerlink" title="哪些情况会使得对象失去所有者"></a>哪些情况会使得对象失去所有者</h5><ul>
<li>将指向内存块C的指针变量A修改指向了内存块B处，内存块C就失去了一个所有者；</li>
<li>将指向内存块C的指针变量A置为nil，内存块C就失去了一个所有者；</li>
<li>当从集合中移除指向内存块c的指针，内存块c就失去一个所有者；   </li>
</ul>
<h5 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h5><ul>
<li>强引用：指针对象指向某个对象，该对象所有者+1，那么该指针特性就是强引用；</li>
<li>弱引用：指针对象指向某个对象，该对象所有者不发生改变，那么该指针就是弱引用；   </li>
</ul>
<h5 id="解决循环引用的问题"><a href="#解决循环引用的问题" class="headerlink" title="解决循环引用的问题"></a>解决循环引用的问题</h5><p>当两个或两个以上的对象互为强引用时，这样就无法通过ARC进行释放，导致内存泄露；<br><strong>如何解决：出现循环引用时需要区分对象之间的父子关系，，父对象使用强引用特性，子对象使用弱引用；</strong>  </p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>使用属性能用来简化声明一个实例变量的同时还用实现一对存储方法；  </p>
<h5 id="声明属性"><a href="#声明属性" class="headerlink" title="声明属性"></a>声明属性</h5><p><code>@property NSString * itemName</code>,声明一个属性会隐含的创建一个实例变量和实现一对存储方法；  </p>
<h5 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h5><ul>
<li>多线程特性： nonatomic（不是默认类型）线程不安全，atomic线程安全但是耗费性能；</li>
<li>多写特性：readwrite：编译器会合成存储方法；readonly：编译器只会生成取方法；</li>
<li>内存管理特性<ul>
<li>unsafe_unretained:不需要内存管理，存取方法直接为实例变量赋值</li>
<li>weak：不会导致对象的引用数增加，对象释放后，指针会自动置为nil；</li>
<li>strong: 会导致对象的引用数增加，存储方法中旧值release，新值赋予实例变量；</li>
<li>copy：当某个属性是指向其他对象指针，并且该对象存在可变的子类，那么通常使用copy；在存方法中<code>_itemName = [itemName copy];</code> 这样做的主要原因是指针指向的对象有可变类型的子类，那么传入可变类型子类对象在程序运行时可能会被修改，这样可能会造成程序异常；</li>
</ul>
</li>
</ul>
<h5 id="属性合成"><a href="#属性合成" class="headerlink" title="属性合成"></a>属性合成</h5><pre><code>@interface ViewController ()
@end
@implementation ViewController
//创建存取方法 方法名name和setName
//同时创建实例变量_name
@synthesize name = _name; 
@end
</code></pre><p>如果你覆盖了存取方法，那么编译器就不会创建实例变量；  </p>
<hr>
<blockquote>
<p>文章内容来自iOS编程（第4版）  </p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2015/03/03/版本控制工具之Git/" class="prev">PREV</a><a href="/2015/01/05/iOS篇之CocoaPods/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">华子</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>