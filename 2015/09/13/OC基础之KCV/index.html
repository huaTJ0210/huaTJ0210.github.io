<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OC基础之KCV · 華</title><meta name="description" content="OC基础之KCV - 华子"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/timg.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="華"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/timg.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/huatianjie1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/huaTJ0210" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OC基础之KCV</h1><div class="post-info">Sep 13, 2015</div><div class="post-content"><h4 id="什么是KVC"><a href="#什么是KVC" class="headerlink" title="什么是KVC"></a>什么是KVC</h4><blockquote>
<p>key value coding：是一种使用字符串标识符间接访问对象属性的机制；  </p>
</blockquote>
<a id="more"></a>  
<pre><code>NSObject 提供如下方法：
     [obj setValue:&lt;#(nullable id)#&gt; forKey:&lt;#(nonnull NSString *)#&gt;];
     [obj setValue:&lt;#(nullable id)#&gt; forKeyPath:&lt;#(nonnull NSString *)#&gt;];
     [obj setValue:&lt;#(nullable id)#&gt; forUndefinedKey:&lt;#(nonnull NSString *)#&gt;];
     [obj setValuesForKeysWithDictionary:&lt;#(nonnull NSDictionary&lt;NSString *,id&gt; *)#&gt;];
     [obj valueForKey:&lt;#(nonnull NSString *)#&gt;];
     [obj valueForKeyPath:&lt;#(nonnull NSString *)#&gt;];
     [obj valueForUndefinedKey:&lt;#(nonnull NSString *)#&gt;];
</code></pre><h4 id="如何使用KVC"><a href="#如何使用KVC" class="headerlink" title="如何使用KVC"></a>如何使用KVC</h4><pre><code>KVCObjectTest* kvcTest = [KVCObjectTest new];
       // setvalue
[kvcTest setValue:@&quot;hua&quot; forKey:@&quot;name&quot;];
       // getvalue
 NSLog(@&quot;name:%@&quot;,[kvcTest valueForKey:@&quot;name&quot;]);
</code></pre><h4 id="KVC的优点"><a href="#KVC的优点" class="headerlink" title="KVC的优点"></a>KVC的优点</h4><ul>
<li>能对对象的成员变量和私有属性进行操作  </li>
<li>自动拆装箱操作（price为CGFloat）<br><code>[obj setValue:@&quot;20.0&quot; forKey:@&quot;price&quot;];</code>  </li>
<li>对集合的操作能力<br><code>[obj setValue:objArray forKey:@&quot;relativeObjs&quot;];</code>  </li>
<li>对于集合的运算（relativeBooks为保存book对象的NSArray数组）  <pre><code>NSLog(@&quot;relativeBooksCount:%@&quot;,[book valueForKeyPath:@&quot;relativeBooks.@count&quot;]);
NSLog(@&quot;relativeBooksPrice sum:%@&quot;,[book valueForKeyPath:@&quot;relativeBooks.@sum.price&quot;]);//-价格总和
NSLog(@&quot;relativeBooksPrice avg:%@&quot;,[book valueForKeyPath:@&quot;relativeBooks.@avg.price&quot;]);//-价格的平均数
NSLog(@&quot;relativeBooksPrice max:%@&quot;,[book //-valueForKeyPath:@&quot;relativeBooks.@max.price&quot;]);
NSLog(@&quot;relativeBooksPrice min:%@&quot;,[book valueForKeyPath:@&quot;relativeBooks.@min.price&quot;]);
</code></pre></li>
<li>kvc可以在一个语句中为多个属性赋值(对属性使用字典直接赋值(用字典直接初始化一个对象的成员变量（局限性）字典中的key要和成员变量意义对应)  <pre><code>Book* book1 = [[Book alloc] init];
NSDictionary* bookPropertiesDict =@{@&quot;name&quot;:@&quot;OC入门&quot;,@&quot;price&quot;:@&quot;20.8&quot;};
[book1 setValuesForKeysWithDictionary:bookPropertiesDict];
NSLog(@&quot;%@&quot;,[book1 valueForKeyPath:@&quot;name&quot;]);
</code></pre></li>
</ul>
<h4 id="KVC的实现"><a href="#KVC的实现" class="headerlink" title="KVC的实现"></a>KVC的实现</h4><ul>
<li>KVC运用了一个isa-swizzling技术，isa-swizzling就是类型混合指针机制。KVC主要通过isa- swizzling，来实现其内部查找定位的。   </li>
<li>isa 指针  <pre><code>struct objc_class {
               Class isa;//指针，顾名思义，表示是一个什么，
               //实例的isa指向类对象，类对象的isa指向元类
               #if !__OBJC2__
               Class super_class;  //指向父类
               const char *name;  //类名
               long version;
               long info;
               long instance_size
               struct objc_ivar_list *ivars //成员变量列表
               struct objc_method_list **methodLists; //方法列表
               struct objc_cache *cache;//缓存
               //一种优化，调用过的方法存入缓存列表，下次调用先找缓存
               struct objc_protocol_list *protocols //协议列表
               #endif
           } OBJC2_UNAVAILABLE;
</code></pre></li>
<li>实例代码经过编译器之后  <pre><code>[obj setValue:@&quot;objname&quot; forKey:@&quot;name&quot;];
 就会被编译器处理成：
 SEL sel = sel_get_uid (&quot;setValue:forKey:&quot;);
 IMP method = objc_msg_lookup (obj-&gt;isa,sel);
 method(obj, sel, @&quot;objname&quot;, @&quot;name&quot;);
</code></pre></li>
<li>附加  <ul>
<li>SEL：选择器，是表示一个方法的selector的指针  <blockquote>
<p><code>typedef struct objc_selector *SEL;</code><br>Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL;本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。  </p>
</blockquote>
</li>
<li>IMP：实际上是一个函数指针，指向方法实现的首地址  <blockquote>
<p>id (*IMP)(id, SEL, …)<br> 参数1：实例方法或者是类方法 分别代表类实例的内存地址或是指向原类的指针   </p>
</blockquote>
</li>
<li>Method ：表示类定义的方法   <pre><code>typedef struct objc_method *Method;
                 struct objc_method {
                 SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名
                 char *method_types                  OBJC2_UNAVAILABLE;
                 IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现
                 }
</code></pre></li>
</ul>
</li>
</ul>
<h4 id="KVC内部的实现：一个对象在调用setValue的时候"><a href="#KVC内部的实现：一个对象在调用setValue的时候" class="headerlink" title="KVC内部的实现：一个对象在调用setValue的时候"></a>KVC内部的实现：一个对象在调用setValue的时候</h4><ul>
<li>首先根据方法名找到运行方法的时候所需要的环境参数（SEL）。   </li>
<li>他会从自己isa指针结合环境参数，找到具体的方法实现的接口（IMP）。   </li>
<li>再直接查找得来的具体的方法实现（method）。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2015/09/14/OC基础之KVO/" class="prev">上一篇</a><a href="/2015/09/08/Linux篇--常用命令/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">华子</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>