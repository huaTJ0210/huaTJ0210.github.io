<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OC基础之内存管理篇 · 華</title><meta name="description" content="OC基础之内存管理篇 - 华子"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/timg.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="華"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/timg.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/huatianjie1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/huaTJ0210" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OC基础之内存管理篇</h1><div class="post-info">May 5, 2015</div><div class="post-content"><h3 id="为什么要进行内存管理"><a href="#为什么要进行内存管理" class="headerlink" title="为什么要进行内存管理"></a>为什么要进行内存管理</h3><ul>
<li>Objective-C不像JAVA和C#等语言，内存管理依赖垃圾回收(GC)机制;它需要开发者自己管理内存，即便目前的ARC机制也只是编译器帮助开发者完成一部分工作，实际开发中还是需要时刻关注创建对象之间关系、是否出现引用循环等问题；</li>
<li>iOS程序员创建的对象大多分配在堆上，存储空间有限，在iOS系统中如果app内存使用量过大，会收到内存预警的消息，不作处理的情况下系统可能会强制清理程序；因此内存管理对移动端开发尤为重要；<a id="more"></a>
<h3 id="如何进行内存管理"><a href="#如何进行内存管理" class="headerlink" title="如何进行内存管理"></a>如何进行内存管理</h3>使用引用计数的方式对创建的对象进行内存的管理操作；有强引用指向（retain）那么引用计数+1，强引用被置为nil(release)那么引用计数-1；对象超过作用域该对象的引用计数如果为0，则系统会清理对象占用的内存空间，目前内存管理的方式分为MRC和ARC两种.      <ul>
<li>MRC：需要开发者编码追加retain/release等消息；</li>
<li>ARC：编译器为开发者追加retain/release等消息；</li>
</ul>
</li>
</ul>
<h3 id="引用计数是什么"><a href="#引用计数是什么" class="headerlink" title="引用计数是什么"></a>引用计数是什么</h3><ul>
<li>内存管理中对引用自动计数的技术；  </li>
<li>简单的说是一个数值，可以通过对象的retainCount获取 ；这个数值为0时代表给对象可以被系统回收；</li>
<li>引用计数采用散列表的方式存储，对象的内存地址作为key，value就是对象的retainCount（此结论待探讨）；  </li>
</ul>
<h3 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h3><ul>
<li>自己生成的对象自己持有（new、 alloc、 copy、 mutablecopy） ；</li>
<li>非自己生成的对象自己也能持有  ；</li>
<li>不需要自己持有的对象时释放 ；</li>
<li>非自己持有的对象无法释放 ，使用autorelease机制生成的对象，一旦持有就不需要自己释放，一旦释放就会导致崩溃问题；</li>
</ul>
<h3 id="autorelease的作用"><a href="#autorelease的作用" class="headerlink" title="autorelease的作用"></a>autorelease的作用</h3><ul>
<li>生成的对象不自己持有，但能保证对象在超出作用域范围存在并能正确地释放  </li>
<li>将对象添加到autoreleasepool中；  </li>
<li>在对象超过autoreleasepool的作用域，向对象发送release消息；</li>
<li>像NSMutableArray的类方法+array内部生成对象就使用了autorelease；</li>
</ul>
<h3 id="autorelease的实现-（GNUStep）"><a href="#autorelease的实现-（GNUStep）" class="headerlink" title="autorelease的实现  （GNUStep）"></a>autorelease的实现  （GNUStep）</h3><ul>
<li>autorelease实例方法的本质就是调用NSAutoreleasePool的addObject:类方法 ；</li>
<li>关于autorelease的频繁调用，系统的解决机制是使用”IMP Caching”,每一个类都有一个方法缓存列表，这样就能提高在运行时频繁调用某个方法的效率  ；</li>
</ul>
<h3 id="autorelease的实现-（Apple）"><a href="#autorelease的实现-（Apple）" class="headerlink" title="autorelease的实现  （Apple）"></a>autorelease的实现  （Apple）</h3><p><img src="http://upload-images.jianshu.io/upload_images/117735-74f016b97d214da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" autorelease的实现"></p>
<h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a>autoreleasepool</h3><ul>
<li>使用autorealease标记的对象都会被注册到自动释放池中，当自动释放池被drain时会向存储的对象一一发送release消息  </li>
<li>autorealeasepool类似一个堆栈，提供pop();push();removeAll();方法。一次runloop循环就会创建一个autorealeasepool，事件循环结束自动释放池销毁，对象realease；引用计数为0的销毁，不为0的可能会出现内存泄露的问题    </li>
</ul>
<h3 id="手动创建autoreleasepool的情况"><a href="#手动创建autoreleasepool的情况" class="headerlink" title="手动创建autoreleasepool的情况"></a>手动创建autoreleasepool的情况</h3><p>当开发中遇到在某个作用域内部产生大量的autorelease对象导致内存激增，需要考虑手动创建autoreleasepool来释放局部变量的情况！ </p>
<h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><h5 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h5><blockquote>
<p>持有强引用的变量会在超过其作用域的时候被释放；对应属性中的retain/strong；默认情况下的所有权修饰符是__strong;   </p>
</blockquote>
<pre><code>{
  // 自己生成并持有对象
  id _strong obj = [[NSObject alloc]init];
}// 超出作用域，强引用失效，释放对象
</code></pre><h5 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h5><ul>
<li>__weak修饰符解决的是两个强引用对象互相引用导致的引用循环所引发的内存泄露问题；  </li>
<li><strong>weak修饰符与</strong>strong 修饰符相反，不能持有对象；</li>
<li>__weak修饰符持有的对象对释放后，弱引用会被自动置为nil；  </li>
</ul>
<pre><code>{  
 id obj = [[NSObject alloc]init];
 id __weak weakObj = obj;   
}
</code></pre><ul>
<li>首先会调用函数objc_loadWeakRetained(&amp;obj);  </li>
<li>retain一下obj；但不改变引用计数;  </li>
<li>obj_autorealease()将obj注册到autorealeasepool中;  </li>
<li>全局有一个可变字典；obj的内存地址作为key值，value是所有指向obj的weak指针列表（CFMutableSet）;  </li>
<li>obj指向的内存块销毁了，对应的value中指针都为统一置为nil  </li>
</ul>
<h5 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h5><blockquote>
<p>和weak相似但不会在对象被销毁时自动置为nil（属性中对应assgin）<br>对于weak来说__unsafe_unretained性能上更加优越</p>
</blockquote>
<h5 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h5><blockquote>
<p>类似调用autorelease方法将对象添加到自动释放池中   </p>
</blockquote>
<h3 id="内存管理开发tips"><a href="#内存管理开发tips" class="headerlink" title="内存管理开发tips"></a>内存管理开发tips</h3><h5 id="ARC与Block的内存管理"><a href="#ARC与Block的内存管理" class="headerlink" title="ARC与Block的内存管理"></a>ARC与Block的内存管理</h5><blockquote>
<p> block为什么会导致循环引用？<br> 当self对象持有block，在block中也持有self；在block中会copy一个self对象作为block的一个属性；当要该属性的释放要等到block从堆中移除，而此时block要等待持有自己的self销毁，由此导致循环引用；<br> 解决方法：弱化self对象，但要在block内不防止弱化的对象过早释放，由此在block中还得再次强化已弱化的self对象   </p>
</blockquote>
<h4 id="属性的set方法MRC下的内存管理的写法"><a href="#属性的set方法MRC下的内存管理的写法" class="headerlink" title="属性的set方法MRC下的内存管理的写法"></a>属性的set方法MRC下的内存管理的写法</h4><pre><code>-(void)setName:(NSString*)newName{
  [newName retain];
  [_name release];
  _name = newName;
</code></pre><h4 id="自动释放池和线程"><a href="#自动释放池和线程" class="headerlink" title="自动释放池和线程"></a>自动释放池和线程</h4><blockquote>
<p> Cocoa程序中的每一个线程，都维护自己的自动释放池栈。如果你要写一个Foundation程序，或者卸载一个线程，你需要创建自己的autorelease池块。如果你的程序或者线程是常驻内存，并可能产生大量自动释放对象，你应该使用自动释放池（AppKit和UIKit在主线程中有自动释放池）；否则自动释放对象累积，导致内存占用增长。如果你不是Cocoa中卸载线程，你不需要使用一个自动释放池块。  </p>
</blockquote>
<h4 id="控制器移除时dealloc无法被调动"><a href="#控制器移除时dealloc无法被调动" class="headerlink" title="控制器移除时dealloc无法被调动"></a>控制器移除时dealloc无法被调动</h4><p>遇到这种情况，就需要排查控制器中出现的内存泄露了；</p>
<ul>
<li>delegate属性类型是否被声明为strong  </li>
<li>NSTime是否被被关闭  </li>
<li>block中是否造成了self的循环引用  </li>
<li>是否存在两个对象之间的强引用   </li>
</ul>
<blockquote>
<p>参考文档 </p>
<p>  <a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a><br> 《Objective-C 高级编程》 </p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2015/06/20/OC基础之消息传递/" class="prev">PREV</a><a href="/2015/04/06/iOS篇-视图/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">华子</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>