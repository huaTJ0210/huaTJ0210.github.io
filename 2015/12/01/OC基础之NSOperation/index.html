<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> OC基础之NSOperation · 華</title><meta name="description" content="OC基础之NSOperation - 华子"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/timg.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="華"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/timg.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/huatianjie1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/huaTJ0210" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">OC基础之NSOperation</h1><div class="post-info">Dec 1, 2015</div><div class="post-content"><p>对于异步执行技术GCD的API已经非常简单高效，但对于某些task之间存在依赖或是监测task的执行状态等需求GCD就显得不那么高效；因此cocoa框架中就提供了一个使用面向对象思想来解决异步操作的NSOperation,同时结合NSOperationQueue会使得异步操作更加简单高效；  </p>
<a id="more"></a>
<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>NSOperation是一个抽象基类，只能实例化子类才能使用；开发框架中已经存在了两个实例NSBlockOperation和NSInvocationOperation  </p>
<h5 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h5><p>NSBlockOperation实例化操作可以在block中执行task，并且当task只有一个的时候task在主线程中执行，当task增加时会另外创建线程执行task；</p>
<p>NSBlockOperation 在调用start方法时所有添加的task会hold住主线程，也就是所有的task执行完毕后才继续执行主线程的其他操作</p>
<p>NSBlockOperation 中添加多个task时，各个task的执行顺序不一定，但是第添加的task一定会在主线程中被执行</p>
<pre><code>NSBlockOperation* blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;blockOp1:%@&quot;,[NSThread currentThread]);
}];
[blockOperation addExecutionBlock:^{
    NSLog(@&quot;blockOp2:%@&quot;,[NSThread currentThread]);
}];
[blockOperation addExecutionBlock:^{
    NSLog(@&quot;blockOp3:%@&quot;,[NSThread currentThread]);
}];
[blockOperation addExecutionBlock:^{
    [NSThread sleepForTimeInterval:3.0f];
    NSLog(@&quot;blockOp4:%@&quot;,[NSThread currentThread]);
}];
blockOperation.completionBlock = ^{
    NSLog(@&quot;blockOperation over!&quot;);
};
[blockOperation start];
NSLog(@&quot;run over!!!:%@&quot;,[NSThread currentThread]);
/*
  HZFoundation[46406:1977543] blockOp3:&lt;NSThread: 0x100700110&gt;{number = 2, name = (null)}
  HZFoundation[46406:1977541] blockOp2:&lt;NSThread: 0x1001037c0&gt;{number = 3, name = (null)}
  HZFoundation[46406:1977517] blockOp1:&lt;NSThread: 0x100502e50&gt;{number = 1, name = main}
  HZFoundation[46406:1977542] blockOp4:&lt;NSThread: 0x100700150&gt;{number = 4, name = (null)}
  HZFoundation[46406:1977517] run over!!!:&lt;NSThread: 0x100502e50&gt;{number = 1, name = main}
 */
</code></pre><p> <strong>根据上述log的输出可用GCD模拟一下NSBlockOperation内部实现</strong>  </p>
<pre><code>  -(void)implementationBlockOperation{
// 添加task
OperationBlock block1=^{
    NSLog(@&quot;block1%@&quot;,[NSThread currentThread]);
};
OperationBlock block2=^{
    NSLog(@&quot;block2%@&quot;,[NSThread currentThread]);
};
OperationBlock block3=^{
    NSLog(@&quot;block3%@&quot;,[NSThread currentThread]);
};
OperationBlock block4=^{
    NSLog(@&quot;block4%@&quot;,[NSThread currentThread]);
};
OperationBlock block5=^{
    [NSThread sleepForTimeInterval:3.0f];
    NSLog(@&quot;block5%@&quot;,[NSThread currentThread]);
};
// 所有执行task的集合
NSArray* operationBlcoks = [NSArray arrayWithObjects:block1,block2,block3,block4,block5,nil];
//根据上面打印的block执行线程名称可以看到，线程名称各不相同，由此推测block的执行在一个并发队列中
dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.*.implementationBlockOperation&quot;, DISPATCH_QUEUE_CONCURRENT);
//打印的内容可以看到NSOperation是block住主线程的，也就是所有的任务执行完毕后才继续执行task，能够执行此操作的dispatch_group最合适
dispatch_group_t dispatchGroup = dispatch_group_create();
for (NSInteger index=0; index&lt;operationBlcoks.count; index++) {
    // 此处的状态判断是由于打印线程名称看到每次第一个任务的执行线程总是在主线程中完成的
    if (index==0) {
        // 此处处理和原设计相违背，虽然是在主线程中执行但是执行的顺序每次都是最先添加的被执行
        OperationBlock block = operationBlcoks[0];
        block();
    }else{
        dispatch_group_async(dispatchGroup, concurrentQueue, ^{
            OperationBlock block = operationBlcoks[index];
            block();
        });
    }
}
dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER);
NSLog(@&quot;implementationBlockOperation over!%@&quot;,[NSThread currentThread]);
}    
</code></pre><p>上述实现代码唯一的不足时第一task执行顺序会影响其他task，因为它总是第一个被执行，目前还没有考虑出合适的实现方法；   </p>
<h5 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h5><p>NSInvocationOperation的使用和UIControl的使用模式很相似  </p>
<pre><code>-(void)operationInvocation{
   NSInvocationOperation* operation1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationAction) object:nil];
[operation1 start];
}

-(void)operationAction{
    NSLog(@&quot;%@---&gt;&quot;,[NSThread currentThread]);
}
</code></pre><h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><pre><code>  // 创建operation
NSBlockOperation* blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;blockOp1:%@&quot;,[NSThread currentThread]);
}];
NSBlockOperation* blockOperation1 = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@&quot;blockOp2:%@&quot;,[NSThread currentThread]);
}];
// 创建operationQueue
NSOperationQueue* operationQueue = [[NSOperationQueue alloc] init];
[operationQueue addOperation:blockOperation];
[operationQueue addOperation:blockOperation1];  
[operationQueue setMaxConcurrentOperationCount:4]; // 设置task最大执行并发数
[blockOperation addDependency:blockOperation1];// operation之间添加依赖关系
[operationQueue waitUntilAllOperationsAreFinished];// 等待所有的operation执行完毕后
[operationQueue cancelAllOperations];//取消所有operation操作  
</code></pre><blockquote>
<p>资料来源 <a href="http://nshipster.cn/nsoperation/" target="_blank" rel="external">NShipster之NSOperation</a> </p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2015/12/03/OC基础之GCD/" class="prev">上一篇</a><a href="/2015/12/01/OC基础之类与对象/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">华子</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>