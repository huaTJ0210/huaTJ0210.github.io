<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>華</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-08T04:45:28.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>华子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS篇-页面优化（-）</title>
    <link href="http://yoursite.com/2018/07/04/iOS%E7%AF%87-%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%EF%BC%88-%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/04/iOS篇-页面优化（-）/</id>
    <published>2018-07-04T14:57:54.000Z</published>
    <updated>2018-07-08T04:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文主要涉及到的知识点："><a href="#本文主要涉及到的知识点：" class="headerlink" title="本文主要涉及到的知识点："></a>本文主要涉及到的知识点：</h3><ul><li>图像显示原理  </li><li>CPU和GPU的职责</li><li>UI卡顿掉帧的原因</li><li>视图的绘制</li><li>视图的异步绘制</li><li>离屏渲染</li><li>性能优化的集合  </li></ul><a id="more"></a><h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><p>CPU和GPU两个硬件通过总线相连接，CPU负责视图的计算，GPU负责视图渲染，GPU将渲染的位图提交给帧缓冲区（frame buffer），视频控制器接收到VSync信号后将位图在显示器上显示；<br><img src="https://upload-images.jianshu.io/upload_images/117735-1f696b1bc58ad56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图像显示原理.png">    </p><p><strong>对应具体视图的显示</strong><br><img src="https://upload-images.jianshu.io/upload_images/117735-b1a696a84cd46d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.39.30.png"></p><h3 id="CPU和GPU的职责"><a href="#CPU和GPU的职责" class="headerlink" title="CPU和GPU的职责"></a>CPU和GPU的职责</h3><p> <strong>CPU的主要职责</strong>    </p><ul><li>Layout -&gt; UI布局【自动布局】、文本计算</li><li>Display -&gt; 绘制【Core Graphics绘制：为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢】</li><li>Prepare -&gt; 图片的编解码【PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸;iOS只有在真正绘制的时候才去解压】</li><li>Commit -&gt; 将位图提交给GPU  </li></ul><p><strong>GPU的主要职责</strong>   </p><ul><li>将图层内容渲染到屏幕上   </li></ul><p><strong>影响GPU的操作</strong>    </p><ul><li>太多的几何结构，视图层级复杂</li><li>重绘：由重叠的半透明图层引起 </li><li>离屏绘制：不能直接在屏幕上绘制，必须绘制到离屏图片上下文中  </li><li>过大的图片  </li></ul><h3 id="UI卡顿掉帧的原因"><a href="#UI卡顿掉帧的原因" class="headerlink" title="UI卡顿掉帧的原因"></a>UI卡顿掉帧的原因</h3><p>在页面滑动流畅一般是60FPS，也就是16.7ms要产生一帧的图像渲染出来，如果CPU+GPU在一次VSync信号结束的16.7ms内没有产生一个帧图像在屏幕中显示就会产生卡顿掉帧；<br><img src="https://upload-images.jianshu.io/upload_images/117735-a22f468c86495bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.44.28.png">  </p><h3 id="视图的绘制"><a href="#视图的绘制" class="headerlink" title="视图的绘制"></a>视图的绘制</h3><p>如下图所示，UIView在接收到setNeedsDisplay的时候并不会直接进行视图的绘制工作，而是等整个流程走完，在当前runloop快结束的时候才会调用setNeedsDisplay标记的视图的drawRect方法<br><img src="https://upload-images.jianshu.io/upload_images/117735-4977b484d21e0045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.54.03.png">  </p><p><img src="https://upload-images.jianshu.io/upload_images/117735-8b1ebc403dec24c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午10.02.06.png"></p><h3 id="视图的异步绘制"><a href="#视图的异步绘制" class="headerlink" title="视图的异步绘制"></a>视图的异步绘制</h3><p><img src="https://upload-images.jianshu.io/upload_images/117735-52c1e98b800ef016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午10.06.29.png"></p><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p><strong>GPU的渲染分为两种</strong>   </p><ul><li>On-Screen Rendering (当前屏幕渲染)：GPU的渲染是在当前用于显示的屏幕缓冲区进行的  </li><li>Off-Screen Rendering（离屏渲染）：GPU在当前屏幕缓冲区以外开辟一个缓存区进行渲染操作</li></ul><p><strong>离屏渲染的坏处</strong>  </p><ul><li>创建新缓冲区：要进行离屏渲染，首先要创建一个新的缓冲区  </li><li>上下文切换：离屏渲染的整个过程，要多次切换上下文，On-Screen -&gt; Off-Screen ,当离屏渲染结束后要将渲染结果显示，需要将上下文再次切换回来，而上下文的切换代价很大  </li></ul><p><strong>会触发离屏渲染的操作</strong>   </p><ul><li>为图层设置遮罩（layer.mask）</li><li>layer.masksToBounds/view.clipsToBounds 设置为true</li><li>layer.opacity小于1.0</li><li>layer.shadow</li><li>layer.cornerRadius</li><li>drawRect中进行绘制  </li></ul><p><strong>如何优化离屏渲染</strong>  </p><ul><li>控件圆角的设置：CAShaperLayer/Core Graphics 结合UIBezierPath 绘制圆角 </li><li>阴影的绘制：设置shadowPath</li><li>使用instrument的Core Animation检测：图层的离屏渲染、图层是否透明</li></ul><h3 id="性能优化的集合"><a href="#性能优化的集合" class="headerlink" title="性能优化的集合"></a>性能优化的集合</h3><ul><li>避免使用CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:<br>原因：实现这两个方法中的其中之一就必须需要一个绘制上下文，这个上下文的大小基本和原有图层的内存占有量一致；所以重绘的代价太高 </li><li>对于Core Graphics 可以使用CAShapLayer来替换绘制图形、直线和曲线，使用CATextLayer绘制文本，CAGradientLayer绘制渐变 </li><li>列表加载远程图片，直接加载会导致界面卡顿；因为图片资源大，导致加载时间长；在另外的线程中加载图片，在主线程中更新显示内容【SDWebImageView】</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文主要涉及到的知识点：&quot;&gt;&lt;a href=&quot;#本文主要涉及到的知识点：&quot; class=&quot;headerlink&quot; title=&quot;本文主要涉及到的知识点：&quot;&gt;&lt;/a&gt;本文主要涉及到的知识点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;图像显示原理  &lt;/li&gt;
&lt;li&gt;CPU和GPU的职责&lt;/li&gt;
&lt;li&gt;UI卡顿掉帧的原因&lt;/li&gt;
&lt;li&gt;视图的绘制&lt;/li&gt;
&lt;li&gt;视图的异步绘制&lt;/li&gt;
&lt;li&gt;离屏渲染&lt;/li&gt;
&lt;li&gt;性能优化的集合  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>生活篇--说说三观</title>
    <link href="http://yoursite.com/2017/06/04/%E7%94%9F%E6%B4%BB%E7%AF%87--%E8%AF%B4%E8%AF%B4%E4%B8%89%E8%A7%82/"/>
    <id>http://yoursite.com/2017/06/04/生活篇--说说三观/</id>
    <published>2017-06-04T09:37:48.000Z</published>
    <updated>2018-06-23T04:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="人生观"><a href="#人生观" class="headerlink" title="人生观"></a>人生观</h3><blockquote><p>对于人生的根本态度与看法  </p></blockquote><p>   人生千姿百态，每个人都是一个演员在无剧本的人生舞台上做着自己的表演。有句话说<strong>意识决定形态</strong>，我个人浅显的理解就是你自己的意愿想通过哪种姿态展现自己， 那么在世人面前你就是以哪种姿态呈现。<br>有时候我们会感慨某某活成了我们自己想要的模样，其实本质上我们都有活成某种模样的意识但最终为什么差别很大？主要原因是缺乏行动，多数人都具有正确的人生观：积极生活、努力奋斗、追求幸福等；但又有多少勤勤恳恳的去实践自己的人生观呢？经常会听到说这人的做事态度不错，但请不要忘记最终衡量你的还是做事的结果。获取正确的人生观容易，困难的是通过正确的人生观来让生活极大丰富才是最困难的事情！<br><a id="more"></a></p><h4 id="人生观主要包含哪些"><a href="#人生观主要包含哪些" class="headerlink" title="人生观主要包含哪些"></a>人生观主要包含哪些</h4><ul><li>友谊观</li><li>恋爱观</li><li>审美观</li><li>道德观</li><li>苦乐观</li><li>幸福观</li></ul><h3 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h3><blockquote><p>它是人们对世界的基本看法和观点.世界观具有实践性，人的世界观是不断更新、不断完善、不断优化的；  </p></blockquote><p>世界观确实是在不断的更新中的，<strong>世界那么大，我想去看看</strong>本质上的追求是去丰富自己的世界观的，而不是仅仅看看风景，发发朋友圈而已。去一个地方应该在欣赏美景的同时去了解风土人情，通过比较差异来完善自己的认知，使得自己更为的丰富。</p><h3 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h3><blockquote><p> 用以区分好与坏的标准，是根据个人内心的尺度进行衡量和评价的，这些标准都可以称为价值观。  </p></blockquote><p>我们日常会听到<strong>某某的价值观出了问题</strong>，其实呢我们是在说某人对于问题的评判或者是做的某些行为严重的偏离了我们正常的认知；那么具体什么是正确的价值观呢？这个问题需要我们自己不断的去探寻、去学习。有些价值观是父母师长等人群灌输的；例如孝敬长者，尊师重道等基本的道德要求；真善美与假恶丑是需要自己去分辨的。特别是目前我们处于互联网时代，言论自由，你对于每一个事件的看法都是你价值观的体现；平时和朋友相处也是，交谈中你的价值观就被反应出来了，价值观一致的人才适合一起玩耍的！</p><h3 id="婚姻观"><a href="#婚姻观" class="headerlink" title="婚姻观"></a>婚姻观</h3><blockquote><p>对婚姻和家庭的看法和态度。</p></blockquote><p>我个人一直遵守家庭第一，其他第二的原则；把家庭照顾好了的前提下再向<em>大家</em>奉献，我觉得才是理想的状态。因为每个人的人生观不同所以也就没有评判对与错的必要；</p><h4 id="幸福婚姻应该包含哪些要素"><a href="#幸福婚姻应该包含哪些要素" class="headerlink" title="幸福婚姻应该包含哪些要素"></a>幸福婚姻应该包含哪些要素</h4><ul><li>童心</li><li>浪漫</li><li>幽默</li><li>亲昵</li><li>情话</li><li>沟通</li><li>欣赏</li></ul><p>日常我们经常听到<strong>三观尽毁</strong>和<strong>三观正才能一起玩耍</strong>；一直以来都没有好好的思考自己的<strong>三观</strong>到底是什么？其实我的日常生活中存在很多这样的习以为常的问题都被自己忽略了，真的很不应该，问题是应该被解决的，时间不会将它带走！追求简单生活，不要要逃避问题，而是要解决复杂的问题，这样生活才会简单！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;人生观&quot;&gt;&lt;a href=&quot;#人生观&quot; class=&quot;headerlink&quot; title=&quot;人生观&quot;&gt;&lt;/a&gt;人生观&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对于人生的根本态度与看法  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   人生千姿百态，每个人都是一个演员在无剧本的人生舞台上做着自己的表演。有句话说&lt;strong&gt;意识决定形态&lt;/strong&gt;，我个人浅显的理解就是你自己的意愿想通过哪种姿态展现自己， 那么在世人面前你就是以哪种姿态呈现。&lt;br&gt;有时候我们会感慨某某活成了我们自己想要的模样，其实本质上我们都有活成某种模样的意识但最终为什么差别很大？主要原因是缺乏行动，多数人都具有正确的人生观：积极生活、努力奋斗、追求幸福等；但又有多少勤勤恳恳的去实践自己的人生观呢？经常会听到说这人的做事态度不错，但请不要忘记最终衡量你的还是做事的结果。获取正确的人生观容易，困难的是通过正确的人生观来让生活极大丰富才是最困难的事情！&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随感" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之AssociatedObject</title>
    <link href="http://yoursite.com/2017/03/10/OC%E5%9F%BA%E7%A1%80%E4%B9%8BAssociatedObject/"/>
    <id>http://yoursite.com/2017/03/10/OC基础之AssociatedObject/</id>
    <published>2017-03-10T05:55:00.000Z</published>
    <updated>2018-07-08T06:07:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AssociatedObject-关联对象"><a href="#AssociatedObject-关联对象" class="headerlink" title="AssociatedObject(关联对象)"></a>AssociatedObject(关联对象)</h3><p> 在既有类中使用关联对象存放自定义数据，分类中添加属性也会用到   </p><ul><li>给对象存储信息，通常会创建对象所属类的子类；但某些情况下无法创建子类（分类），只能通过关联属性值的方式</li><li>关联属性值可能会出现循环引用问题</li></ul><h3 id="AssociatedObject实现原理"><a href="#AssociatedObject实现原理" class="headerlink" title="AssociatedObject实现原理"></a>AssociatedObject实现原理</h3><p> 通过objc_setAssociatedObject给分类创建的属性放在了一个全局的AssociationManager中；<br> 通过对象的地址找到AssociationManager中的hashMap，然后通过属性的Key来获取属性的value；   </p><h3 id="AssociatedObject具体使用"><a href="#AssociatedObject具体使用" class="headerlink" title="AssociatedObject具体使用"></a>AssociatedObject具体使用</h3><pre><code>    #import &quot;AssociatedObject.h&quot;#import &lt;objc/runtime.h&gt;@implementation AssociatedObjectstatic void* associatedObjectKey = &quot;associatedObjectKey&quot;;-(void)askQuestion{    void (^block)(NSInteger index)= ^(NSInteger index){        if (0 == index) {            [self confrim];        }else if (1 == index){            [self cancel];        }    };    objc_setAssociatedObject(self, associatedObjectKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC);}-(void)associated:(AssociatedObject*)associated index:(NSInteger)index{    void (^block)(NSInteger index) = objc_getAssociatedObject(associated, associatedObjectKey);    block(index);}-(void)confrim{  // Class test_class = [NSString class];}-(void)cancel{}@end</code></pre><p> 文章参考：<br> <a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AssociatedObject-关联对象&quot;&gt;&lt;a href=&quot;#AssociatedObject-关联对象&quot; class=&quot;headerlink&quot; title=&quot;AssociatedObject(关联对象)&quot;&gt;&lt;/a&gt;AssociatedObject(关联对象)
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之分类-Category</title>
    <link href="http://yoursite.com/2017/03/04/OC%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%86%E7%B1%BB-Category/"/>
    <id>http://yoursite.com/2017/03/04/OC基础之分类-Category/</id>
    <published>2017-03-04T14:57:54.000Z</published>
    <updated>2018-07-08T05:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>在Objective-C语言中Category可以在不修改原有类文件的情况下，为类添加方法；在Category文件中所添加的内容包括<strong>方法（实例方法、类方法）</strong>、<strong>协议</strong>、<strong>属性</strong>;其中属性的实现还需要根据关联对象来辅助实现；  </p><h3 id="分类的具体实现原理"><a href="#分类的具体实现原理" class="headerlink" title="分类的具体实现原理"></a>分类的具体实现原理</h3><p> 以下是runtime源码中对于分类具体实现的大致调用顺序   </p><pre><code>  // 加载所有头文件，并从头文件中获取分类列表void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){   // 重新调整宿主类的结构，包括：添加方法、属性、协议等   remethodizeClass(Class cls) {      // 将分类中的内容添加到宿主类中      attachCategories(Class cls, category_list *cats, bool flush_caches){            // 如何添加的具体实现            attachLists(List* const * addedLists, uint32_t addedCount){             }      }  } } </code></pre><a id="more"></a>      <h3 id="分类的常见问题"><a href="#分类的常见问题" class="headerlink" title="分类的常见问题"></a>分类的常见问题</h3><ul><li>分类中出现与宿主类同名的方法，会出现什么问题？ ==》宿主中的方法会失效，调用的时候会使用分类的方法，不建议定义相同的名称；</li><li>出现多个分类文件，分类文件中存在相同方法时，调用方法时会出现什么问题？==》最后被编译的分类文件中的方法会生效 ，具体原因查看<code>attachLists</code>的代码实现；  </li></ul><h3 id="分类实现原理的代码解析"><a href="#分类实现原理的代码解析" class="headerlink" title="分类实现原理的代码解析"></a>分类实现原理的代码解析</h3><h4 id="read-images"><a href="#read-images" class="headerlink" title="_read_images()"></a>_read_images()</h4><p>  <code>_read_images()</code> 方法在获取分类时，第一步：遍历加载的.h文件列表，然后获取分类列表；第二部：将分类列表中的方法转换为一个二维数组<code>[[method1,method2,method3],[method4,method5],[method6]]</code>;第三步将二维数组中的每个元素包含的方法再添加到宿主类的<code>method_list</code>中；<strong>分类中的方法是添加在<code>method_list</code>头部</strong>   </p><pre><code>  void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){/*   Discover categories.   + 遍历所有.h文件，获取分类列表   + 将分类列表中的方法通过倒序遍历得到一个二维数组==&gt;[[method1,method2,method3],[method4,method5],[method6]]; */for (EACH_HEADER) {    category_t **catlist =    _getObjc2CategoryList(hi, &amp;count);    bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();    for (i = 0; i &lt; count; i++) {        category_t *cat = catlist[i];        Class cls = remapClass(cat-&gt;cls);        if (!cls) {            // Category&apos;s target class is missing (probably weak-linked).            // Disavow any knowledge of this category.            catlist[i] = nil;            if (PrintConnecting) {                _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;                             &quot;missing weak-linked target class&quot;,                             cat-&gt;name, cat);            }            continue;        }        /*          将二维数组中的每一个数组中的method添加到原生方法列表中         */        bool classExists = NO;        if (cat-&gt;instanceMethods ||  cat-&gt;protocols            ||  cat-&gt;instanceProperties)        {            addUnattachedCategoryForClass(cat, cls, hi);            if (cls-&gt;isRealized()) {                remethodizeClass(cls);                classExists = YES;            }            if (PrintConnecting) {                _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,                             cls-&gt;nameForLogging(), cat-&gt;name,                             classExists ? &quot;on existing class&quot; : &quot;&quot;);            }        }        if (cat-&gt;classMethods  ||  cat-&gt;protocols            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))        {            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);            if (cls-&gt;ISA()-&gt;isRealized()) {                remethodizeClass(cls-&gt;ISA());            }            if (PrintConnecting) {                _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,                             cls-&gt;nameForLogging(), cat-&gt;name);            }        }    }}ts.log(&quot;IMAGE TIMES: discover categories&quot;);// Category discovery MUST BE LAST to avoid potential races// when other threads call the new category code before}   #undef EACH_HEADER}   </code></pre><h4 id="remethodizeClass-Class-cls"><a href="#remethodizeClass-Class-cls" class="headerlink" title="remethodizeClass(Class cls)"></a>remethodizeClass(Class cls)</h4><p><code>remethodizeClass(Class cls)</code> 重新调整class，利用<code>attachCategories</code>将分类内容添加到宿主类中   </p><pre><code>static void remethodizeClass(Class cls){category_list *cats;bool isMeta;runtimeLock.assertWriting();isMeta = cls-&gt;isMetaClass();// Re-methodizing: check for more categoriesif ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {    if (PrintConnecting) {        _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,                      cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);    }    //     attachCategories(cls, cats, true /*flush caches*/);            free(cats);}}      </code></pre><hr><h4 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a>attachCategories</h4><p><code>attachCategories(Class cls, category_list *cats, bool flush_caches)</code>  将分类中的方法、属性、协议添加到宿主类中       </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123;</div><div class="line">if (!cats) return;</div><div class="line">if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line">bool isMeta = cls-&gt;isMetaClass();</div><div class="line">// fixme rearrange to remove these intermediate allocations</div><div class="line">method_list_t **mlists = (method_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*mlists));</div><div class="line">property_list_t **proplists = (property_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*proplists));</div><div class="line">protocol_list_t **protolists = (protocol_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*protolists));</div><div class="line">// Count backwards through cats to get newest categories first</div><div class="line">int mcount = 0;</div><div class="line">int propcount = 0;</div><div class="line">int protocount = 0;</div><div class="line">int i = cats-&gt;count;</div><div class="line">bool fromBundle = NO;</div><div class="line">while (i--) &#123;</div><div class="line">    auto&amp; entry = cats-&gt;list[i];</div><div class="line">    method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">    if (mlist) &#123;</div><div class="line">        mlists[mcount++] = mlist;</div><div class="line">        fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">    &#125;</div><div class="line">    property_list_t *proplist = </div><div class="line">        entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class="line">    if (proplist) &#123;</div><div class="line">        proplists[propcount++] = proplist;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class="line">    if (protolist) &#123;</div><div class="line">        protolists[protocount++] = protolist;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">auto rw = cls-&gt;data();</div><div class="line">prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">// 添加方法</div><div class="line">rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">free(mlists);</div><div class="line">if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class="line">// 添加属性</div><div class="line">rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">free(proplists);</div><div class="line">// 添加协议</div><div class="line">rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">free(protolists);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h4 id="attachLists"><a href="#attachLists" class="headerlink" title="attachLists"></a>attachLists</h4><p><code>void attachLists(List* const * addedLists, uint32_t addedCount)</code>主要是将分类中的内容添加到宿主类中；以method为例；第一步<br>扩充宿主元素的method_list得容量，具体扩充多少，由 要添加多少新方法来决定；第二步将宿主方法列表中的元素向后移动位置；第三步：将分类中的方法一次填充到宿主元素的methodList中；   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class="line">    if (addedCount == 0) return;</div><div class="line">    if (hasArray()) &#123;</div><div class="line">        // many lists -&gt; many lists</div><div class="line">        uint32_t oldCount = array()-&gt;count;</div><div class="line">        uint32_t newCount = oldCount + addedCount;</div><div class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">        array()-&gt;count = newCount;</div><div class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, </div><div class="line">                oldCount * sizeof(array()-&gt;lists[0]));</div><div class="line">        memcpy(array()-&gt;lists, addedLists, </div><div class="line">               addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">    &#125;</div><div class="line">    else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class="line">        // 0 lists -&gt; 1 list</div><div class="line">        list = addedLists[0];</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">        // 1 list -&gt; many lists</div><div class="line">        List* oldList = list;</div><div class="line">        uint32_t oldCount = oldList ? 1 : 0;</div><div class="line">        uint32_t newCount = oldCount + addedCount;</div><div class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class="line">        array()-&gt;count = newCount;</div><div class="line">        if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class="line">        memcpy(array()-&gt;lists, addedLists, </div><div class="line">               addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>文章参照  <a href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/" target="_blank" rel="external">Objective-C Category 的实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h3&gt;&lt;p&gt;在Objective-C语言中Category可以在不修改原有类文件的情况下，为类添加方法；在Category文件中所添加的内容包括&lt;strong&gt;方法（实例方法、类方法）&lt;/strong&gt;、&lt;strong&gt;协议&lt;/strong&gt;、&lt;strong&gt;属性&lt;/strong&gt;;其中属性的实现还需要根据关联对象来辅助实现；  &lt;/p&gt;
&lt;h3 id=&quot;分类的具体实现原理&quot;&gt;&lt;a href=&quot;#分类的具体实现原理&quot; class=&quot;headerlink&quot; title=&quot;分类的具体实现原理&quot;&gt;&lt;/a&gt;分类的具体实现原理&lt;/h3&gt;&lt;p&gt; 以下是runtime源码中对于分类具体实现的大致调用顺序   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 加载所有头文件，并从头文件中获取分类列表
void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){
   // 重新调整宿主类的结构，包括：添加方法、属性、协议等
   remethodizeClass(Class cls) {
      // 将分类中的内容添加到宿主类中
      attachCategories(Class cls, category_list *cats, bool flush_caches){
            // 如何添加的具体实现
            attachLists(List* const * addedLists, uint32_t addedCount){
             }
      }
  } } 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程初识(一)</title>
    <link href="http://yoursite.com/2016/12/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E8%AF%86-%E4%B8%80/"/>
    <id>http://yoursite.com/2016/12/12/JAVA多线程初识-一/</id>
    <published>2016-12-12T05:58:17.000Z</published>
    <updated>2017-02-21T03:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h4><blockquote><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流;<br><a id="more"></a></p></blockquote><h4 id="如何实现在一个单独的线程中执行一个任务"><a href="#如何实现在一个单独的线程中执行一个任务" class="headerlink" title="如何实现在一个单独的线程中执行一个任务"></a>如何实现在一个单独的线程中执行一个任务</h4><h5 id="（1）创建执行task的类实现Runnable接口的run方法"><a href="#（1）创建执行task的类实现Runnable接口的run方法" class="headerlink" title="（1）创建执行task的类实现Runnable接口的run方法"></a>（1）创建执行task的类实现Runnable接口的run方法</h5><pre><code>package Test.Thread;public class MyRunnable implements Runnable{        public void run(){        System.out.println(Thread.currentThread());    }}</code></pre><h5 id="2-调用端创建Thread实例对象调用start方法"><a href="#2-调用端创建Thread实例对象调用start方法" class="headerlink" title="(2)调用端创建Thread实例对象调用start方法"></a>(2)调用端创建Thread实例对象调用start方法</h5><pre><code>package Test.Thread;public class TestTread {public static void main(String[] args) {    // TODO Auto-generated method stub        // 当前线程    System.out.println(Thread.currentThread());    Runnable run = (Runnable) new MyRunnable();    Thread thread = new Thread(run);    thread.start();    System.out.println(&quot;task excute over!&quot;);  }}</code></pre><p>以上两个步骤就实现了新创建一个线程执行另外一个Task的操作；  </p><h4 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h4><p>线程的中断有两种情况（1）run方法正常执行完所有的操作；（2）run方法中出现没有捕获的异常；API中提供interrupt方法用来请求终止线程； </p><pre><code>package Test.Thread;public class MyRunnable implements Runnable{        public void run(){        System.out.println(Thread.currentThread());        // 新线程执行的任务        try {            // 测试线程是否被终止，不会改变线程的中断状态(线程被堵塞就无法判断)            if(!Thread.currentThread().isInterrupted()){                    Thread.currentThread();                Thread.sleep(3000);            }        } catch (InterruptedException e) {            System.out.println(e);            // TODO Auto-generated catch block            // 向线程发送中断请求。线程的中断状态会被置为true；如果线程目前被一个sleep阻塞，那么InterruptedException被抛出            Thread.currentThread().interrupt();            e.printStackTrace();        }        Thread.currentThread();        // 测试线程是否被终止，会改变线程的中断状态,线程的中断状态会被置为false        if(Thread.interrupted()){                System.out.println(&quot;isInterrupted&quot;);        }else{                System.out.println(&quot;not is Interrupted!!!&quot;);        }        // 此时因为调用了Thread.interrupted()，此时线程的中断状态被置为false        if(!Thread.currentThread().isInterrupted()){                System.out.println(&quot;thread is Interrupted!!!&quot;);        }        }}</code></pre><p>java 中提供了 void interrupt()、static boolen interrupted()、boolean isInterrupted()来发送中断请求具体的区别详细见上述代码注释；</p><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><ul><li>New（新创建）</li><li>Runnable(可运行)</li><li>Blocked(被阻塞)</li><li>Waiting(等待)</li><li>Timed waiting(计时等待)</li><li>Terminated(被终止)</li></ul><h5 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h5><p> 使用 new Thread(r)；创建一个Thread实例对象，此时线程处于新创建状态 </p><h5 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h5><p> 一旦调用start方法，线程就进入runnable状态（不一定立即运行这个取决于系统的分配的时间）</p><h5 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h5><p> 阻塞：线程访问资源遇到加锁机制，他需要等待锁对象被释放才能进入非堵塞状态；<br> 等待：一个线程等待另一个线程的通知调度才能进入非等待状态；</p><h5 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h5><p> （1）run方法的正常退出而自然死亡（2）一个没有捕获的异常终止run方法而意外死亡；</p><h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>java中的线程优先级定义在MIN_PRIORITY(1)到MAX_PRIORITY(10)之间任何值；NORM_PRIORITY被定义为5；<br>void setPriority(int newPriority)可以设置优先级，但并不推荐使用；</p><h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p>void setDaemon(boolean isDaemon);该方法可以将线程转化为守护线程；他唯一的作用是为其他线程提供服务；使用守护线程要避免访问固有的资源，如文件、数据库，因为他任意时候都可能在一个操作的中间发生中断； </p><h5 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h5><p>run方法中出现的异常是无法使用try…catch捕获，只能为线程添加未捕获异常的处理器；<br>该处理器需要重写UncaughtExceptionHandler接口中的<code>void uncaughtException(Thread arg0,Throwable arg1)</code>方法，具体参照下列代码； </p><pre><code>package Test.Thread;import java.lang.Thread.UncaughtExceptionHandler;public class MyCrashHandler implements UncaughtExceptionHandler {   @Override   public void uncaughtException(Thread arg0,Throwable arg1){       System.out.println(&quot;线程出现问题！&quot;);   }}</code></pre><p>调用端只要为当前创建的Thread实例添加未捕获异常处理器即可   </p><pre><code>package Test.Thread;public class TestTread {public static void main(String[] args) {    // TODO Auto-generated method stub        // 当前线程    System.out.println(Thread.currentThread());    Runnable run = (Runnable) new MyRunnable();    Thread thread = new Thread(run);    // 为线程添加未捕获异常处理器    thread.setUncaughtExceptionHandler(new MyCrashHandler());;    thread.start();    System.out.println(&quot;task excute over!&quot;);   }}</code></pre><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>多线程编程时遇到的一个问题是多个子线程访问同一个数据源，在读写操作的时候导致异常出现；为了避免出现这种问题就会对多线程采用同步处理数据资源的机制；  </p><h5 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h5><p>java中提供的ReentrantLock锁来处理这种资源竞争问题 </p><pre><code>// 具体使用类似下列代码块  myLock.lock();   try{   }catch(Exception e){   }finally{       myLock.unlock();   }</code></pre><p>这样就能保证任何时刻只有一个线程进入临界区，当一个线程持有了锁对象，其他线程就被阻塞；直到所对象被持有的线程释放；   </p><h5 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h5><p>所谓的条件对象就是给锁L加一个条件限制，当A线程被锁L阻塞且不满足条件时线程A被阻塞，同时线程A放弃对当前锁L的等待获取（即使锁L被其他线程释放，线程A也不会去持有锁L），线程A被加入到了条件限制的等待集中；直到条件调用了signalAll()方法才会重新激活线程A；    </p><pre><code>package unsynch;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Bank {    private final double[] accounts;    // 所对象    private Lock bankLock;    // 条件对象    private Condition sufficientFunds;    // 构造器    public Bank(int n,double initialBalance){            accounts = new double[n];        for (int i = 0; i &lt; accounts.length; i++) {            accounts[i] = initialBalance;        }        bankLock = new ReentrantLock();        // 为锁添加条件对象        sufficientFunds = bankLock.newCondition();    }public void transfer(int from,int to ,double amount){        bankLock.lock();// 添加锁对象    try{        // 只有当当前账户的金额大于转出金额才能进行转账操作        while(accounts[from] &lt; amount)             //调用await()使得不满足条件的线程放弃对当前锁对象的索取；            sufficientFunds.await();        System.out.println(Thread.currentThread());        accounts[from] -= amount;        System.out.printf(&quot;%10.2f from %d to %d&quot;,amount,from,to);        accounts[to] += amount;        System.out.printf(&quot;Total Balance:%10.2f%n&quot;,getTotalBalance());        // 将加入到条件集合中的线程激活        sufficientFunds.signalAll();    }catch(Exception e){    }finally{            // 解锁操作        bankLock.unlock();    }}public double getTotalBalance(){        double sum = 0;    for(double a : accounts){            sum += a;    }    return sum ;}public int size(){        return accounts.length; }}   </code></pre><h5 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h5><p>使用synchronized 修饰方法其功能和加锁并添加条件对象一样，但代码要简洁很多；但平时使用上并不建议使用Lock和Condition以及synchronized来处理这类问题；java中提供了阻塞队列来实现。</p><pre><code>package unsynch;public class Bank {    private final double[] accounts;    // 构造器    public Bank(int n,double initialBalance){            accounts = new double[n];        for (int i = 0; i &lt; accounts.length; i++) {            accounts[i] = initialBalance;        }    }    public synchronized void transfer(int from,int to ,double amount){        try{            // 只有当当前账户的金额大于转出金额才能进行转账操作            while(accounts[from] &lt; amount)                 //调用wait()使得不满足条件的线程放弃对当前锁对象的索取；                wait();            System.out.println(Thread.currentThread());            accounts[from] -= amount;            System.out.printf(&quot;%10.2f from %d to %d&quot;,amount,from,to);            accounts[to] += amount;            System.out.printf(&quot;Total Balance:%10.2f%n&quot;,getTotalBalance());            // 将加入到条件集合中的线程激活            notifyAll();        }catch(Exception e){        }}public double getTotalBalance(){        double sum = 0;    for(double a : accounts){            sum += a;    }    return sum ;}public int size(){        return accounts.length;}}   </code></pre><h5 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h5><p> volatile关键字为实例域的同步访问提供了一种免锁机制；这样多线程访问实例域对象时就能保证线程安全</p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><blockquote><p>上述内容是java并发程序设计基础的底层构建块，实际编程中应该远离这些API的使用，选择更高级的并发处理方式解决遇到的并发问题，这样才能使得编程方面，也更加的安全。   </p></blockquote><h5 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h5><blockquote><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p></blockquote><h5 id="JAVA中提供的阻塞队列"><a href="#JAVA中提供的阻塞队列" class="headerlink" title="JAVA中提供的阻塞队列"></a>JAVA中提供的阻塞队列</h5><ul><li>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。  </li><li>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。  </li><li>PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。  </li><li>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素；  <ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。我们可以将DelayQueue运用在以下应用场景  </li><li>定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。 </li></ul></li></ul><h4 id="Callable-与-Future"><a href="#Callable-与-Future" class="headerlink" title="Callable 与 Future"></a>Callable 与 Future</h4><p>Callable和Runnable类似，只是Callable接口有返回值并且是一个参数化的类型，它有一个call方法；  </p><pre><code>public interface Callable&lt;V&gt;{    V call() throws Exception;}</code></pre><p>Future保存异步计算的结果   </p><pre><code>public interface Future&lt;V&gt;{// 计算未完成调用会发生堵塞   V get() throws...;  // 计算完成之前调用会超时，并且抛出TimeoutException异常   V get(long timeout,TimeUnit unit)throws...;   // cancel可以取消该计算   void cancel(boolean mayInterrupt);   boolean isCancelled();   // 如果计算还在进行 isDone方法会返回false   boolean isDone();} </code></pre><p>FutureTask包装器可以将Callable转换成Future和Runnable它同时实现两者的接口；</p><pre><code>Callable&lt;Integer&gt;myCompution = ...;FutureTask&lt;Integer&gt; task = new  FutureTask&lt;Integer&gt; (myCompution) ;Thread thread = new Thread(task);thread.start();...Integer result = task.get();// 对get调用会阻塞线程，直到获取结果为止 </code></pre><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><h5 id="什么是线程池，以及线程池有什么作用？"><a href="#什么是线程池，以及线程池有什么作用？" class="headerlink" title="什么是线程池，以及线程池有什么作用？"></a>什么是线程池，以及线程池有什么作用？</h5><p>线程池是用来包含多个准备运行的空闲线程，线程池持有Runnable对象，此时就会有一个线程调用run方法，run方法执行完毕后，线程也不会死亡，而是在线程池中为下一个请求提供服务；线程池的另外一个作用是减少并发线程的数量；<br>执行器Excutor类有许多静态方法可以创建线程池；  </p><ul><li>newCachedTheadPool 必要时创建线程，空闲线程会被停留60秒；  </li><li>newFixedThreadPool 该池包含固定数量的线程，空闲线程会一直被保存；</li><li>newSingleThreadPool 只有一个线程池，该线程的顺序执行每一个任务</li><li>newScheduledThreadPool 用于预定执行而创建的固定线程池  </li><li>newSingleThreadScheduledExcutor 用于预定执行而创建的单线程池   </li></ul><h5 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h5><blockquote><p>Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p></blockquote><h6 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h6><blockquote><p>使用Fork／Join框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork／Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果   </p></blockquote><pre><code>package fork.join.text;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;import Test.Thread.MyCrashHandler;import Test.Thread.MyRunnable;public class CountTask extends RecursiveTask&lt;Integer&gt; {public static void main(String[] args){    ForkJoinPool forkJoinPool = new ForkJoinPool();    CountTask task = new CountTask(1, 4);    Future&lt;Integer&gt; result = forkJoinPool.submit(task);    try{        System.err.println(result.get());    }catch(InterruptedException e){    }catch(ExecutionException e){    }}private static final int THRESHOLD = 2;// 阈值private int start;private int end;public CountTask(int start,int end){        this.start = start;    this.end = end;}@Overrideprotected Integer compute(){    int sum = 0 ;    // 任务足够小就直接计算    boolean canCompute = (end - start) &lt;= THRESHOLD;    if(canCompute){        for(int i = start;i&lt;=end;i++){            sum+=i;        }    }else{            int middle = (start + end)/2;        CountTask leftTask = new CountTask(start, middle);        CountTask rightTask = new CountTask(middle+1,end);        // 执行子任务        leftTask.fork();        rightTask.fork();        // 等待子任务完成，并将结果合并         int leftResult = leftTask.join();        int rightResult = rightTask.join();        // 合并子任务         sum = leftResult + rightResult;    }    return sum;}}   </code></pre><blockquote><p>文章内容来源 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank" rel="external">聊聊并发（七）——Java中的阻塞队列</a> ;<a href="http://www.infoq.com/cn/articles/fork-join-introduction" target="_blank" rel="external">Fork/Join框架介绍</a>《JAVA核心技术 卷1》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线程是什么&quot;&gt;&lt;a href=&quot;#线程是什么&quot; class=&quot;headerlink&quot; title=&quot;线程是什么&quot;&gt;&lt;/a&gt;线程是什么&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读篇--SDWebImage</title>
    <link href="http://yoursite.com/2016/10/26/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AF%87--SDWebImage/"/>
    <id>http://yoursite.com/2016/10/26/源码阅读篇--SDWebImage/</id>
    <published>2016-10-26T09:49:27.000Z</published>
    <updated>2018-06-23T04:06:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage提供的简洁的获取远程URL图片的API；平时开发中使用最多场景就是列表中的cell中要显示远程图片的需求，在具体的实现中要避免加载图片造成的界面卡顿，列表卡顿等现象的出现；所以需要编码实现如下功能：  </p><ul><li>使用占位图片显示UI界面，异步线程加载图片成功后刷新控件</li><li>缓存机制，下载过的图片做内存缓存和磁盘缓存 </li><li>app内存吃紧的状态下移除缓存的内容 </li></ul><a id="more"></a>    <p><strong>对于上述的需求SDWebImage已经完全优雅的实现，并且提供了更多简洁的API供开发者使用</strong>   </p><h4 id="github上一个关于SDWebImage的时序图"><a href="#github上一个关于SDWebImage的时序图" class="headerlink" title="github上一个关于SDWebImage的时序图"></a>github上一个关于SDWebImage的时序图</h4><div align="center"><br><img src="https://raw.githubusercontent.com/rs/SDWebImage/master/Docs/SDWebImageSequenceDiagram.png" width="800" height="300" alt="SDWebImage浅析"><br></div>      <p>上述的时序图大致介绍了SDWebImage的工作流程，而SDWebImage框架的构成是由多个组件构成，下面就一一介绍SDWebImage提供的便利组件；</p><h4 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h4><p>SDImageCache这个类主要的任务就是对图像进行存储；内存缓存，本地磁盘缓存，使用处理后的URL作为key，便于查找，删除，存储操作；SDImageCache提供了如下API</p><pre><code>- (void)storeImage:(UIImage *)image forKey:(NSString *)key;- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk;- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;   </code></pre><h5 id="SDImageCacheType"><a href="#SDImageCacheType" class="headerlink" title="SDImageCacheType"></a>SDImageCacheType</h5><p>在使用SD时，SDImageCache提供了多种缓存类型来适应不同的场景需求  </p><pre><code>typedef NS_ENUM(NSInteger, SDImageCacheType) {/** * The image wasn&apos;t available the SDWebImage caches, but was downloaded from the web. */SDImageCacheTypeNone,/** * The image was obtained from the disk cache. */SDImageCacheTypeDisk,/** * The image was obtained from the memory cache. */SDImageCacheTypeMemory};   </code></pre><h5 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h5><ul><li>内存存储SD选用的存储类是NSCache；它具有的优点是线程安全，可控存储大小，内存吃紧时系统会自动回收缓存对象；而SD在创建NSCache时也监听了UIApplicationDidReceiveMemoryWarningNotification、UIApplicationWillTerminateNotification、UIApplicationDidEnterBackgroundNotification等通知，适当的时期移除了内存缓存的图像；  </li><li>SDImageCache 暴露了maxMemoryCost、maxMemoryCountLimit等属性来供使用者设置内存缓存的存储空间   </li></ul><h5 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h5><ul><li>SD对于磁盘存储同样开放自定义存储路径  </li><li>SD创建了一个serial queue 来异步执行耗时的磁盘存储任务；将NSData写到指定目录，同时默认不执行iCloud同步  </li></ul><h4 id="SDWebImageDecoder"><a href="#SDWebImageDecoder" class="headerlink" title="SDWebImageDecoder"></a>SDWebImageDecoder</h4><p><strong>记得一道面试题问道SD为什么要对图片进行解压缩？</strong>  </p><blockquote><p>“解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间”  </p></blockquote><p><strong>在图片解压操作中SD的一些优化处理</strong> </p><p>在下载大量图片时产生了 the bitmap context，为了避免管理内存 SD自创建autoreleasepool来管理；解压的过程实质是创建一个适合的画布将压缩的image对象绘制到画布上然后返回绘制的image对象   </p><h4 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h4><p>SDWebImageManager这个类负责了整个框架API的调用；（1）图片从缓存中获取（2）图片从服务端获取 （3）图片下载之后的缓存 （4）图片的解码 （5）未下载完成图片operation的取消 这些操作统一由 SDWebImageManager来调用各个组件进行完成；     </p><p>SDWebImageManager提供下面的API来完成图片的获取操作  </p><pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url                                     options:(SDWebImageOptions)options                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock                                   completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;   </code></pre><p> 具体的执行包括  </p><ul><li>缓存获取图片返回image对象  </li><li>缓存中未获取图片  <ul><li>有正在执行的任务cancel掉当前operation  </li><li>执行下载操作  </li><li>下载成功返回image对象</li><li>缓存图片</li></ul></li></ul><h4 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h4><p>SD基于NSURLSession实现下载图片任务，同时结合NSOperationQueue控制最大的并发task量为6；<br>默认的下载是first in frist out 新加入的operation执行要依赖最后添加到队列中的task；  </p><p>SDWebImageDownloader提供如下API来实现图片的下载操作 </p><pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url                                     options:(SDWebImageDownloaderOptions)options                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock                                   completed:(SDWebImageDownloaderCompletedBlock)completedBlock;   </code></pre><h4 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h4><p>执行下载操作的类，对网络请求的数据进行解析和处理操作   </p><h4 id="当某一个UIImageView执行下载图片但是它有下载任务还未完成该如何操作？"><a href="#当某一个UIImageView执行下载图片但是它有下载任务还未完成该如何操作？" class="headerlink" title="当某一个UIImageView执行下载图片但是它有下载任务还未完成该如何操作？"></a>当某一个UIImageView执行下载图片但是它有下载任务还未完成该如何操作？</h4><p>通常解决这类问题就是设置一个属性字段作为标识符但是在objective-c的分类中不能增加属性来标识当前UIImageView有下载任务；那么该如何解决？<br>SD的解决方案是运用运行时的关联对象的特性给UIImageView增加了一个可变字典属性  </p><pre><code>- (NSMutableDictionary *)operationDictionary {NSMutableDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);if (operations) {    return operations;}operations = [NSMutableDictionary dictionary];objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);return operations;}</code></pre><blockquote><p>以上是对SD的简单解析，框架中的具体代码还需要更详细的理解才能完成在这个框架中获取编程上的提升</p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/rs/SDWebImage/master/SDWebImage_logo.png" width="300" height="100" alt="SDWebImage浅析"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImage提供的简洁的获取远程URL图片的API；平时开发中使用最多场景就是列表中的cell中要显示远程图片的需求，在具体的实现中要避免加载图片造成的界面卡顿，列表卡顿等现象的出现；所以需要编码实现如下功能：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用占位图片显示UI界面，异步线程加载图片成功后刷新控件&lt;/li&gt;
&lt;li&gt;缓存机制，下载过的图片做内存缓存和磁盘缓存 &lt;/li&gt;
&lt;li&gt;app内存吃紧的状态下移除缓存的内容 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS开源代码阅读" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之引用循环</title>
    <link href="http://yoursite.com/2016/10/20/OC%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2016/10/20/OC基础之引用循环/</id>
    <published>2016-10-20T02:20:56.000Z</published>
    <updated>2018-06-23T03:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用面向对象的编程语言进行开发的过程中大都涉及到内存管理相关的问题；JAVA、C#等语言采用GC（垃圾回收）机制来管理内存的使用；而最早从事iOS开发的工程师则经历过MRC（手动管理）内存的阶段，后期apple推出了ARC（自动引用计数）的方式来简化内存的管理；那么ARC究竟是什么呢？ARC是如何进行内存管理的呢？<br><a id="more"></a></p><h4 id="自动引用计数（ARC）"><a href="#自动引用计数（ARC）" class="headerlink" title="自动引用计数（ARC）"></a>自动引用计数（ARC）</h4><ul><li>创建一个对象就是在内存中开辟了一块空间来存储对象的属性和行为，对象都有自己的生命周期，系统如何判断对象的生命周期完毕后就对它进行回收呢？  </li><li>iOS系统采用的是引用计数，在开辟的内存区域中存在一个NSInteger类型的变量，对象一旦创建它的值就为1，（通常情况下）有强引用指向它的值就会+1，强引用置为nil，它的值就会-1（retain消息会使得引用计数+1，release消息会使得引用计数-1）；在一次事件循环结束后如果对象的引用计数为0则系统就会回收该对象；那么一次的事件循环还发生了什么呢？  </li><li>首先要介绍自动释放池(autoReleasePool)：它的实质是一个NSMutableArray，一次的事件循环都会创建一个自动释放池，事件循环中产生的对象会被依次加入到autoReleasePool中，事件循环结束后自动释放池会一次向存储的对象发送release消息，使得对象的引用计数-1，当此操作完毕后，引用计数为0的对象就会被系统回收了； </li><li>总的来说自动引用计数（ARC）就是iOS系统用来进行内存管理手段，通过监控对象的引用计数值来决定对象是否应该回收；   </li></ul><h4 id="判断一个对象是否被回收的依据"><a href="#判断一个对象是否被回收的依据" class="headerlink" title="判断一个对象是否被回收的依据"></a>判断一个对象是否被回收的依据</h4><p>对象的引用计数为0时，Objective-C中会调用<code>-(void)dealloc</code>而Swift会调用<code>deinit {}</code>;当这两个方法被正常调用时说明对象的内存管理是正确的；但是也会出现对象不被正常释放的情况，例如：两个对象互相强引用造成循环引用，使用block或是闭包造成与self的循环引用等，那么该如何解决这种强引用循环呢？  </p><h4 id="循环强引用"><a href="#循环强引用" class="headerlink" title="循环强引用"></a>循环强引用</h4><h5 id="类的实例之间的循环强引用"><a href="#类的实例之间的循环强引用" class="headerlink" title="类的实例之间的循环强引用"></a>类的实例之间的循环强引用</h5><pre><code>@interface Person()@property(strong)Car* car;@end@interface Car()@property(strong)Person* owner;@end   </code></pre><p>上述代码中创建Person和Car的实例后，为属性赋值，就会造成两者互为强引用，这样就使得引用计数不能为0，ARC就无法对两者进行内存的释放； 那么该如何打破这种互相强引用呢？Objective-C和Swift都提供了weak关键字的机制来解决这个问题；使用weak修饰属性在赋值的时候不会使引用计数+1，没有了强引用那么对象就能正常释放！除了weak在Swift中还提供了unowned（无主引用）解决强循环引用；</p><h5 id="Swift中weak和unowned"><a href="#Swift中weak和unowned" class="headerlink" title="Swift中weak和unowned"></a>Swift中weak和unowned</h5><p>当两个实例出现互相强引用：（1）实例的值为nil对逻辑上不造成影响，那么选择weak（2）实例的值的一方必须存在，那么只能使用unowned；例如人和信用卡一样，信用卡的拥有者必须要实际存在；   </p><h4 id="block和闭包中出现强循环引用"><a href="#block和闭包中出现强循环引用" class="headerlink" title="block和闭包中出现强循环引用"></a>block和闭包中出现强循环引用</h4><pre><code>#import &quot;HZBlock.h&quot;typedef void (^TestBlock)(NSString* message);@interface HZBlock()@property(nonatomic,copy)TestBlock testBlock;@property(nonatomic,copy)NSString* name;@end@implementation HZBlock-(void)testBlcok{    self.testBlock = ^(NSString* message){       // 循环引用        NSString* nameNew = self.name;        NSLog(@&quot;%@&quot;,nameNew);    };}   </code></pre><p>上述代码中在block中使用self，编译器会报警告，告知此处会出现循环引用(Capturing ‘self’ strongly in this block is likely to lead to a retain cycle)；  </p><p>在Objective-C中可以weak化self来解决此问题   </p><pre><code>// weak化self__weak __typeof(self) weakSelf = self;// 在block体中为了避免self被释放，可以再次强引用__typeof(&amp;*weakSelf) strongSelf = weakSelf;    </code></pre><p> 在Swift中定义捕获列表解决闭包内的引用循环   </p><pre><code>class AutoRefManager: NSObject { let name: Stringlet text: String?lazy var asHTML: (Void) -&gt; String = {// 捕获列表    [unowned self] in   self.text!}init(name: String, text: String? = nil) {    self.name = name    self.text = text}}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在开发中遇到类似的循环引用时要仔细思考，是否会造成内存泄露的问题，然后再选择合适的解决方案来解决出现的问题；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用面向对象的编程语言进行开发的过程中大都涉及到内存管理相关的问题；JAVA、C#等语言采用GC（垃圾回收）机制来管理内存的使用；而最早从事iOS开发的工程师则经历过MRC（手动管理）内存的阶段，后期apple推出了ARC（自动引用计数）的方式来简化内存的管理；那么ARC究竟是什么呢？ARC是如何进行内存管理的呢？&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网络之HTTP和HTTPS</title>
    <link href="http://yoursite.com/2016/09/08/%E7%BD%91%E7%BB%9C%E4%B9%8BHTTP%E5%92%8CHTTPS/"/>
    <id>http://yoursite.com/2016/09/08/网络之HTTP和HTTPS/</id>
    <published>2016-09-08T02:35:23.000Z</published>
    <updated>2018-07-04T15:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>iOS网络编程中会涉及一些协议（HTTP/HTTPS）和计算机网络相关概念，只有了解它们的相关机制和概念才能在实际的编程中解决一些出现的问题。本文主要会讲解HTTP、HTTPS、Cookie、Session等概念。    </p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP是超文本传输协议,是用于从服务器传输超文本到本地浏览器的传送协议,它是基于TCP实现的，由于TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。移动端可通过HTTP向服务端请求数据(JSON/XML)或者下载上传二进制数据等，那么HTTP是如何工作的？<br><a id="more"></a></p><h5 id="HTTP的工作流程"><a href="#HTTP的工作流程" class="headerlink" title="HTTP的工作流程"></a>HTTP的工作流程</h5><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><ul><li>首先客户端与服务器需要建立连接。只要出发一个HTTP请求，HTTP的工作开始。</li><li>建立连接（建立连接的过程涉及到TCP的三次握手操作）后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和其他的内容。 </li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 </li><li>客户端接收服务器所返回的信息进行解析操作，然后客户机与服务器断开连接。  </li></ul><h5 id="HTTP请求报文和响应报文的格式"><a href="#HTTP请求报文和响应报文的格式" class="headerlink" title="HTTP请求报文和响应报文的格式"></a>HTTP请求报文和响应报文的格式</h5><ul><li>起始行：如 GET / HTTP/1.0 （请求的方法  请求的URL 请求所使用的协议）</li><li>头部信息：User-Agent  Host等成对出现的值</li><li>主体       </li></ul><p>GET 请求报文  </p><pre><code>GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive</code></pre><p>POST 请求报文  </p><pre><code>POST / HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alive  sex=man&amp;name=Professional      </code></pre><p>响应报文</p><pre><code>HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;...  </code></pre><h5 id="GET-与-POST-的区别"><a href="#GET-与-POST-的区别" class="headerlink" title="GET 与 POST 的区别"></a>GET 与 POST 的区别</h5><p>GET提交的数据会受到长度限制，GET和POST提交的数据存放位置一个在URL中一个在HTTP Body中；  </p><h6 id="HTTP-请求的错误码"><a href="#HTTP-请求的错误码" class="headerlink" title="HTTP 请求的错误码"></a>HTTP 请求的错误码</h6><ul><li>2xx : 成功状态码</li><li>3xx : 重定向 </li><li>4xx : 客户端状态错误码</li><li>5xx : 服务端错误状态吗 <ul><li>500 : 服务器内部错误</li><li>502 : 代理服务器连接不到后端的服务器</li><li>504 : 后端服务器给代理服务器的响应超时     </li></ul></li></ul><h5 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h5><ul><li>Accept  就是告诉服务器端，我接受那些MIME类型</li><li>Accept-Encoding  这个看起来是接受那些压缩方式的文件</li><li>Accept-Lanague   告诉服务器能够发送哪些语言</li><li>Connection       告诉服务器支持keep-alive特性</li><li>Cookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端</li><li>Host             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多个虚拟主机,那这里就是用来标识要访问那个虚拟主机。<ul><li>User-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等     </li></ul></li></ul><h4 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h4><ul><li>什么是会话: 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话;</li><li>什么是会话跟踪: 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。<br>-为什么需要会话跟踪: 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。  </li></ul><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><ul><li>什么是cookie:  cookie 实际上是包含用户信息的一小段文本信息   </li><li>为什么会使用cookie: HTTP的无状态性,服务端想记住某一个访问者只能通过某中标识来判断，cookie就作为服务端颁发给客户端的证书，作为继续请求的凭证   </li><li>cookie的局限性: cookie保存在本地，存储信息不能超过3K，易于被伪造造成安全问题；所以敏感信息不能存储   </li></ul><h5 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h5><ul><li>什么是Session: Session是服务端记录用户信息的一种机制；Session相当于在服务器上建立了一个客户档案，通过SessionID来确定用户的信息  </li><li>Session的有效期和过期时间: Session清理掉；一般被服务端放在内存中，但是大量访问会可能造成内存溢出的情况，所以超过设定时间的session会被清理掉！   </li></ul><h4 id="密文处理"><a href="#密文处理" class="headerlink" title="密文处理"></a>密文处理</h4><p> 由于目前的app绝大多数已经切换到HTTPS协议，也就是传输的报文都是经过加密的，这其中包含一些相关概念需要讲述。   </p><ul><li>公钥密码机制: 该机制包含公钥、私钥、加密算法；并且最重要的是只有私钥才能解析出密文的信息；  </li><li>对称与非对称加密算法: 公钥和私钥相同的机密算法叫对称加密算法(例如DES/AES等)，公钥和私钥不相同的算法叫做非对称加密算法   </li><li>签名<br>在传输的信息后面加上一段传输信息的hash后的内容，这样能够保证信息的完整和安全性； </li><li>数字证书<br>CA机构颁发的一个凭证，包含颁发机构、有效期、公钥、加密算法; </li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTPS被称为安全的HTTP原因在与它被SSL/TSL包裹了一层，客户端与服务端进行通讯是两者之间共同商议的加密机制对传输报文进行加密操作；  </p><h5 id="发起一个HTTPS请求，客户端和服务端进行了哪些沟通"><a href="#发起一个HTTPS请求，客户端和服务端进行了哪些沟通" class="headerlink" title="发起一个HTTPS请求，客户端和服务端进行了哪些沟通"></a>发起一个HTTPS请求，客户端和服务端进行了哪些沟通</h5><p><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http协议学习和总结系列-3-5.jpg" alt="HTTPS请求客户端和服务端之间的交互">  </p><ul><li>client发送’我是客户端’的请求给server端，server接到请求返回自己的数字证书（CA机构颁发的）； </li><li>client验证数字证书的真伪(由客户端的TSL完成)，client生成一个随机数(使用证书的公钥加密)发给服务端；  </li><li>server接收到请求后使用私钥解密随机数，sever将随机数hash计算用私钥加密后传给客户端</li><li>client使用公钥解密和本身的随机数hash值做比较，确定是server的身份；client此时用公钥加密一套对称加密算法和密钥给server用于以后的数据传输；  </li><li>server和client就能进行正常的数据传输了   </li></ul><h4 id="TCP协议和UDP协议"><a href="#TCP协议和UDP协议" class="headerlink" title="TCP协议和UDP协议"></a>TCP协议和UDP协议</h4><p><img src="http://upload-images.jianshu.io/upload_images/117735-b7d77ab5724c9560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机网络层级">     </p><h5 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h5><p>TCP协议是面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达)传输层协议。  </p><h5 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h5><p> UDP协议也是传输层协议，它是无连接，不保证可靠的传输层协议   </p><h5 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h5><p>I P是T C P / I P协议族中最为核心的协议。所有的T C P、U D P、I C M P及I G M P数据都以I P数据<br>报格式传输。它的特点不可靠无连接；</p><h5 id="TCP的三次握手操作"><a href="#TCP的三次握手操作" class="headerlink" title="TCP的三次握手操作"></a>TCP的三次握手操作</h5><p>SYN（synchronous）是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息<br><img src="http://upload-images.jianshu.io/upload_images/117735-31ba059b7a617177.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP的三次握手操作">   </p><ul><li>客户端发送syn报文并将序列号X放在Sequence Number字段中 ；</li><li>服务端接收到请求，发送确认报文(Acknowledgement Number)X+1,将序列号Y放在Sequence Number字段中，SYN标志位仍旧为1；</li><li>客户端收到响应再次发送确认报文Y+1,将序列号Z放在Sequence Number字段中；三次握手完成   </li></ul><h5 id="TCP的四次挥手操作"><a href="#TCP的四次挥手操作" class="headerlink" title="TCP的四次挥手操作"></a>TCP的四次挥手操作</h5><p><img src="http://upload-images.jianshu.io/upload_images/117735-3f11e03900b70a75.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP的四次挥手操作">   </p><h5 id="客户端基于Token的身份验证"><a href="#客户端基于Token的身份验证" class="headerlink" title="客户端基于Token的身份验证"></a>客户端基于Token的身份验证</h5><ul><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 </li></ul><p>文章参照 </p><blockquote><p>   <a href="http://www.blogjava.net/zjusuyong/articles/304788.html" target="_blank" rel="external">HTTP协议详解</a><br>   <a href="http://www.cnblogs.com/zmlctt/p/3690998.html" target="_blank" rel="external">TCP三次握手和四次挥手</a><br>   <a href="http://blog.chinaunix.net/uid-26833883-id-3627644.html" target="_blank" rel="external">TCP与UDP详解</a><br>   <a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="external">HTTP</a><br>   <a href="http://ninghao.net/blog/2834" target="_blank" rel="external">基于 Token 的身份验证</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h4&gt;&lt;p&gt;iOS网络编程中会涉及一些协议（HTTP/HTTPS）和计算机网络相关概念，只有了解它们的相关机制和概念才能在实际的编程中解决一些出现的问题。本文主要会讲解HTTP、HTTPS、Cookie、Session等概念。    &lt;/p&gt;
&lt;h4 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h4&gt;&lt;p&gt;HTTP是超文本传输协议,是用于从服务器传输超文本到本地浏览器的传送协议,它是基于TCP实现的，由于TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。移动端可通过HTTP向服务端请求数据(JSON/XML)或者下载上传二进制数据等，那么HTTP是如何工作的？&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>iOS篇-测试</title>
    <link href="http://yoursite.com/2016/03/20/iOS%E7%AF%87-%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2016/03/20/iOS篇-测试/</id>
    <published>2016-03-20T06:40:33.000Z</published>
    <updated>2018-06-23T04:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<p> Xcode中集成XCTest框架进行简单的单元测试；在创建App工程时默认创建UnitTest和UITest；UnitTest可以很方便的自定义Method验证项目中某一个业务逻辑单元，UITest则通过录制操作步骤生成代码，然后再执行可以起到自动化测试界面的效果。  </p><a id="more"></a><h4 id="UnitTest的使用"><a href="#UnitTest的使用" class="headerlink" title="UnitTest的使用"></a>UnitTest的使用</h4><p><strong>如何写一个简单的验证api的单元测试</strong><br>创建一个single view application的项目如下图所示  </p><div align="center"><br><img src="http://ofldf2gv9.bkt.clouddn.com/HZTestProject.png" width="500" height="280" alt="iOS核心动画思维导图"><br></div><br>Unit Tests和UI Tests都是默认选中的，然后再项目中找到XXTests.m（我的项目中是HZTestTests.m）文件;<br><div align="center"><br><img src="http://ofldf2gv9.bkt.clouddn.com/TestList.png" width="200" height="400" alt="iOS核心动画思维导图"><br></div> <h5 id="XXTests-m详解"><a href="#XXTests-m详解" class="headerlink" title="XXTests.m详解"></a>XXTests.m详解</h5><p>首先看一下文件中的几个自动生成Method；    </p><pre><code>#import &lt;XCTest/XCTest.h&gt;@interface HZTestTests : XCTestCase@end@implementation HZTestTests- (void)setUp {    [super setUp];    // Put setup code here. This method is called before the invocation of each test method in the class.}- (void)tearDown {    // Put teardown code here. This method is called after the invocation of each test method in the class.    [super tearDown];}- (void)testExample {    // This is an example of a functional test case.    // Use XCTAssert and related functions to verify your tests produce the correct results.}@end   </code></pre><h6 id="void-setUp"><a href="#void-setUp" class="headerlink" title="- (void)setUp"></a>- (void)setUp</h6><p>如果有一些初始代码需要在调用其他测试类的方法之前调用可以写在这个方法中；  </p><h6 id="void-tearDown"><a href="#void-tearDown" class="headerlink" title="- (void)tearDown"></a>- (void)tearDown</h6><p>关于测试的方法调用完毕之后会调用   </p><h6 id="void-testExample"><a href="#void-testExample" class="headerlink" title="- (void)testExample"></a>- (void)testExample</h6><p>测试的业务逻辑代码可以写在这个方法中；通常是自己创建已test开头的方法类似-(void)testLogin;来验证逻辑   </p><h5 id="自定义测试方法并执行"><a href="#自定义测试方法并执行" class="headerlink" title="自定义测试方法并执行"></a>自定义测试方法并执行</h5><p><strong>如下图所示在左侧有空心菱形点击就可以直接执行相应的代码；没有菱形的可以command+b 一下</strong>  </p><div align="center"><br><img src="http://ofldf2gv9.bkt.clouddn.com/excuteTest.png" width="600" height="400" alt="iOS核心动画思维导图"><br></div>     <p><strong>测试一个API的耗时时间可以直接调用measureBlock在控制台就可以看到具体的执行时间</strong>   </p><pre><code>#pragma mark- 性能测试的耗时操作- (void)testExcuteTime{    // This is an example of a performance test case.    __block NSInteger sum;    [self measureBlock:^{        // Put the code you want to measure the time of here.        for (NSInteger index=0; index&lt;10000; index++)            sum +=index;    }];}    </code></pre><p><strong>异步回调判断超时时间，创建XCTestExpectation对象，使用waitForExpectationsWithTimeout监测超时错误，使用[expectation fulfill]告知异步请求完成</strong>     </p><pre><code>#pragma mark- 异步请求回调测试 -(void)testAsyncRequest{    XCTestExpectation * expectation = [self expectationWithDescription:@&quot;test async&quot;];    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{        sleep(4);        XCTAssert(YES,&quot;call back success!&quot;);        [expectation fulfill];    });    [self waitForExpectationsWithTimeout:5 handler:^(NSError *error) {        //Do something when time out        NSLog(@&quot;%@&quot;,[error localizedDescription]);    }];}</code></pre><h5 id="断言的使用"><a href="#断言的使用" class="headerlink" title="断言的使用"></a>断言的使用</h5><pre><code>#pragma mark-  系统提供的断言   XCTAssert(expression, format...)  XCTAssertTrue(expression, format...)  XCTAssertFalse(expression, format...)  XCTAssertEqual(expression1, expression2, format...)  XCTAssertNotEqual(expression1, expression2, format...)  XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...)  XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...)  XCTAssertNil(expression, format...)  XCTAssertNotNil(expression, format...)     XCTFail(format...)   </code></pre><h4 id="UITest的使用"><a href="#UITest的使用" class="headerlink" title="UITest的使用"></a>UITest的使用</h4><p><strong>HZTestUITests.m中系统会生成一些方法</strong></p><pre><code>#import &lt;XCTest/XCTest.h&gt;@interface HZTestUITests : XCTestCase@end@implementation HZTestUITests- (void)setUp {    [super setUp];    // Put setup code here. This method is called before the invocation of each test method in the class.    // In UI tests it is usually best to stop immediately when a failure occurs.    self.continueAfterFailure = NO;    // UI tests must launch the application that they test. Doing this in setup will make sure it happens for each test method.    [[[XCUIApplication alloc] init] launch];    // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.}- (void)tearDown {    // Put teardown code here. This method is called after the invocation of each test method in the class.    [super tearDown];}- (void)testExample {    // Use recording to get started writing UI tests.    // Use XCTAssert and related functions to verify your tests produce the correct results.}</code></pre><p><strong>如何使用UITest</strong>  </p><ul><li>定义一个跳转场景viewController中点击一个button跳转到fristViewController </li><li>在HZTestUITests.m定义一个-(void)testUI{}的方法； </li><li>将光标放在 -(void)testUI{}的大括号中；点击下边的红色record；</li><li>根据你的操作 系统会自动生成代码  </li></ul><p>下面是系统自动生成的代码详细  </p><pre><code>  -(void)testUI{ XCUIApplication *app = [[XCUIApplication alloc] init]; XCUIElement *nextvcButton = app.buttons[@&quot;nextVC&quot;]; [nextvcButton tap]; XCUIElement *backButton = [[[app.navigationBars[@&quot;HZFristView&quot;] childrenMatchingType:XCUIElementTypeButton] matchingIdentifier:@&quot;Back&quot;] elementBoundByIndex:0]; [backButton tap]; [nextvcButton tap]; [backButton tap];} </code></pre><p>执行自动UI跳转可以点击左侧的空心菱形进行操作！   </p><blockquote><p>简单的介绍XCTests框架的使用，如何将测试框架应用到实际项目还需要更多的探索！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Xcode中集成XCTest框架进行简单的单元测试；在创建App工程时默认创建UnitTest和UITest；UnitTest可以很方便的自定义Method验证项目中某一个业务逻辑单元，UITest则通过录制操作步骤生成代码，然后再执行可以起到自动化测试界面的效果。  &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS 测试" scheme="http://yoursite.com/tags/iOS-%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之Runloop</title>
    <link href="http://yoursite.com/2016/03/15/OC%E5%9F%BA%E7%A1%80%E4%B9%8BRunloop/"/>
    <id>http://yoursite.com/2016/03/15/OC基础之Runloop/</id>
    <published>2016-03-15T05:54:58.000Z</published>
    <updated>2018-06-23T03:58:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章内容来自:<br> <a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a><br> <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">官方文档-Runloop</a></p></blockquote><h4 id="Runloop概念"><a href="#Runloop概念" class="headerlink" title="Runloop概念"></a>Runloop概念</h4><ul><li>Runloop本身是一个对象（CFRunloopRef或是NSRunloop  ）</li><li>管理事件和消息</li><li><p>提供一种机制：接收到消息或是事件处于运行状态，否则处于休眠避免CPU资源的浪费   </p><a id="more"></a><h4 id="Runloop和线程的关系"><a href="#Runloop和线程的关系" class="headerlink" title="Runloop和线程的关系"></a>Runloop和线程的关系</h4><ul><li>线程和Runloop是一一对应的，系统持有一个全局的CFMutableDictionary来保存线程和Runloop；其中key是线程，value对应CFRunloopRef实例；   </li></ul></li><li><p>线程的最初创建如果不获取Runloop是不会自动创建的  </p></li></ul><h4 id="Runloop组成"><a href="#Runloop组成" class="headerlink" title="Runloop组成"></a>Runloop组成</h4><p><img src="http://upload-images.jianshu.io/upload_images/117735-cfc201030af27008.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runloop组成"><br>一个runloop中存在多个Mode，每个Mode中存在Source/Observer/Timer ；每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出runloop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响   </p><h5 id="CFRunloopSourceRef-（事件产生）"><a href="#CFRunloopSourceRef-（事件产生）" class="headerlink" title="CFRunloopSourceRef （事件产生）"></a>CFRunloopSourceRef （事件产生）</h5><ul><li>source0：包含一个回调的函数指针，它不能主动触发事件，需要调用函数将其标记，然后再唤醒runloop执行；</li><li>source1：包含一个mach_port和函数指针，被用于处理内核和其他线程发送过来的消息，可以直接唤醒runloop；  </li></ul><h4 id="CFRunloopTimerRef"><a href="#CFRunloopTimerRef" class="headerlink" title="CFRunloopTimerRef"></a>CFRunloopTimerRef</h4><p>CFRunloopTimerRef包含一个时间长度和函数指针，runloop会注册时间，当时间一到就会触发回调函数；  </p><h4 id="CFRunloopObserverRef"><a href="#CFRunloopObserverRef" class="headerlink" title="CFRunloopObserverRef"></a>CFRunloopObserverRef</h4><p>CFRunloopObserverRef包含一个函数指针，它可以监控runloop的状态，一旦状态改变就会触发回调函数；   </p><pre><code> typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入LoopkCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 TimerkCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 SourcekCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop};  </code></pre><blockquote><p>Source/Timer/Observer 被统称为 <strong>mode item</strong>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环   </p></blockquote><h4 id="Runloop的Mode"><a href="#Runloop的Mode" class="headerlink" title="Runloop的Mode"></a>Runloop的Mode</h4><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下： </p><pre><code>struct __CFRunLoopMode {CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;CFMutableSetRef _sources0;    // SetCFMutableSetRef _sources1;    // SetCFMutableArrayRef _observers; // ArrayCFMutableArrayRef _timers;    // Array...};struct __CFRunLoop {CFMutableSetRef _commonModes;     // SetCFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;CFRunLoopModeRef _currentMode;    // Current Runloop ModeCFMutableSetRef _modes;           // Set...};   </code></pre><h4 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h4><p><img src="http://upload-images.jianshu.io/upload_images/117735-6c9cb0e8a42e326c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop 的内部逻辑">   </p><p>当以一种Mode启动runloop时，CFRunLoopRunSpecific函数会根据ModeName找到对应的Mode，判断Mode内部是否存在source/observer/timer,如果存在会调用CFRunloopRun函数，CFRunloopRun内部存在一个while循环，runloop会通知observers将要分别启动timer、source0、source1，一旦启动observers中对应的回调函数将会被调用；runloop会通过mach_msg()函数接收系统消息，当这一切执行完毕，当前runloop就会退出！   </p><h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>一个runloop循环可以理解创建一个AutoreleasePool，在启动和离开时分别触发AutoreleasePool的push和pop函数，在此次循环结束后完成内存的清理工作；   </p><h4 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h4><ul><li>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()</li><li>触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</li><li>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。  </li></ul><p>事件的分发有一个hit-testing的过程，这样能够找到最终处理时间的控件，进而执行自定义的逻辑！  </p><h4 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h4><ul><li>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</li><li>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调 </li><li>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。   </li></ul><h4 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h4><ul><li>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</li><li>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面   </li></ul><h4 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h4><ul><li>CFSocket 是最底层的接口，只负责 socket 通信。</li><li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li><li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li><li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。  </li></ul><h4 id="与-Runloop-相关的实例"><a href="#与-Runloop-相关的实例" class="headerlink" title="与 Runloop 相关的实例"></a>与 Runloop 相关的实例</h4><h5 id="NSTimer注册的事件不被执行"><a href="#NSTimer注册的事件不被执行" class="headerlink" title="NSTimer注册的事件不被执行"></a>NSTimer注册的事件不被执行</h5><p>日常开发中，与 runLoop 接触得最近可能就是通过 NSTimer 了。一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 runLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode 。而这个时候， Timer 就不会运行。  </p><hr><p>有如下两种解决方案：<br>第一种: 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 runLoop 运行哪个 mode ，事件都能得到执行。<br>第二种: 另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章内容来自:&lt;br&gt; &lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot;&gt;深入理解RunLoop&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1&quot;&gt;官方文档-Runloop&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Runloop概念&quot;&gt;&lt;a href=&quot;#Runloop概念&quot; class=&quot;headerlink&quot; title=&quot;Runloop概念&quot;&gt;&lt;/a&gt;Runloop概念&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Runloop本身是一个对象（CFRunloopRef或是NSRunloop  ）&lt;/li&gt;
&lt;li&gt;管理事件和消息&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供一种机制：接收到消息或是事件处于运行状态，否则处于休眠避免CPU资源的浪费   &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读篇--AFNetWorking</title>
    <link href="http://yoursite.com/2016/03/08/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AF%87--AFNetWorking/"/>
    <id>http://yoursite.com/2016/03/08/源码阅读篇--AFNetWorking/</id>
    <published>2016-03-08T02:35:23.000Z</published>
    <updated>2018-07-05T00:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>AFNetworking对于iOS开发者来说是一个十分熟悉的网络请求三方框架，本文就是就是对这个优秀三方框架的学习的一些总结；首先看一下最新的AFNetworking结构目录：<br><img src="http://upload-images.jianshu.io/upload_images/117735-065c16fb6d316dad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetworking结构目录"><br><a id="more"></a> </p><h5 id="AFNetworking包含的模块"><a href="#AFNetworking包含的模块" class="headerlink" title="AFNetworking包含的模块"></a>AFNetworking包含的模块</h5><ul><li>网络请求模块</li><li>网络监控模块</li><li>安全策略模块  </li><li>网络请求/响应序列化模块  </li><li>UIKit的扩展模块    </li></ul><h5 id="AFNetworking便捷之处"><a href="#AFNetworking便捷之处" class="headerlink" title="AFNetworking便捷之处"></a>AFNetworking便捷之处</h5><p>AFNetworking在使用过程中仅仅需要开发者考虑，HTTP Method、URL、Params、回调的Block中解析响应数据、错误的回调Block中处理错误展示的信息；对于数据的上传、下载、安全策略配置等方面的支持AFNetworking更让开发者减轻了不少开发量；  </p><h5 id="AFNetworking-的简单使用案例"><a href="#AFNetworking-的简单使用案例" class="headerlink" title="AFNetworking 的简单使用案例"></a>AFNetworking 的简单使用案例</h5><pre><code> -(void)requestPhoneNumberBelong{NSURLSessionConfiguration* sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];AFHTTPSessionManager* sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:nil sessionConfiguration:sessionConfiguration];[sessionManager GET:@&quot;http://tcc.taobao.com/cc/json/mobile_tel_segment.htm&quot; parameters:@{@&quot;tel&quot;:@&quot;18518487767&quot;} success:^(NSURLSessionDataTask * _Nonnull task, id  _Nonnull responseObject) {    NSStringEncoding gbkEncoding = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);    NSString *pageSource = [[NSString alloc] initWithData:responseObject encoding:gbkEncoding];} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {}]; }   </code></pre><h5 id="AFHTTPSessionManager的创建解析"><a href="#AFHTTPSessionManager的创建解析" class="headerlink" title="AFHTTPSessionManager的创建解析"></a>AFHTTPSessionManager的创建解析</h5><p>创建sessionManger也是使用NSURLSessionConfiguration配置SessionConfiguration，使用AFSecurityPolicy来配置安全策略；   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   +(instancetype)httpManager&#123;</div><div class="line">    static HZHTTPManager *manager;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        manager = [[self alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">        /*</div><div class="line">           设置安全策略</div><div class="line">         */</div><div class="line">        AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];</div><div class="line">        manager.securityPolicy = securityPolicy;</div><div class="line">    &#125;);</div><div class="line">    return manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="AFNetworking网络任务的创建是在哪个线程执行的？"><a href="#AFNetworking网络任务的创建是在哪个线程执行的？" class="headerlink" title="AFNetworking网络任务的创建是在哪个线程执行的？"></a>AFNetworking网络任务的创建是在哪个线程执行的？</h5><p>对于这个问题首先看一下网络任务创建的代码片段   </p><pre><code>    __block NSURLSessionDataTask *dataTask = nil;dispatch_sync(url_session_manager_creation_queue(), ^{    NSLog(@&quot;----&gt;%@&quot;,[NSThread currentThread]);    dataTask = [self.session dataTaskWithRequest:request];});     //  url_session_manager_creation_queue 的创建static dispatch_queue_t url_session_manager_creation_queue() {static dispatch_queue_t af_url_session_manager_creation_queue;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{    af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);});return af_url_session_manager_creation_queue;</code></pre><p>}</p><p>使用dispatch_sync在url_session_manager_creation_queue()函数返回的serial queue中执行request的请求，因此AFNetworking在创建网络任务的时候所在的线程取决于你网络任务发起所在的线程（主线程或是你自己创建的线程中）；<br>对于这个段代码片段究竟有什么作用？看资料的解释是为了解决iOS 8.0以下版本中偶发的taskIdentifiers不唯一的bug；   </p><h5 id="AFNetworking网络任务的完成回调是在哪个线程执行的？"><a href="#AFNetworking网络任务的完成回调是在哪个线程执行的？" class="headerlink" title="AFNetworking网络任务的完成回调是在哪个线程执行的？"></a>AFNetworking网络任务的完成回调是在哪个线程执行的？</h5><p>首先一段代码片段   </p><pre><code>  NSError *serializationError = nil;NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];if (serializationError) {    if (failure) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wgnu&quot;        dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{            failure(nil, serializationError);        });#pragma clang diagnostic pop    }    return nil;}</code></pre><p><strong>代码中如果NSMutableURLRequest的对象创建失败，当completionQueue为nil时，会异步在main queue中执行失败回调，也就是在主线程中处理错误回调；</strong>   </p><p>当数据请求完成会回调<code>- (void)URLSession:(__unused NSURLSession *)session   task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error</code> 方法；此方法中存在代码片段    </p><pre><code>dispatch_async(dispatch_get_main_queue(), ^{           [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];       });    </code></pre><p>所以AFNetworking在NSURLSession完成数据请求回调之后会在主线程里发送AFNetworkingTaskDidCompleteNotification通知，即AFNetworking网络任务的完成回调处理是在<strong>主线程</strong>中完成的；   </p><h5 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h5><p>AFSecurityPolicy可以简化客户端配置安全策略的工作量；AFSecurityPolicy提供了三种模式：  </p><ul><li>AFSSLPinningModeNone:这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。   </li><li>AFSSLPinningModeCertificate：这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。   </li><li>AFSSLPinningModePublicKey：这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</li></ul><h5 id="客户端配置HTTPS的方式"><a href="#客户端配置HTTPS的方式" class="headerlink" title="客户端配置HTTPS的方式"></a>客户端配置HTTPS的方式</h5><p>客户端验证HTTPS协议的一种方式是将把服务端证书(需要转换成cer格式)放到APP项目资源里，AFSecurityPolicy会自动寻找根目录下所有cer文件   </p><pre><code> AFSecurityPolicy *securityPolicy = [AFSecurityPolicy               policyWithPinningMode:AFSSLPinningModePublicKey];securityPolicy.allowInvalidCertificates = YES; [AFHTTPRequestOperationManager manager].securityPolicy = securityPolicy;  [manager GET:@&quot;https://example.com/&quot; parameters:nil         success:^(AFHTTPRequestOperation *operation, id responseObject) {} failure:^(AFHTTPRequestOperation *operation, NSError *error) {}];</code></pre><blockquote><p><a href="http://blog.cnbang.net/tech/2456/" target="_blank" rel="external">AFNetworking2.0</a>这个系列对源码进行了更详细的解析可以参照。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AFNetworking对于iOS开发者来说是一个十分熟悉的网络请求三方框架，本文就是就是对这个优秀三方框架的学习的一些总结；首先看一下最新的AFNetworking结构目录：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/117735-065c16fb6d316dad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;AFNetworking结构目录&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>UIKIT-UIButton事件解析</title>
    <link href="http://yoursite.com/2016/03/01/UIKIT-UIButton%E4%BA%8B%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/01/UIKIT-UIButton事件解析/</id>
    <published>2016-03-01T06:50:49.000Z</published>
    <updated>2018-06-23T03:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个UIButton对象从被点击到执行对应的target action method的过程到底经历了哪些？<br><a id="more"></a><br><strong>首先来通过Time Profiler来看一下点击一个简单的button函数的调用堆栈；</strong></p><center><br><img src="http://ww4.sinaimg.cn/mw690/8e8e3b1bjw1f82cad8b5pj20v00ir108.jpg" alt="调用栈"><br></center>    <p>图片中涉及runloop的部分暂时先不做解释；那么从最上层[UIApplication sendEvent:]开始到最终的NSLog为什么会执行一大堆的方法调用呢？为了搞清该过程需要了解视图的树状结构、UIResponder、响应者链的产生、查找事件响应者等；   </p><h4 id="视图的树状结构"><a href="#视图的树状结构" class="headerlink" title="视图的树状结构"></a>视图的树状结构</h4><p>iOS应用程序屏幕显示的内容都是呈现在UIWindow上的，然后指定window的rootViewController，在viewController上添加控制器的各种展示内容的subViews；如下图所示</p><center><br><img src="http://smnh.me/images/hit-test-view-hierarchy.png" alt="图片来自网络"><br></center> <h4 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h4><blockquote><p>The UIResponder class defines an interface for objects that respond to and handle events. It is the superclass of UIApplication, UIView and its subclasses (which include UIWindow). Instances of these classes are sometimes referred to as responder objects or, simply, responders.<br>大体上说UIResponder给众多对象提供了响应和处理事件的接口；下面展示的是UIResponder一个重要属性nextResponder和相应的方法  </p></blockquote><pre><code>#if UIKIT_DEFINE_AS_PROPERTIES@property(nonatomic, readonly, nullable) UIResponder *nextResponder;#else- (nullable UIResponder*)nextResponder;#endif- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;  </code></pre><h4 id="响应者链的产生"><a href="#响应者链的产生" class="headerlink" title="响应者链的产生"></a>响应者链的产生</h4><p>由于视图继承自UIResponder，因此他有一个nextResponder属性，结合视图的层次结构这样一个响应者链就产生了；子视图的nextResponder指向的是父视图；事件在传递的过程中根据nextResponder指针完成树状图的遍历直到有视图处理此次事件，否则就放弃事件的响应；  </p><h4 id="查找响应者"><a href="#查找响应者" class="headerlink" title="查找响应者"></a>查找响应者</h4><p>屏幕中点击了一个按钮，事件由UIApplication从runloop的事件队列中取出通过[UIApplication sendEvent:]传递给UIWindow；此时会触发Hit-Testing View也就是触发UIWindow中的<code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;</code>和<code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</code>方法；那么Hit-Testing View的过程是什么呢？</p><h5 id="Hit-Testing-View的过程"><a href="#Hit-Testing-View的过程" class="headerlink" title="Hit-Testing View的过程"></a>Hit-Testing View的过程</h5><p>Hit-Testing View实际是递归的使用<code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;</code>和<code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</code>方法来找到<em>触摸点</em>所在的最上层视图然后返回；如下图所示： </p><center><br><img src="http://zhoon.github.io/img/artical/ios_event/iosevent_4.png" alt="图片来自网络"><br></center>  <p>Hit-Testing View 的执行流程图   </p><center><br><img src="http://zhoon.github.io/img/artical/ios_event/iosevent_5.png" alt="图片来自网络"><br></center> <hr><p>经过上述的Hit-Testing View的过程找到了事件处理的视图，此时UIWindow会调用[UIWindow _sendTouchesEnded:withEvent]将事件一层层的传递到UIButton对象，最终执行对应的逻辑操作；<br>在函数调用堆栈中还看到了一系列的UIControl执行的函数具体作用是什么可以参考<a href="http://southpeak.github.io/blog/2015/12/13/cocoa-uikit-uicontrol/" target="_blank" rel="external">UIControl介绍,进一步了解UIButton的父类UIContorl为button对象执行actionMethod的又做了哪些事情</a>   </p><blockquote><p>文章内容参考  </p></blockquote><ul><li><a href="http://southpeak.github.io/2015/03/07/cocoa-uikit-uiresponder/" target="_blank" rel="external">UIKIT-UIRespoder</a>   </li><li><a href="http://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="external">深入浅出iOS事件机制</a>  </li><li><a href="http://smnh.me/hit-testing-in-ios/" target="_blank" rel="external">Hit-Testing in iOS</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个UIButton对象从被点击到执行对应的target action method的过程到底经历了哪些？&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之面向切面编程</title>
    <link href="http://yoursite.com/2016/02/24/OC%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/02/24/OC基础之面向切面编程/</id>
    <published>2016-02-24T07:30:00.000Z</published>
    <updated>2018-06-23T04:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。   <a id="more"></a> <ul><li>但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。<br>也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 </li><li>一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</li><li>这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br>AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。<a href="https://www.zhihu.com/question/24863332/answer/48376158" target="_blank" rel="external">面向切面编程-知乎</a>   </li></ul></li></ul><p>实际开发中会有运营统计当前界面打开数统计，button按钮的点击事件统计等等一系列的需求；编程过程很容易自定义收集工具类在实现的代码逻辑中调用，但是整个项目中编码文件众多，每个实现逻辑中都穿插这样的收集逻辑实在无法忍受，在查找资料中发现<a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="external">Glow的工程师的 Method Swizzling 和 AOP 实践</a>通过利用objective-c动态语言的特性再加上AOP的编程思想，在运行时中将要实现的逻辑代码插入到指定的位置中去；</p><h4 id="使用Method-Swizzling来实现在-void-viewWillAppear-BOOL-animated中实现日志收集逻辑"><a href="#使用Method-Swizzling来实现在-void-viewWillAppear-BOOL-animated中实现日志收集逻辑" class="headerlink" title="使用Method Swizzling来实现在-(void)viewWillAppear:(BOOL)animated中实现日志收集逻辑"></a>使用Method Swizzling来实现在<code>-(void)viewWillAppear:(BOOL)animated</code>中实现日志收集逻辑</h4><p>首先我们希望在程序启动的时候将要执行的日志逻辑插入到 <code>-(void)viewWillAppear:(BOOL)animated</code>中，同时还要保证正常调用<code>-(void)viewWillAppear:(BOOL)animated</code>不受到影响；所以可以在UIViewController的类别中实现<code>-(void)viewWillAppear:(BOOL)animated</code>和自定义方法的互换；下面是具体的实现逻辑</p><pre><code>#import &quot;UIViewController+Logging.h&quot;#import &lt;objc/objc-runtime.h&gt;#import &quot;Logging.h&quot;@implementation UIViewController (Logging)// 保证程序一运行就能实现方法的互换+(void)load{    swizzleMethod([self class], @selector(viewWillAppear:), @selector(swizzled_viewDidAppear:));}//  交换两个指定的方法void swizzleMethod(Class class,SEL originalSelector,SEL swizzledSelector){    Method originalMethod  = class_getInstanceMethod(class, originalSelector);    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);    //     BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));    if (didAddMethod) {        class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));    }else{        method_exchangeImplementations(originalMethod, swizzledMethod);    }}// 切入执行逻辑-(void)swizzled_viewDidAppear:(BOOL)animated{    // 下面调用的其实是 -(void)viewWillAppear:(BOOL)animated    [self swizzled_viewDidAppear:animated];    //log逻辑    [Logging logWithEventName:NSStringFromClass([self class])];}@end</code></pre><p><strong>Glow的工程师</strong>在文章中介绍<code>Aspect</code>框架提供的API能更加简单的实现统计埋点的需求；同时segmentfault有篇<a href="https://segmentfault.com/a/1190000003499895" target="_blank" rel="external">Aspect入门实践讲的很详细</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之load和initialize</title>
    <link href="http://yoursite.com/2016/01/09/OC%E5%9F%BA%E7%A1%80%E4%B9%8Bload%E5%92%8Cinitialize/"/>
    <id>http://yoursite.com/2016/01/09/OC基础之load和initialize/</id>
    <published>2016-01-09T10:32:23.000Z</published>
    <updated>2018-06-23T04:01:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Objective-C作为一门面向对象语言，有类和对象的概念。编译后，类相关的数据结构会保留在目标文件中，在运行时得到解析和使用。在应用程序运行起来的时候，类的信息会有加载和初始化过程。<br><a id="more"></a></p></blockquote><h4 id="void-load"><a href="#void-load" class="headerlink" title="+ (void)load"></a><code>+ (void)load</code></h4><blockquote><p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.<br>这个方法的执行发生类或是分类加入到objc运行时,仅此执行一次；</p></blockquote><h4 id="void-initialize"><a href="#void-initialize" class="headerlink" title="+(void)initialize"></a><code>+(void)initialize</code></h4><blockquote><p>Initializes the class before it receives its first message<br>这个方法的执行发生在类第一次接收到消息的时候，给方法会晚于<code>+ (void)load</code>方法执行</p></blockquote><h4 id="验证执行顺序"><a href="#验证执行顺序" class="headerlink" title="验证执行顺序"></a>验证执行顺序</h4><pre><code>#import &quot;Person.h&quot;@implementation Person+(void)load{    NSLog(@&quot;加载Person文件！&quot;);}+(void)initialize{    NSLog(@&quot;使用Person！&quot;);}@end#import &lt;Foundation/Foundation.h&gt;#import &quot;Person.h&quot;int main(int argc, const char * argv[]) {    @autoreleasepool {        Person* person = [[Person alloc] ini        Person* person1 = [[Person alloc] init];        } ===》 [11767:1733037] 加载Person文件！ ===》  [11767:1733037] 使用Person！</code></pre><p><strong>+(void)load先于+(void)initialize执行，并且两者在应用的生命周期内都只执行一次</strong></p><h4 id="避免UIButton被连续点击触发事件"><a href="#避免UIButton被连续点击触发事件" class="headerlink" title="避免UIButton被连续点击触发事件"></a>避免UIButton被连续点击触发事件</h4><pre><code>import &quot;UIButton+HZ.h&quot;#import &lt;objc/objc-runtime.h&gt;@implementation UIButton (HZ)+(void)load{    Method originalMethod = class_getInstanceMethod([UIButton class], @selector(sendAction:to:forEvent:));    Method anotherMethod = class_getInstanceMethod([UIButton class], @selector(delaysendAction:to:forEvent:));    method_exchangeImplementations(originalMethod, anotherMethod);}-(void)delaysendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event{    [self delaysendAction:action to:target forEvent:event];    self.enabled = NO;    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3*NSEC_PER_SEC)), dispatch_get_main_queue(), ^{        self.enabled = YES;    });}@end</code></pre><p><strong>在UIButton的分类中重写<code>+(void)load</code>实现UIButton点击事件的触发方法替换</strong></p><p><a href="http://www.cocoachina.com/ios/20150104/10826.html" target="_blank" rel="external">参考NSObject的load和initialize方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Objective-C作为一门面向对象语言，有类和对象的概念。编译后，类相关的数据结构会保留在目标文件中，在运行时得到解析和使用。在应用程序运行起来的时候，类的信息会有加载和初始化过程。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之NSString</title>
    <link href="http://yoursite.com/2016/01/08/OC%E5%9F%BA%E7%A1%80%E4%B9%8BNSString/"/>
    <id>http://yoursite.com/2016/01/08/OC基础之NSString/</id>
    <published>2016-01-08T09:32:23.000Z</published>
    <updated>2018-06-23T04:11:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><ul><li>为什么NSString类型成员变量的修饰符属性使用copy而不是strong？</li><li>NSArray类型成员变量的修饰符属性你使用copy or strong?</li></ul><p><strong>下面从对象接收copy消息可以解析问题的答案</strong></p><a id="more"></a><h4 id="对象接收到copy消息会如何"><a href="#对象接收到copy消息会如何" class="headerlink" title="对象接收到copy消息会如何"></a>对象接收到copy消息会如何</h4><p>对象接收到copy消息，如果已经对象的类型已经遵守了NSCopying协议那么会触发<code>- (id)copyWithZone:(nullable NSZone *)zone</code>;如果未遵守该协议那么<code>-[User copyWithZone:]: unrecognized selector sent to instance 0x100203ed0</code></p><h4 id="NSCopying协议的内容"><a href="#NSCopying协议的内容" class="headerlink" title="NSCopying协议的内容"></a>NSCopying协议的内容</h4><pre><code>@protocol NSCopying- (id)copyWithZone:(nullable NSZone *)zone;@end</code></pre><blockquote><p>Returns a new instance that’s a copy of the receiver.遵守协议的对象，实现<code>- (id)copyWithZone:(nullable NSZone *)zone</code>就会返回一个新的实例对象；</p></blockquote><h4 id="收到copy消息的对象都会创建一个新的实例对象吗？"><a href="#收到copy消息的对象都会创建一个新的实例对象吗？" class="headerlink" title="收到copy消息的对象都会创建一个新的实例对象吗？"></a>收到copy消息的对象都会创建一个新的实例对象吗？</h4><pre><code>- (void)testMethod {        #pragma mark - NSString        NSString* k_name = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;HZiOS&quot;];        NSLog(@&quot;(1)%@---%p&quot;,k_name,k_name);        NSString* another_name = [k_name copy];        NSLog(@&quot;(2)%@---%p&quot;,another_name,another_name);        #pragma mark - NSMutableString        NSMutableString* kmutable_name = [NSMutableString stringWithFormat:@&quot;%@&quot;,@&quot;HZiOSmutable&quot;];        NSLog(@&quot;(3)%@---%p&quot;,kmutable_name,kmutable_name);        NSString* other_name = [kmutable_name copy];        NSLog(@&quot;(4)%@---%p&quot;,other_name,other_name);        /*         (1)HZiOS---0x534f695a4855         (2)HZiOS---0x534f695a4855         (3)HZiOSmutable---0x100207120         (4)HZiOSmutable---0x100700110         */}</code></pre><h5 id="NSString不可变字符串"><a href="#NSString不可变字符串" class="headerlink" title="NSString不可变字符串"></a>NSString不可变字符串</h5><p>上述代码中NSString类型的变量在收到copy消息的时候并未返回一个全新的实例对象，可以看到两个变量的内存地址是一样的；由此可以猜想在NSString类型的变量收到copy消息时在<code>- (id)copyWithZone:(nullable NSZone *)zone;</code>方法中做了逻辑判断，<code>[k_name isKindOfClass:[NSString class]]</code>此条件成立则直接返回当前实例对象；</p><h5 id="NSMutableString可变字符串"><a href="#NSMutableString可变字符串" class="headerlink" title="NSMutableString可变字符串"></a>NSMutableString可变字符串</h5><p>上述代码中NSMutableString的变量kmutable_name收到copy消息返回了一个不可变NSString的变量other_name；两个变量的内存地址不一致；这就说明重新创建一个全新的实例变量；</p><h5 id="为什么NSString和NSMutableString接收到copy消息操作会不一样呢？"><a href="#为什么NSString和NSMutableString接收到copy消息操作会不一样呢？" class="headerlink" title="为什么NSString和NSMutableString接收到copy消息操作会不一样呢？"></a>为什么NSString和NSMutableString接收到copy消息操作会不一样呢？</h5><ul><li>NSString类型接收到copy消息如果返回一个新实例，那么内存中就存在两块内存空间存储相同值的不可变字符串，这样做的话会浪费本来就很稀缺的内存空间，所以具体实现上apple的工程师应该做一些优化；</li><li>NSMutableString类型接收到消息返回一个新实例，原因在于存储可变字符串变量的内存空间在开发的某个阶段接收到 <code>[kmutable_name appendString:@&quot;123&quot;];</code>那么内存空间的值就被改变了，相应的定义的不可变类型的变量值发生了改变，这样可能会造成程序的异常；</li></ul><hr><h4 id="NSArray类型成员变量的修饰符属性你使用copy-or-strong？"><a href="#NSArray类型成员变量的修饰符属性你使用copy-or-strong？" class="headerlink" title="NSArray类型成员变量的修饰符属性你使用copy or strong？"></a>NSArray类型成员变量的修饰符属性你使用copy or strong？</h4><p>答案是使用copy；为什么使用copy这个就是为了完全避免被子类类型的变量赋值后导致的程序异常</p><blockquote><p>总结</p></blockquote><h4 id="当属性类型为NSString，并且赋值的类型也是NSString（对于不可变类型的集合同样适用）那么使用copy和strong没有区别"><a href="#当属性类型为NSString，并且赋值的类型也是NSString（对于不可变类型的集合同样适用）那么使用copy和strong没有区别" class="headerlink" title="当属性类型为NSString，并且赋值的类型也是NSString（对于不可变类型的集合同样适用）那么使用copy和strong没有区别"></a>当属性类型为NSString，并且赋值的类型也是NSString（对于不可变类型的集合同样适用）那么使用copy和strong没有区别</h4><pre><code>-(void)testCopyStr{        #pragma mark - copy属性        NSString* k_name = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;HZiOS&quot;];        NSLog(@&quot;%@---%p&quot;,k_name,k_name);        self.name = k_name;        NSLog(@&quot;%@---%p&quot;,self.name,self.name);        k_name = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;anotherStr&quot;];        NSLog(@&quot;%@---%p&quot;,k_name,k_name);        NSLog(@&quot;%@---%p&quot;,self.name,self.name);        #pragma mark - test copy and mutableCopy        self.name = [k_name copy];        NSLog(@&quot;%@---%p&quot;,self.name,self.name);        self.name = [k_name mutableCopy];        NSLog(@&quot;%@---%p&quot;,self.name,self.name);        NSLog(@&quot;----------------------------------&quot;);        /*          HZiOS---0x534f695a4855          HZiOS---0x534f695a4855          anotherStr---0x10b192a02d085a5          HZiOS---0x534f695a4855          anotherStr---0x10b192a02d085a5          anotherStr---0x10b192a02d085a5         */}</code></pre><hr><pre><code>-(void)testStrongStr{    #pragma mark - strong属性    NSString* k_name = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;HZiOS1&quot;];    NSLog(@&quot;%@---%p&quot;,k_name,k_name);    self.anotherName = k_name;    NSLog(@&quot;%@---%p&quot;,self.anotherName,self.anotherName);    k_name = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;anotherStr1&quot;];    NSLog(@&quot;%@---%p&quot;,k_name,k_name);    NSLog(@&quot;%@---%p&quot;,self.anotherName,self.anotherName);   #pragma mark - test copy and mutableCopy    self.anotherName = [k_name copy];    NSLog(@&quot;%@---%p&quot;,self.anotherName,self.anotherName);    self.anotherName = [k_name mutableCopy];    NSLog(@&quot;%@---%p&quot;,self.anotherName,self.anotherName);    /*      HZiOS1---0x1002036a0      HZiOS1---0x1002036a0      HZiOS1addStr---0x1002036a0      HZiOS1addStr---0x1002036a0      HZiOS1addStr---0x1001029b0      HZiOS1addStr---0x100700150     */}</code></pre><h4 id="唯一需要注意的是属性类型为NSString时，接收到-xxx-mutableCopy-的返回值，使用copy和strong会略有不同；这个可以看代码中的内存地址；"><a href="#唯一需要注意的是属性类型为NSString时，接收到-xxx-mutableCopy-的返回值，使用copy和strong会略有不同；这个可以看代码中的内存地址；" class="headerlink" title="唯一需要注意的是属性类型为NSString时，接收到[xxx mutableCopy]的返回值，使用copy和strong会略有不同；这个可以看代码中的内存地址；"></a>唯一需要注意的是属性类型为NSString时，接收到[xxx mutableCopy]的返回值，使用copy和strong会略有不同；这个可以看代码中的内存地址；</h4><p>copy属性特征：接收到[xxx mutableCopy]的返回值，实际又接收了copy消息，这样在内存中有存在两块内存空间存储相同的不可变字符，so优化合并，所以打印出来的内存地址是一样的；</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;两个问题&quot;&gt;&lt;a href=&quot;#两个问题&quot; class=&quot;headerlink&quot; title=&quot;两个问题&quot;&gt;&lt;/a&gt;两个问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;为什么NSString类型成员变量的修饰符属性使用copy而不是strong？&lt;/li&gt;
&lt;li&gt;NSArray类型成员变量的修饰符属性你使用copy or strong?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;下面从对象接收copy消息可以解析问题的答案&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之GCD</title>
    <link href="http://yoursite.com/2015/12/03/OC%E5%9F%BA%E7%A1%80%E4%B9%8BGCD/"/>
    <id>http://yoursite.com/2015/12/03/OC基础之GCD/</id>
    <published>2015-12-03T06:57:54.000Z</published>
    <updated>2018-07-04T15:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章资料来源《Objective-C高级编程》之GCD</p></blockquote><p>GCD是一种异步执行任务的技术，对于编程层面上异步执行就意味着创建一个线程（操作系统能夠進行運算调度的最小單位，是进程中一个单一顺序的控制流–from wiki）去执行Task；GCD提供了两种队列和相关API使得开发者只需要关心该选择哪种队列去执行任务即可；<br><a id="more"></a></p><h4 id="GCD的队列"><a href="#GCD的队列" class="headerlink" title="GCD的队列"></a>GCD的队列</h4><ul><li>serial queue 能够保证各个task在同一个线程中被执行并且执行顺序会严格的按照入队的顺序进行；</li><li>concurrent queue 各个task的执行互不影响，执行顺序上不确定，执行线程也不一定会相同；</li></ul><h5 id="dispatch-queue-create-创建队列"><a href="#dispatch-queue-create-创建队列" class="headerlink" title="dispatch_queue_create 创建队列"></a>dispatch_queue_create 创建队列</h5><p>serial queue</p><pre><code>  /* 1&gt;serial Queue：系统默认创建一个线程，队列中的任务是顺序执行 2&gt;创建多个serial queue 的执行是并发的没有顺序 3&gt;解决数据竞争问题：可以将任务放在serial queue中 保证任务按照顺序执行就能解决数据竞争*/dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.hua.example.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</code></pre><p>concurrent queue  </p><pre><code> /*  1 concurrent queue 添加到队列中的任务会并发执行，没有顺序性 */dispatch_queue_t myConcurrentQueue=dispatch_queue_create(&quot;com.hua.example.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</code></pre><p>非ARC下生成的队列还必须使用<code>dispatch_release(Queue);</code>来释放指定的队列</p><h4 id="Main-Dispatch-Queue-and-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-and-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue and Global Dispatch Queue"></a>Main Dispatch Queue and Global Dispatch Queue</h4><p>Main Dispatch Queue</p><pre><code>  /*  dispatch_get_main_queue （1）main queue 是一中serial queue，task是放在主线程的Runloop中执行的； （2）一些UI的更新操作需要放在主线程中，使用main queue是比较简单的 */dispatch_queue_t main_queue = dispatch_get_main_queue();</code></pre><p>global Dispatch Queue</p><pre><code> /*   dispatch_get_global_queue (1)global queue 是一种concurrent queue，可以通过设置queue的priority指定执行的优先级； */dispatch_queue_t global_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  </code></pre><h4 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h4><pre><code> /* dispatch_set_target_queue的第一个参数是指定要变更优先级的队列；指定与要使用优先级相同优先级的队列为第二个参数 */dispatch_queue_t serialqueue1 = dispatch_queue_create(&quot;serialqueue1&quot;, NULL);dispatch_queue_t serialqueue2 = dispatch_queue_create(&quot;serialqueue2&quot;, NULL);dispatch_set_target_queue(serialqueue2, serialqueue1);/*  </code></pre><h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><pre><code>/*  延迟若干时间处理某一个Task，只是追加task到某一个队列，并不一定立即执行task*/dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);dispatch_after(time, dispatch_get_main_queue(), ^{    NSLog(@&quot;wait at least three seconds!!&quot;);});</code></pre><h4 id="dispatch-Group"><a href="#dispatch-Group" class="headerlink" title="dispatch Group"></a>dispatch Group</h4><p>dispatch group 的出现可以解决多个并发task执行后能收到通知再执行其他任务操作的需求；</p><pre><code>  /*  1; 如果使用 serial queue 所有的task执行完毕后在执行done task  2：如果使用 concurrent queue 所有的task执行后没办法 执行行done task 就需要 dispatch_group */dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();//dispatch_group_async(group, queue, ^{    NSLog(@&quot;blok1&quot;);});dispatch_group_async(group, queue, ^{    NSLog(@&quot;blok2&quot;);});dispatch_group_async(group, queue, ^{    NSLog(@&quot;blok3&quot;);});dispatch_group_async(group, queue, ^{    [NSThread sleepForTimeInterval:2.0];    NSLog(@&quot;blok4&quot;);});// 监听group 中的task 是否已经全部执行完成dispatch_group_notify(group, dispatch_get_main_queue(), ^{    NSLog(@&quot;done!!&quot;);});//   dispatch_group_wait会hold住当前线程直到所有task执行完毕//    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);NSLog(@&quot;all finish!!!!&quot;);</code></pre><p>多个网络请求执行操作完成在执行下一步操作的需求如何实现？  </p><pre><code>// 多个网络请求完成后再做新的任务   dispatch_group_enter(group);   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{       //网络请求操作1       dispatch_group_leave(group);   });   dispatch_group_enter(group);   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{       //网络请求操作2       dispatch_group_leave(group);   });</code></pre><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><p>多线程操作产生的一个问题就是数据资源的竞争，读写操作如何能保证线程安全性；dispatch_barrier_async提供了解决方案  </p><pre><code> /*   使用concurrent dispatch queue 和 dispatch barrier async 函数可实现高效率的数据库访问和文件读取 */dispatch_queue_t queue = dispatch_queue_create(&quot;test.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^{    NSLog(@&quot;task1forReading!&quot;);});dispatch_async(queue, ^{    NSLog(@&quot;task2forReading!&quot;);});dispatch_async(queue, ^{    NSLog(@&quot;task3forReading!&quot;);});dispatch_barrier_async(queue, ^{    // 此taskforWriting 会等到加入concurrentQueue中的task执行完毕后，执行taskforWriting，等到该taskforWriting执行完毕后在执行 concurrentQueue中的task    NSLog(@&quot;taskforWriting!&quot;);});dispatch_async(queue, ^{    NSLog(@&quot;task4forReading!&quot;);});dispatch_async(queue, ^{    NSLog(@&quot;task5forReading!&quot;);});</code></pre><h4 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h4><pre><code>/*dispatch_sync 函数意味着等待；它要等待task执行完毕后再做返回*///使用dispatch_sync 容易造成死锁//在主线程中执行以下源代码会造成死锁/*  main_queue 是一个serialQueue ，使用dispatch_sync将task加入到mainqueue中task会等待mainqueue中的任务执行完成，而mainqueue又要等待task完成，由此造成了死锁； */dispatch_queue_t main_queue = dispatch_get_main_queue();dispatch_sync(main_queue, ^{    NSLog(@&quot;hello dispatch_sync!&quot;);});//&gt;2在主线程中执行以下源代码也会造成死锁dispatch_async(main_queue, ^{   dispatch_sync(main_queue, ^{       NSLog(@&quot;hello!!&quot;);   });});</code></pre><h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><pre><code>NSMutableArray* tempArr  = [@[@&quot;key1&quot;,@&quot;key2&quot;,@&quot;key3&quot;,@&quot;key4&quot;,@&quot;key5&quot;] mutableCopy]; // 1 按照指定的次数将指定的Block追加到指定的Dispatch_Queue中，并等待全部处理执行结束  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  dispatch_apply([tempArr count], queue, ^(size_t index) {      // 要做数据更新操作      NSLog(@&quot;%d&quot;,index);  });  NSLog(@&quot;task done&quot;);  /*   1 对数组进行循环遍历的方法     1》 for循环     2》 block     3》 dispatch_apply    2 dispatch_apply 要等待结束，最好和 dispatch_async函数混合使用   */</code></pre><h4 id="挂起队列和执行队列"><a href="#挂起队列和执行队列" class="headerlink" title="挂起队列和执行队列"></a>挂起队列和执行队列</h4><pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//挂起队列dispatch_suspend(queue);//恢复指定队列dispatch_resume(queue);  </code></pre><h4 id="dispatch-Semaphore"><a href="#dispatch-Semaphore" class="headerlink" title="dispatch_Semaphore"></a>dispatch_Semaphore</h4><pre><code> // 1  向数组中增加对象由于内存错误导致异常的概率会很高dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);NSMutableArray* mutable_arr =[NSMutableArray array];for(int i = 0;i&lt;100000;++i){   dispatch_async(queue, ^{       [mutable_arr addObject:[NSNumber numberWithInt:i]];   });}// 2 使用dispatch_semaphore进行更细粒度的线程管理dispatch_queue_t global_queue = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);/*  生成Dispatch Semahpore  dispatch_Semahpore 的计数初始值设定为“1”  这样能保证访问NSMutableArray类对象的线程，同时只有1个 */dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);NSMutableArray* array =[NSMutableArray array];for(int i = 0;i&lt;10000;i++){    dispatch_async(global_queue, ^{        /*         等待Dispatch Semaphore         直到Dispatch Semphore的计数值达到大于等于1；         */        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);        /*         由于dispatch Semaphore 的计数值达到大于等于1         所以将Dispatch semaphore 的计数值减去1         dispatch_semaphore_wait 函数执行返回         执行到此 dispatch Semaphore的计数值恒为“0”         */        [array addObject:[NSNumber numberWithInt:i]];        /*         排他控制处理结束，所以通过dispatch_semaphore_signal函数 将         Dispatch Semaphore的计数值加1         如果有通过dispatch_semaphore_wait 函数 等待dispatch Semaphore 的计数值增加的线程 就由最先等待的线程执行         */        dispatch_semaphore_signal(semaphore);    });}</code></pre><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p>保证应用程序中只执行一次指定处理的API  </p><pre><code>+(instancetype)shareInstance   {       static ViewController* _vc;       static dispatch_once_t onceToken;       dispatch_once(&amp;onceToken, ^{           _vc =[[self alloc] init];       });       return _vc;   }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章资料来源《Objective-C高级编程》之GCD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GCD是一种异步执行任务的技术，对于编程层面上异步执行就意味着创建一个线程（操作系统能夠進行運算调度的最小單位，是进程中一个单一顺序的控制流–from wiki）去执行Task；GCD提供了两种队列和相关API使得开发者只需要关心该选择哪种队列去执行任务即可；&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之NSOperation</title>
    <link href="http://yoursite.com/2015/12/01/OC%E5%9F%BA%E7%A1%80%E4%B9%8BNSOperation/"/>
    <id>http://yoursite.com/2015/12/01/OC基础之NSOperation/</id>
    <published>2015-12-01T06:01:55.000Z</published>
    <updated>2018-06-23T04:02:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于异步执行技术GCD的API已经非常简单高效，但对于某些task之间存在依赖或是监测task的执行状态等需求GCD就显得不那么高效；因此cocoa框架中就提供了一个使用面向对象思想来解决异步操作的NSOperation,同时结合NSOperationQueue会使得异步操作更加简单高效；  </p><a id="more"></a><h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>NSOperation是一个抽象基类，只能实例化子类才能使用；开发框架中已经存在了两个实例NSBlockOperation和NSInvocationOperation  </p><h5 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h5><p>NSBlockOperation实例化操作可以在block中执行task，并且当task只有一个的时候task在主线程中执行，当task增加时会另外创建线程执行task；</p><p>NSBlockOperation 在调用start方法时所有添加的task会hold住主线程，也就是所有的task执行完毕后才继续执行主线程的其他操作</p><p>NSBlockOperation 中添加多个task时，各个task的执行顺序不一定，但是第添加的task一定会在主线程中被执行</p><pre><code>NSBlockOperation* blockOperation = [NSBlockOperation blockOperationWithBlock:^{    NSLog(@&quot;blockOp1:%@&quot;,[NSThread currentThread]);}];[blockOperation addExecutionBlock:^{    NSLog(@&quot;blockOp2:%@&quot;,[NSThread currentThread]);}];[blockOperation addExecutionBlock:^{    NSLog(@&quot;blockOp3:%@&quot;,[NSThread currentThread]);}];[blockOperation addExecutionBlock:^{    [NSThread sleepForTimeInterval:3.0f];    NSLog(@&quot;blockOp4:%@&quot;,[NSThread currentThread]);}];blockOperation.completionBlock = ^{    NSLog(@&quot;blockOperation over!&quot;);};[blockOperation start];NSLog(@&quot;run over!!!:%@&quot;,[NSThread currentThread]);/*  HZFoundation[46406:1977543] blockOp3:&lt;NSThread: 0x100700110&gt;{number = 2, name = (null)}  HZFoundation[46406:1977541] blockOp2:&lt;NSThread: 0x1001037c0&gt;{number = 3, name = (null)}  HZFoundation[46406:1977517] blockOp1:&lt;NSThread: 0x100502e50&gt;{number = 1, name = main}  HZFoundation[46406:1977542] blockOp4:&lt;NSThread: 0x100700150&gt;{number = 4, name = (null)}  HZFoundation[46406:1977517] run over!!!:&lt;NSThread: 0x100502e50&gt;{number = 1, name = main} */</code></pre><p> <strong>根据上述log的输出可用GCD模拟一下NSBlockOperation内部实现</strong>  </p><pre><code>  -(void)implementationBlockOperation{// 添加taskOperationBlock block1=^{    NSLog(@&quot;block1%@&quot;,[NSThread currentThread]);};OperationBlock block2=^{    NSLog(@&quot;block2%@&quot;,[NSThread currentThread]);};OperationBlock block3=^{    NSLog(@&quot;block3%@&quot;,[NSThread currentThread]);};OperationBlock block4=^{    NSLog(@&quot;block4%@&quot;,[NSThread currentThread]);};OperationBlock block5=^{    [NSThread sleepForTimeInterval:3.0f];    NSLog(@&quot;block5%@&quot;,[NSThread currentThread]);};// 所有执行task的集合NSArray* operationBlcoks = [NSArray arrayWithObjects:block1,block2,block3,block4,block5,nil];//根据上面打印的block执行线程名称可以看到，线程名称各不相同，由此推测block的执行在一个并发队列中dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.*.implementationBlockOperation&quot;, DISPATCH_QUEUE_CONCURRENT);//打印的内容可以看到NSOperation是block住主线程的，也就是所有的任务执行完毕后才继续执行task，能够执行此操作的dispatch_group最合适dispatch_group_t dispatchGroup = dispatch_group_create();for (NSInteger index=0; index&lt;operationBlcoks.count; index++) {    // 此处的状态判断是由于打印线程名称看到每次第一个任务的执行线程总是在主线程中完成的    if (index==0) {        // 此处处理和原设计相违背，虽然是在主线程中执行但是执行的顺序每次都是最先添加的被执行        OperationBlock block = operationBlcoks[0];        block();    }else{        dispatch_group_async(dispatchGroup, concurrentQueue, ^{            OperationBlock block = operationBlcoks[index];            block();        });    }}dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER);NSLog(@&quot;implementationBlockOperation over!%@&quot;,[NSThread currentThread]);}    </code></pre><p>上述实现代码唯一的不足时第一task执行顺序会影响其他task，因为它总是第一个被执行，目前还没有考虑出合适的实现方法；   </p><h5 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h5><p>NSInvocationOperation的使用和UIControl的使用模式很相似  </p><pre><code>-(void)operationInvocation{   NSInvocationOperation* operation1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationAction) object:nil];[operation1 start];}-(void)operationAction{    NSLog(@&quot;%@---&gt;&quot;,[NSThread currentThread]);}</code></pre><h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><pre><code>  // 创建operationNSBlockOperation* blockOperation = [NSBlockOperation blockOperationWithBlock:^{    NSLog(@&quot;blockOp1:%@&quot;,[NSThread currentThread]);}];NSBlockOperation* blockOperation1 = [NSBlockOperation blockOperationWithBlock:^{    NSLog(@&quot;blockOp2:%@&quot;,[NSThread currentThread]);}];// 创建operationQueueNSOperationQueue* operationQueue = [[NSOperationQueue alloc] init];[operationQueue addOperation:blockOperation];[operationQueue addOperation:blockOperation1];  [operationQueue setMaxConcurrentOperationCount:4]; // 设置task最大执行并发数[blockOperation addDependency:blockOperation1];// operation之间添加依赖关系[operationQueue waitUntilAllOperationsAreFinished];// 等待所有的operation执行完毕后[operationQueue cancelAllOperations];//取消所有operation操作  </code></pre><blockquote><p>资料来源 <a href="http://nshipster.cn/nsoperation/" target="_blank" rel="external">NShipster之NSOperation</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于异步执行技术GCD的API已经非常简单高效，但对于某些task之间存在依赖或是监测task的执行状态等需求GCD就显得不那么高效；因此cocoa框架中就提供了一个使用面向对象思想来解决异步操作的NSOperation,同时结合NSOperationQueue会使得异步操作更加简单高效；  &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS篇-动画</title>
    <link href="http://yoursite.com/2015/10/25/iOS%E7%AF%87-%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2015/10/25/iOS篇-动画/</id>
    <published>2015-10-25T07:31:18.000Z</published>
    <updated>2018-06-23T04:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读<a href="http://wiki.jikexueyuan.com/project/ios-core-animation" target="_blank" rel="external">iOS核心动画译文版本</a>对其中的内容做了概要整理；文中罗列出视图、图层、Core Animation 、Core Graphics的介绍。<br><a id="more"></a></p></blockquote><h4 id="视图和图层"><a href="#视图和图层" class="headerlink" title="视图和图层"></a>视图和图层</h4><center><br><img src="http://ofldf2gv9.bkt.clouddn.com/视图和图层.png" alt="视图和图层"><br></center> <h5 id="增加一个子图层"><a href="#增加一个子图层" class="headerlink" title="增加一个子图层"></a>增加一个子图层</h5>   <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">func</span> <span class="title">addBlueLayer</span><span class="params">(button:UIButton)</span></span> &#123;</div><div class="line">      button.backgroundColor = <span class="type">UIColor</span>.red</div><div class="line">      <span class="keyword">let</span> blueLayer = <span class="type">CALayer</span>()</div><div class="line">      blueLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">50</span>, height: <span class="number">30</span>)</div><div class="line">      blueLayer.backgroundColor = <span class="type">UIColor</span>.blue.cgColor</div><div class="line">      <span class="keyword">self</span>.view.layer.addSublayer(blueLayer)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h4><center><br><img src="http://ofldf2gv9.bkt.clouddn.com/CALayer.png" alt="CALayer"><br></center> <h5 id="直接给视图的图层增加图片"><a href="#直接给视图的图层增加图片" class="headerlink" title="直接给视图的图层增加图片"></a>直接给视图的图层增加图片</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">func</span> <span class="title">addImageOnLayer</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"desktop"</span>)</div><div class="line">    <span class="keyword">self</span>.view.layer.contents = image?.cgImage</div><div class="line">    <span class="comment">/*</span></div><div class="line">      UIImageView:当图片显示不合适时，可以更改contentMode的属性</div><div class="line">      contents也可以设置contentsGravity 来修正图片的显示</div><div class="line">     </div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><center><br><img src="http://ofldf2gv9.bkt.clouddn.com/布局.png" alt="布局"><br></center> <h4 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h4><center><br><img src="http://ofldf2gv9.bkt.clouddn.com/图层.png" alt="图层"><br></center> <h5 id="视图和图层通过改变transform属性来做变换"><a href="#视图和图层通过改变transform属性来做变换" class="headerlink" title="视图和图层通过改变transform属性来做变换"></a>视图和图层通过改变transform属性来做变换</h5>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">/*</span></div><div class="line">   图层做变换</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">layerTransform</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 旋转45度</span></div><div class="line">    <span class="keyword">let</span> transformrotated =  blueLayer.affineTransform().rotated(by: <span class="type">CGFloat</span>(<span class="type">M_PI_4</span>))</div><div class="line">    blueLayer.setAffineTransform(transformrotated)</div><div class="line">    </div><div class="line">    <span class="comment">// 放大二倍</span></div><div class="line">    <span class="keyword">let</span> transformscaled = blueLayer.affineTransform().scaledBy(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>)</div><div class="line">    blueLayer.setAffineTransform(transformscaled)</div><div class="line">    </div><div class="line">    <span class="comment">// 平移 X轴 和 Y轴</span></div><div class="line">   <span class="keyword">let</span> transformstranslated = blueLayer.affineTransform().translatedBy(x: <span class="number">50</span>, y: <span class="number">50</span>)</div><div class="line">    blueLayer.setAffineTransform(transformstranslated)</div><div class="line">    </div><div class="line">&#125;</div><div class="line">   </div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line">   视图的变换</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">scaledImageView</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">let</span> imageView = <span class="type">UIImageView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">180</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">20</span>))</div><div class="line">    imageView.image = <span class="type">UIImage</span>(named: <span class="string">"desktop"</span>)</div><div class="line">    <span class="keyword">self</span>.view.addSubview(imageView)</div><div class="line">    <span class="comment">//将图片整体方法2倍</span></div><div class="line">    imageView.transform = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">2.0</span>, y: <span class="number">2.0</span>)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h4><center><br><img src="http://ofldf2gv9.bkt.clouddn.com/视觉效果.png" alt="视觉效果"><br></center> <h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><center><br><img src="http://ofldf2gv9.bkt.clouddn.com/变换.png" alt="变换"><br></center> <h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><center><br><img src="http://ofldf2gv9.bkt.clouddn.com/动画.png" alt="动画"><br></center>    <h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><h5 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h5><ul><li>GPU的相关操作: 将图层内容渲染到屏幕上 </li><li>影响GPU的操作  <ul><li>太多的几何结构 </li><li>重绘：由重叠的半透明图层引起 </li><li>离屏绘制：不能直接在屏幕上绘制，必须绘制到离屏图片上下文中  </li><li>过大的图片   </li></ul></li></ul><h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><p>影响CPU的操作  </p><ul><li>布局计算 :自动布局机制  </li><li>视图的懒加载 ：iOS只会在视图控制器的视图显示在屏幕上时，才会加载他  </li><li>Core Graphics绘制：为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢  </li><li>解压图片: PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸;iOS只有在真正绘制的时候才去解压   </li></ul><h5 id="Instruments"><a href="#Instruments" class="headerlink" title="Instruments"></a>Instruments</h5><ul><li>时间分析器：测量方法打断CPU使用情况   </li><li>Core Animation:用来调试各种Core Animation性能问题  <ul><li>Color Blended Layers：基于渲染程度对于屏幕中的混合区域进行绿到红的高亮</li><li>ColorHitsGreenandMissesRed：耗时的图层绘制就会使用红色高亮 </li></ul></li><li>OpenGL ES 驱动：用来调试GPU性能问题  <ul><li>Renderer Utilization - 如果这个值超过了~50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合  </li><li>Tiler Utilization - 如果这个值超过了~50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了  </li></ul></li></ul><h5 id="高效绘制"><a href="#高效绘制" class="headerlink" title="高效绘制"></a>高效绘制</h5><p><strong>避免使用CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:</strong>  </p><blockquote><p>原因：实现这两个方法中的其中之一就必须需要一个绘制上下文，这个上下文的大小基本和原有图层的内存占有量一致；所以重绘的代价太高  </p></blockquote><p><strong>对于Core Graphics 可以使用CAShapLayer来替换绘制图形、直线和曲线，使用CATextLayer绘制文本，CAGradientLayer绘制渐变</strong>   </p><h5 id="图像IO"><a href="#图像IO" class="headerlink" title="图像IO"></a>图像IO</h5><p><strong>使用列表加载远程图片资源</strong>  </p><p>直接加载会导致界面卡顿；因为图片资源大，导致加载时间长；  </p><blockquote><p> 解决方案：在子线程中加载图片，在主线程中更新显示内容  </p></blockquote><p><strong>延迟解压</strong>  </p><blockquote><p>加载图片的时候iOS通常会延迟解压图片的时间;+imageNamed:可以避免延迟加载，但是此方法只是使用<br> 应用资源包中的图片;使用ImageIO框架强制将图片解压出来,渲染的时候直接使用或者使用CATiledLayer（异步加载和显示大型图片）同时使用缓存策略  </p></blockquote><h5 id="关于离屏渲染问题"><a href="#关于离屏渲染问题" class="headerlink" title="关于离屏渲染问题"></a>关于离屏渲染问题</h5><ul><li>设置控件圆角：cornerRadius和masksToBounds一起使用时要考虑性能损耗<br>可以采用CAShapeLayer结合UIBezierPath 绘制圆角的图层来实现 </li><li>控件阴影的设置 采用 shadowPath来创建一个对应形状的阴影路径  </li><li>混合和过度绘制（GPU会放弃绘制被遮挡住的图层像素）  <ul><li>给视图设置背景色，并且不透明  </li><li>设置opaque 为yes  </li></ul></li><li>对象回收 <blockquote><p>处理巨大数量的相似视图或是图层时还有一个技巧就是回收；类似于UITableView的重用机制</p></blockquote></li></ul><div align="center"><br><img src="http://ofldf2gv9.bkt.clouddn.com/iOS核心动画.png" width="600" height="240" alt="iOS核心动画思维导图"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;阅读&lt;a href=&quot;http://wiki.jikexueyuan.com/project/ios-core-animation&quot;&gt;iOS核心动画译文版本&lt;/a&gt;对其中的内容做了概要整理；文中罗列出视图、图层、Core Animation 、Core Graphics的介绍。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS动画" scheme="http://yoursite.com/tags/iOS%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS篇-审核</title>
    <link href="http://yoursite.com/2015/10/15/iOS%E7%AF%87-%E5%AE%A1%E6%A0%B8/"/>
    <id>http://yoursite.com/2015/10/15/iOS篇-审核/</id>
    <published>2015-10-14T16:00:00.000Z</published>
    <updated>2018-06-23T04:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>新版本app上架提交审核，苹果方面返回审核结果说是应用安装后icloud的存储空间会增加8M(app中会解压一个zip压缩包)左右，这个违反了上架的规则；在网上查询得到的信息是NSDocumentDirectory下的数据能不备份到icloud的尽量不要备份，貌似最大的支持备份到5M之内；解决方案有两个；<br><a id="more"></a></p><h4 id="（一）放在NSDocumentDirectory下的数据单独建立文件夹，并且手动设置该路径不需要同步到icloud"><a href="#（一）放在NSDocumentDirectory下的数据单独建立文件夹，并且手动设置该路径不需要同步到icloud" class="headerlink" title="（一）放在NSDocumentDirectory下的数据单独建立文件夹，并且手动设置该路径不需要同步到icloud"></a>（一）放在NSDocumentDirectory下的数据单独建立文件夹，并且手动设置该路径不需要同步到icloud</h4><pre><code>/** *  禁止备份文件目录下的数据 * *  @param URL * *  @return */- (BOOL)addSkipBackupAttributeToItemAtPath:(NSString *) filePathString{    NSURL* URL= [NSURL fileURLWithPath: filePathString];    assert([[NSFileManager defaultManager] fileExistsAtPath: [URL path]]);    NSError *error = nil;    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]                                  forKey: NSURLIsExcludedFromBackupKey error: &amp;error];    if(!success){        NSLog(@&quot;Error excluding %@ from backup %@&quot;, [URL lastPathComponent], error);    }    return success;}</code></pre><blockquote><p><strong>NSURLIsExcludedFromBackupKey</strong>:Key for determining whether the resource is excluded from all backups of app data, returned as a Boolean NSNumber object (read-write).<br>You can use this property to exclude cache and other app support files which are not needed in a backup. Some operations commonly made to user documents cause this property to be reset to false; consequently, do not use this property on user documents.   </p></blockquote><h4 id="（二）将存放在NSDocumentDirectory下的数据更换目录到NSLibraryDiretory下，该目录系统默认不会备份数据到icloud"><a href="#（二）将存放在NSDocumentDirectory下的数据更换目录到NSLibraryDiretory下，该目录系统默认不会备份数据到icloud" class="headerlink" title="（二）将存放在NSDocumentDirectory下的数据更换目录到NSLibraryDiretory下，该目录系统默认不会备份数据到icloud"></a>（二）将存放在NSDocumentDirectory下的数据更换目录到NSLibraryDiretory下，该目录系统默认不会备份数据到icloud</h4><hr><h4 id="沙盒路径的简介"><a href="#沙盒路径的简介" class="headerlink" title="沙盒路径的简介"></a>沙盒路径的简介</h4><h5 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h5><blockquote><p>iOS应用程序只能在为该应用创建的文件系统中读取文件信息，不能去其他地方访问，这个部分就叫做沙盒； </p></blockquote><h5 id="Documents"><a href="#Documents" class="headerlink" title="Documents"></a>Documents</h5><p>苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包括此目录</p><h5 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h5><p>存储程序的默认设置或其它状态信息；</p><ul><li>Library/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除</li><li>Library/Preference：保存用户的偏好设置</li></ul><h5 id="tmp"><a href="#tmp" class="headerlink" title="tmp"></a>tmp</h5><p>提供一个即时创建临时文件的地方</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新版本app上架提交审核，苹果方面返回审核结果说是应用安装后icloud的存储空间会增加8M(app中会解压一个zip压缩包)左右，这个违反了上架的规则；在网上查询得到的信息是NSDocumentDirectory下的数据能不备份到icloud的尽量不要备份，貌似最大的支持备份到5M之内；解决方案有两个；&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之NSCache</title>
    <link href="http://yoursite.com/2015/10/01/OC%E5%9F%BA%E7%A1%80%E4%B9%8BNSCache/"/>
    <id>http://yoursite.com/2015/10/01/OC基础之NSCache/</id>
    <published>2015-10-01T05:30:00.000Z</published>
    <updated>2018-06-23T04:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>需要在项目运行时在内存里缓存某些对象，该如何操作？<br><a id="more"></a></p><h5 id="NSMutableDictionary实现需求"><a href="#NSMutableDictionary实现需求" class="headerlink" title="NSMutableDictionary实现需求"></a>NSMutableDictionary实现需求</h5><ul><li>问题一：当缓存的对象较多，系统抛出memory warning需要手动处理；</li><li>问题二：线程问题，根据key存储或者获取值的时候要考虑线程安全</li></ul><h5 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h5><blockquote><p>An NSCache object is a collection-like container, or cache, that stores key-value pairs, similar to the NSDictionary class. Developers often incorporate caches to temporarily store objects with transient data that are expensive to create. Reusing these objects can provide performance benefits, because their values do not have to be recalculated. However, the objects are not critical to the application and can be discarded if memory is tight. If discarded, their values will have to be recomputed again when needed.  </p><p>NSCache对象是一个类似于NSDictionary存储键值对的容器或缓存。开发人员通常会缓存那些临时创建昂贵的对象，对象的再次被利用能够提升性能;  </p></blockquote><pre><code> #import &lt;Foundation/NSObject.h&gt;@class NSString;@protocol NSCacheDelegate;NS_ASSUME_NONNULL_BEGINNS_CLASS_AVAILABLE(10_6, 4_0)@interface NSCache &lt;KeyType, ObjectType&gt; : NSObject {@private    id _delegate;    void *_private[5];    void *_reserved;}@property (copy) NSString *name;@property (nullable, assign) id&lt;NSCacheDelegate&gt; delegate;- (nullable ObjectType)objectForKey:(KeyType)key;- (void)setObject:(ObjectType)obj forKey:(KeyType)key; // 0 cost- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;- (void)removeObjectForKey:(KeyType)key;- (void)removeAllObjects;@property NSUInteger totalCostLimit;    // limits are imprecise/not strict@property NSUInteger countLimit;    // limits are imprecise/not strict@property BOOL evictsObjectsWithDiscardedContent;@end@protocol NSCacheDelegate &lt;NSObject&gt;@optional- (void)cache:(NSCache *)cache willEvictObject:(id)obj;@end</code></pre><h5 id="NSCache与NSMutableDictionary的对比"><a href="#NSCache与NSMutableDictionary的对比" class="headerlink" title="NSCache与NSMutableDictionary的对比"></a>NSCache与NSMutableDictionary的对比</h5><p>从头文件中可以看出NSCache的API和NSMutableDictionary的基本相似；但从苹果的官方上介绍NSCache的优点：（1）会自动移除对象来释放内存；（2）线程操作安全；（3）键对象不会像NSMutableDictionary中那样被复制；  </p><h5 id="NSCache解析"><a href="#NSCache解析" class="headerlink" title="NSCache解析"></a>NSCache解析</h5><ul><li>countLimit和totalCostLimit来现在cache的数量或者限制cost，cost是指对象在内存中占有的字节数；通常设置为0；</li><li><code>- (void)cache:(NSCache *)cache willEvictObject:(id)obj;</code> 缓存对象将要被移除的时候才会调用该方法。</li></ul><h5 id="SDWebImage-开源框架中的使用"><a href="#SDWebImage-开源框架中的使用" class="headerlink" title="SDWebImage 开源框架中的使用"></a>SDWebImage 开源框架中的使用</h5><p>在SDWebImage中就使用了NScache将image对象在内存中缓存，key就是图片的远程地址；  </p><hr><p>参考<a href="http://nshipster.cn/nscache/" target="_blank" rel="external">NSCache</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h5&gt;&lt;p&gt;需要在项目运行时在内存里缓存某些对象，该如何操作？&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
