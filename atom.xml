<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>華</title>
  
  <subtitle>人无远虑必有近忧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-13T02:37:47.408Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>华子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue-loader+webpack项目工程配置笔记</title>
    <link href="http://yoursite.com/2018/11/25/vue-loader-webpack%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/25/vue-loader-webpack项目工程配置/</id>
    <published>2018-11-25T12:11:36.000Z</published>
    <updated>2019-01-13T02:37:47.408Z</updated>
    
    <content type="html"><![CDATA[<p>由于近期被分配一个vue.js开发的业务模块，需要对此业务模块进行技术支持（bug修复和新需求的迭代）。经过了一周已完成业务熟悉和打包投产的工作，故梳理以下内容加强理解： </p><ul><li>相关名词概念</li><li>vue-loader+webpack项目配置</li><li>webpack配置项目加载各种静态资源以及CSS</li><li>webpack-dev-server的配置和使用  </li></ul><p>在接触web开发的过程中经常会听到以下的名词： </p><ul><li><code>Node.js</code> </li><li><code>NPM</code> </li><li><code>Vue.js</code></li><li><code>webpack</code><br>那么这些名词是什么，做什么用的呢？<a id="more"></a> </li></ul><h3 id="名词概念简介"><a href="#名词概念简介" class="headerlink" title="名词概念简介"></a>名词概念简介</h3><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><blockquote><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。  </p></blockquote><p><code>Node.js</code>使得JavaScript能够像PHP、Python等语言一样进行服务端开发。 </p><h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><blockquote><p>NPM的全称是Node Package Manager，是一个Node.js包管理和分发工具,有了NPM，可以很快的找到特定服务要使用的包，进行下载、安装以及管理已经安装的包  </p></blockquote><h5 id="npm的一些命令"><a href="#npm的一些命令" class="headerlink" title="npm的一些命令"></a>npm的一些命令</h5><ul><li><code>npm install &lt;packageName&gt;</code> :<code>npm install</code>首先会检查<code>node_modules</code>目录中是否存在要安装的模块，如果有就不在安装，及时远程仓库中存在新的版本，也不执行重新安装操作；</li><li><code>npm update &lt;packageName&gt;</code>:先到远程仓库查询，如果本地不存在或者远程仓库版本较新，则执行安装操作。</li><li><code>registry</code>：<code>npm</code>模块仓库提供了一个查询服务，叫做registry，执行<code>npm update react</code>实际是执行<code>https://registry.npmjs.org/react</code></li><li>模块的安装过程：发出<code>npm install</code>命令  –&gt;  <code>npm</code>向<code>registry</code>查询模块压缩包的网址 –&gt; 下载压缩包，存放在~/.npm目录下 –&gt; 解压压缩包到当前项目的node_modules目录</li></ul><h4 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h4><blockquote><p>Vue.js（读音 /vjuː/, 类似于 view）是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p></blockquote><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><blockquote><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle  </p></blockquote><p>通过以上对以上名词的大致了解，那么就开始一步步构建一个简单的web项目  </p><h3 id="webpack打包web工程"><a href="#webpack打包web工程" class="headerlink" title="webpack打包web工程"></a>webpack打包web工程</h3><h4 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h4><p>创建一个<code>web-project</code>的文件夹，命令行切换到<code>web-project</code>下，执行<code>npm init</code>,根据提示填写；<code>web-project</code>下会多出一个package.json的文件包含项目基本信息：  </p><pre><code>{     &quot;name&quot;: &quot;webproject&quot;,     &quot;version&quot;: &quot;1.0.0&quot;,     &quot;description&quot;: &quot;test create web project&quot;,     &quot;main&quot;: &quot;index.js&quot;,     &quot;scripts&quot;: {       &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;     },     &quot;author&quot;: &quot;hua&quot;,     &quot;license&quot;: &quot;ISC&quot;   }   </code></pre><h4 id="安装项目需要的组件"><a href="#安装项目需要的组件" class="headerlink" title="安装项目需要的组件"></a>安装项目需要的组件</h4><ul><li><code>npm install vue vue-loader webpack</code></li><li><code>npm install css-loader</code></li></ul><h4 id="构建一个vue页面"><a href="#构建一个vue页面" class="headerlink" title="构建一个vue页面"></a>构建一个vue页面</h4><p>在<code>web-project</code>下创建<code>src</code>目录，然后再<code>src</code>目录下创建<code>App.vue</code>文件，代码如下 ：  </p><pre><code>&lt;template&gt;     &lt;div id=&quot;text&quot;&gt;{{text}}&lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default{            data(){                return{                    text:&apos;hello vue&apos;                }            }        }    &lt;/script&gt;    &lt;style&gt;    #text{        color: red    }    &lt;/style&gt;</code></pre><h4 id="创建项目的入口文件index-js"><a href="#创建项目的入口文件index-js" class="headerlink" title="创建项目的入口文件index.js"></a>创建项目的入口文件index.js</h4><p>在<code>web-project/src</code>下创建<code>index.js</code>文件，内容如下：  </p><pre><code>import Vue from &apos;vue&apos;import App from &apos;./app.vue&apos;const root = document.createElement(&apos;div&apos;)document.body.appendChild(root)new Vue({    render:(h) =&gt; h(App)}).$mount(root)</code></pre><h4 id="创建webpack的配置文件"><a href="#创建webpack的配置文件" class="headerlink" title="创建webpack的配置文件"></a>创建webpack的配置文件</h4><p>在<code>web-project</code>下创建<code>webpack.config.js</code>文件，内容如下：  </p><pre><code>  const path = require(&apos;path&apos;)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);const config = {    // 设置入口    entry:path.join(__dirname,&apos;src/index.js&apos;),    output:{        filename:&apos;bundle.js&apos;,//打包后js的名称        path:path.join(__dirname,&apos;dist&apos;)// 打包后文件存放的目录    },    plugins:[        new VueLoaderPlugin(),    ],    mode:&apos;development&apos;,    module:{        rules:[            {                test:/\.vue$/,//包含vue的文件使用vue-loader处理                loader:&apos;vue-loader&apos;            },            {                test:/\.css$/,                loader:&apos;css-loader&apos;            }        ]    }}module.exports = config</code></pre><h4 id="在package-json中添加配置"><a href="#在package-json中添加配置" class="headerlink" title="在package.json中添加配置"></a>在package.json中添加配置</h4><p>在<code>scripts</code>结点下添加<code>&quot;build&quot;: &quot;webpack --config webpack.config.js&quot;</code>  </p><h4 id="使用webpack打包工程"><a href="#使用webpack打包工程" class="headerlink" title="使用webpack打包工程"></a>使用webpack打包工程</h4><p>执行<code>npm run build</code>，在项目<code>web-project</code>目录下产生一个<code>dist</code>的文件夹，并且目录下有个<code>bundle.js</code>的文件，至此项目打包已经结束</p><h3 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h3><p>在日常的工作中webpack-dev-server能够使得我们的开发调试更简洁方便，下面让我们来一步步通过配置来使用webpack-dev-server； </p><h4 id="webpack-dev-server安装"><a href="#webpack-dev-server安装" class="headerlink" title="webpack-dev-server安装"></a>webpack-dev-server安装</h4><p>执行<code>npm install webpack-dev-server</code> 我们在打包的使用希望有个html文件承载我们的bundle.js，所以要安装一个html-webpack-plugin，执行<code>npm install html-webpack-plugin</code>   </p><p>在不同的操作系统中，我们希望执行的命令是统一的所以要安装cross-env，执行 <code>npm install cross-env</code> </p><h4 id="修改package-json中的配置"><a href="#修改package-json中的配置" class="headerlink" title="修改package.json中的配置"></a>修改package.json中的配置</h4><p> 在package.json文件中的scripts节点下，修改build节点为<code>cross-env NODE_ENV=production webpack --config webpack.config.js</code>，代表生产环境的命令脚本，新增dev节点，内容为<code>cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js</code>，为开发环境执行脚本。</p><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><pre><code>const path = require(&apos;path&apos;)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);const isDev = process.env.NODE_ENV === &apos;development&apos;const HTMLPlugin = require(&apos;html-webpack-plugin&apos;)const webpack = require(&apos;webpack&apos;)const config = {    target:&apos;web&apos;,    // 设置入口    entry:path.join(__dirname,&apos;src/index.js&apos;),    output:{        filename:&apos;bundle.js&apos;,//打包后js的名称        path:path.join(__dirname,&apos;dist&apos;)// 打包后文件存放的目录    },    plugins:[        new VueLoaderPlugin(),        new webpack.DefinePlugin({            &apos;process.env&apos;:{                NODE_ENV:isDev ? &apos;&quot;development&quot;&apos;:&apos;&quot;production&quot;&apos;            }        }),        new HTMLPlugin()    ],    mode:&apos;development&apos;,    module:{        rules:[            {                test:/\.vue$/,//包含vue的文件使用vue-loader处理                loader:&apos;vue-loader&apos;            },            {                test:/\.css$/,                loader:&apos;css-loader&apos;            }        ]    }}if(isDev){   config.devServer={       port:8008,       host:&apos;0.0.0.0&apos;,       overlay:{           errors:true       },       hot:true   }   config.plugins.push(       new webpack.HotModuleReplacementPlugin(),       new webpack.NoEmitOnErrorsPlugin()   )}module.exports = config</code></pre><h3 id="页面显示"><a href="#页面显示" class="headerlink" title="页面显示"></a>页面显示</h3><p>此时在浏览器中输入<code>http://0.0.0.0:8008/</code>即可访问项目页面。  </p><blockquote><p>内容参照  </p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="external">阮一峰-npm 模块安装机制简介</a><br><a href="https://www.imooc.com/learn/935" target="_blank" rel="external">慕课网-Vue+Webpack打造todo应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于近期被分配一个vue.js开发的业务模块，需要对此业务模块进行技术支持（bug修复和新需求的迭代）。经过了一周已完成业务熟悉和打包投产的工作，故梳理以下内容加强理解： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相关名词概念&lt;/li&gt;
&lt;li&gt;vue-loader+webpack项目配置&lt;/li&gt;
&lt;li&gt;webpack配置项目加载各种静态资源以及CSS&lt;/li&gt;
&lt;li&gt;webpack-dev-server的配置和使用  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在接触web开发的过程中经常会听到以下的名词： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Node.js&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;NPM&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vue.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webpack&lt;/code&gt;&lt;br&gt;那么这些名词是什么，做什么用的呢？
    
    </summary>
    
      <category term="Vue.js" scheme="http://yoursite.com/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-《程序是怎么跑起来的》-part1</title>
    <link href="http://yoursite.com/2018/10/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B-part1/"/>
    <id>http://yoursite.com/2018/10/28/读书笔记-《程序是怎么跑起来的》-part1/</id>
    <published>2018-10-28T03:03:08.000Z</published>
    <updated>2019-01-13T03:10:51.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对于程序员来说CPU是什么"><a href="#对于程序员来说CPU是什么" class="headerlink" title="对于程序员来说CPU是什么"></a>对于程序员来说CPU是什么</h2><p>在日常使用高级编程语言进行编程时，是否考虑过以下问题：   </p><ul><li>程序是什么</li><li>程序的组成部分</li><li>什么是机器语言</li><li>运行的程序在计算机中的存储位置</li><li>内存地址是什么</li><li>负责程序解析和运行的是哪个</li></ul><a id="more"></a>  <p>如果以上的概念不能很清楚的描述出来，那么就需要了解一下对程序员来讲CPU是什么了。<br>对于CPU的解析首先需要知道程序的运行流程：使用一些高级语言<code>C</code>、<code>JAVA</code>、<code>Objective-C</code>等编写的程序 —-&gt; 编译器会将源码编译为机器语言的可执行文件 —-&gt; 程序运行后会将可执行文件加载到内存中形成副本 —-&gt; CPU解释并执行程序内容 【转化成的机器语言其实是由CPU中的寄存器来处理的】；例如 a = 1 + 2 这样的运算，转化为机器语言后是通过寄存器进行相加运算和存储的。  </p><h4 id="CPU的组成部分"><a href="#CPU的组成部分" class="headerlink" title="CPU的组成部分"></a>CPU的组成部分</h4><p>CPU是中央处理器，负责计算机的控制和运算，它主要包含以下4个部分： </p><ul><li>寄存器：暂时存储指令、数据处理对象【一个CPU会包含20~100个寄存器】</li><li>控制器：把内存上的指令、数据读入寄存器，并根据指令的执行结果来控制计算机【控制器的控制内容：控制键盘、鼠标和内存媒介的输入输出】</li><li>运算器：负责把从内存读到寄存器中的指令和数据进行运算</li><li>时钟： 负责发出CPU开始计时的时钟信号</li></ul><h4 id="程序运行机制中CPU的各部分都起到了哪些作用"><a href="#程序运行机制中CPU的各部分都起到了哪些作用" class="headerlink" title="程序运行机制中CPU的各部分都起到了哪些作用"></a>程序运行机制中CPU的各部分都起到了哪些作用</h4><p>程序启动 —&gt; 根据时钟信号 —&gt; 控制器从内存中读取指令和数据【对指令进行解释和执行】—&gt; 运算器对指令进行运算 —&gt; 控制器根据运算结果控制计算器 </p><h4 id="寄存器简介"><a href="#寄存器简介" class="headerlink" title="寄存器简介"></a>寄存器简介</h4><p>寄存器用来存储指令、数据处理对象，按照使用功能的不同大致分为8类：  </p><ul><li>累加寄存器：负责存储运算数据和运算的结果数据</li><li>基址寄存器：存储数据内存的起始地址</li><li>标志寄存器： 存储运算处理后的CPU的状态</li><li>指令寄存器 ：存储指令</li><li>栈寄存器  ： 存储栈区域的起始地址</li><li>通用寄存器 ： 存储任意数据</li><li>变址寄存器 ： 存储基地址寄存器的相对地址</li><li>程序计数器：存储下一条指令所在的内存地址</li></ul><h4 id="决定程序流程-–-程序计数器"><a href="#决定程序流程-–-程序计数器" class="headerlink" title="决定程序流程 – 程序计数器"></a>决定程序流程 – 程序计数器</h4><p>程序计数器中存储的是程序的执行指令，CPU的控制器会参照程序计数器中存储的内存地址，去查找相应的指令去执行</p><h4 id="条件分支和循环机制"><a href="#条件分支和循环机制" class="headerlink" title="条件分支和循环机制"></a>条件分支和循环机制</h4><p>CPU进行运算时，标志寄存器的数值会根据运算结果自动设定，条件分支在跳转指令前会进行比较运算  </p><h4 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h4><p>如何解决函数内部执行完毕后，CPU继续执行函数入口地址下一个程序计数器中存储的指令：使用机器语言的call指令和return指令可以解决：  </p><ul><li>call指令：会把调用函数后要执行的指令地址存在栈中，函数执行完毕后再函数的出口执行return指令；  </li><li>return指令：把保存在栈中指令设置到程序计数器中   </li></ul><h4 id="机器语言指令的主要类型和功能"><a href="#机器语言指令的主要类型和功能" class="headerlink" title="机器语言指令的主要类型和功能"></a>机器语言指令的主要类型和功能</h4><ul><li>数据传送指令：寄存器和内存、内存和内存、寄存器和外围设备之间的数据读写操作</li><li>运算指令 ： 累加寄存器执行算数运算、逻辑运算、比较运算和位移运算</li><li>跳转指令： 实现条件分支、循环、强制跳转等</li><li>call/return指令 ： 函数的调用/返回调用前的地址</li></ul><h4 id="对文章开头问题进行解答"><a href="#对文章开头问题进行解答" class="headerlink" title="对文章开头问题进行解答"></a>对文章开头问题进行解答</h4><ul><li>程序是什么 ：指导计算机执行操作的一组指令集</li><li>程序的组成部分 ： 指令和数据</li><li>什么是机器语言 ： CPU能够理解和执行的语言</li><li>运行的程序在计算机中的存储位置 ：内存</li><li>内存地址是什么 ： 代表数据和指令在内存中位置的整数值</li><li>负责程序解析和运行的是哪个 ： CPU  </li></ul><blockquote><p>资料来源  </p></blockquote><p> <strong>程序是怎么跑起来的–《对程序员来说CPU是什么》</strong>   </p><h2 id="数据是用二进制数表示的"><a href="#数据是用二进制数表示的" class="headerlink" title="数据是用二进制数表示的"></a>数据是用二进制数表示的</h2><p> 在计算机内部数据和信息是使用二进制来存储的，那么二进制是如何表示信息以及它的运算机制是怎么样的呢？如下有几个问题可以思考一下？  </p><ul><li>32位是几个字节</li><li>二进制01011100转化为十进制是多少</li><li>二进制数00001111左移两位，会变成原来的几倍</li><li>补码形式表示的8位二进制数11111111，用十进制表示的话是多少</li><li>补码形式表示的8位二进制数10101010，用16位的二进制表示的话是多少</li><li>反转部分图形模式，使用的是什么逻辑  </li></ul><p>以上问题如果不能清晰的回答那么就需要了解一下二进制的基础知识了。<br><!--more--></p><h4 id="二进制表示计算机信息的原因"><a href="#二进制表示计算机信息的原因" class="headerlink" title="二进制表示计算机信息的原因"></a>二进制表示计算机信息的原因</h4><p>二进制<strong>是计算机技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”</strong><br>由于计算机内部是由<em>集成电路（integrated circuit)</em>这种电子部件构成，IC只有两种状态，0V和5V，即有电流和无电流两种模式； 计算机处理信息最小的单元是位，二进制的位数一般是8位、16位、32位、也就是8的倍数，8位二进制数被称为一个字节， 内存和磁盘都是以字节单位来存储和读写数据的，因此字节是信息的基本单位。  </p><h4 id="二进制如何同十进制之间进行转化"><a href="#二进制如何同十进制之间进行转化" class="headerlink" title="二进制如何同十进制之间进行转化"></a>二进制如何同十进制之间进行转化</h4><p>先要了解一下位权的概念，首先了解十进制的位权，例如39十位上3的位权是10，个位9的位权是1，那么39的表示就是3x10+9x1 = 39；同样的二进制也是，例如101从右侧向左 1x2^0 + 0x2^1 + 1x2^1。这样二进制转化为十进制，只需要各个数位上的数字与位权相乘然后相加即可。<br>十进制转化为二进制，根据逢<code>二进一</code>的原则，利用短除法求余数的方式可以转化。 </p><h4 id="移位运算和乘除运算的关系"><a href="#移位运算和乘除运算的关系" class="headerlink" title="移位运算和乘除运算的关系"></a>移位运算和乘除运算的关系</h4><p>移位运算指的是将二进制数的各个数位进行左移或右移的操作。其中左移运算符<code>&lt;&lt;</code>,右移的运算符<code>&gt;&gt;</code>,移位运算代替乘除法，十进制左移会变成原来10倍、100倍、1000倍…同样在不考虑符号位的情况下二进制左移后会变成原来的2倍、4倍、8倍，相反右侧移动会变成1/2、1/4、1/8…</p><h4 id="便于计算机处理的补数-补码"><a href="#便于计算机处理的补数-补码" class="headerlink" title="便于计算机处理的补数(补码)"></a>便于计算机处理的补数(补码)</h4><p>二进制表示负数时会把最高位作为符号位来使用，因此最高位也被称为符号位，符号位为0表示正数，符号位为1表示负数；计算机中进行减法操作其实也是按照加法操作进行的；那么如何使用8位二进制来表示-1呢：  </p><pre><code>如何用二进制表示负数-1第一步： 取1的8位二进制表示 ： 00000001第二步：按位取反：   11111110第三步：执行+1操作： 11111111得到的11111111就是-1的8位二进制</code></pre><h4 id="逻辑右移和算术右移的区别"><a href="#逻辑右移和算术右移的区别" class="headerlink" title="逻辑右移和算术右移的区别"></a>逻辑右移和算术右移的区别</h4><p>关于逻辑右移：右移后左侧空位用0填充，而算术右移动：空出来的高位用符号位上的数字填充，下面看一下-4右移2位得到-1；</p><pre><code>-4 ：11111100  先右移2位得到111111，高位使用符号位数字填充11，就得到了-1 ：11111111</code></pre><p>关于符号扩充：保持值不变的情况下，将8位二进制准话为16位或是32位，不管正数还是负数都使用符号位上的数字去扩充高位即可。</p><h4 id="掌握逻辑运算的窍门"><a href="#掌握逻辑运算的窍门" class="headerlink" title="掌握逻辑运算的窍门"></a>掌握逻辑运算的窍门</h4><p>逻辑运算包含如下几种：  </p><ul><li>逻辑非 NOT ： 0变成1，1变成0</li><li>逻辑与  AND：两个都为1才是1，否则为0</li><li>逻辑或  OR ： 至少有一方为1，结果为1，其他为0 </li><li>逻辑异或 XOR： 排斥相同数值的运算，相同为0，不同为1  </li></ul><h4 id="对为文章开头问题的解答"><a href="#对为文章开头问题的解答" class="headerlink" title="对为文章开头问题的解答"></a>对为文章开头问题的解答</h4><ul><li>32位是几个字节 ：8个</li><li>二进制01011100转化为十进制是多少 ： 92</li><li>二进制数00001111左移两位，会变成原来的几倍 ： 4倍</li><li>补码形式表示的8位二进制数11111111，用十进制表示的话是多少 ： -1</li><li>补码形式表示的8位二进制数10101010，用16位的二进制表示的话是多少 ： 1111111110101010</li><li>反转部分图形模式，使用的是什么逻辑  ：XOR（异或）  </li></ul><blockquote><p>资料来源  </p></blockquote><p> <strong>程序是怎么跑起来的–《数据是用二进制表示的》</strong></p><h2 id="计算机进行小数运算"><a href="#计算机进行小数运算" class="headerlink" title="计算机进行小数运算"></a>计算机进行小数运算</h2><p>关于计算机进行小数运算可以先了解以下问题：  </p><ul><li>二进制数0.1，用十进制数表示的话是多少?</li><li>用小数点后有3位的二进制数，能表示十进制数0.625吗？</li><li>将小数分为符号、尾数、基数、指数4部分进行表现的形式称为什么？</li><li>二进制数的基数是什么？</li><li>通过把0作为数值范围的中间值，从而在不使用符号位的情况下来表示负数的表示方法称为什么？</li><li>10101100.01010011这个二进制数，用十六进制数表示的话是多少？  <!--more-->  </li></ul><p>以上问题是不是会有些模糊不清的几个呢，那么就需要了解计算机是如何对小数进行保存和操作的了。首先将1011.0011这个有小数点的二进制数转化成十进制该如何操作，整数部分使用位权和对应位置的数字相乘然后再进行相加操作即可，小数部分同理，只是位权变成了2^(-1)、2^(-2)… </p><pre><code>1011.0011  :二进制      1x2^3+0x2^2+1x2^1+1x2^0+0x2^(-1)+0x2^(-2)+1x2^(-3)+1x2^(-4) = 11.1875 :十进制  </code></pre><h4 id="将0-1累加100得到的结果不是10"><a href="#将0-1累加100得到的结果不是10" class="headerlink" title="将0.1累加100得到的结果不是10"></a>将0.1累加100得到的结果不是10</h4><pre><code>void sum_hundred_float(){    float sum = 0.0;    for (int i=0; i&lt;100; i++) {        sum +=0.1;    }    printf(&quot;%f\n&quot;,sum); //结果为：10.000002}  </code></pre><p>对于以上结果到底问题出现在哪呢？  </p><h4 id="计算机出错的原因"><a href="#计算机出错的原因" class="headerlink" title="计算机出错的原因"></a>计算机出错的原因</h4><p>有一些十进制的小数无法转换成二进制数的正确表示，只能够取近似值，例如十进制数0.1就无法用二进制数来表示；小数点后四位用二进制数表示时的数值范围：0.0000~0.1111，因此这里只能表示0.5、0.25、0.125、0.0625这四个二进制小数点后面的位权组合而成（相加总和）的小数</p><h4 id="什么是浮点数"><a href="#什么是浮点数" class="headerlink" title="什么是浮点数"></a>什么是浮点数</h4><p>浮点数的表示形式：符号+尾数+基数+指数<br>双精度浮点数和单精度浮点数在表示同一个数值时使用的位数不同   </p><h4 id="正则表达式和EXCESS系统"><a href="#正则表达式和EXCESS系统" class="headerlink" title="正则表达式和EXCESS系统"></a>正则表达式和EXCESS系统</h4><p>尾数部分使用正则表达式，可以将表现形式多样的浮点数统一为一种表现形式；例如：十进制的0.75就有很多表现形式，0.75 x 10^0 、0.75 x 10^1,但遵循小数点前是0，小数点后不为0的原则 0.75 x 10^0 是标准的形式；同样二进制中将小数点前面的值固定为1的正则表达式；<br>指数部分使用EXCESS系统，使用这种方式主要是为了表示负数时不使用符号位【待理解】 </p><h4 id="如何避免计算机在处理浮点数时出错"><a href="#如何避免计算机在处理浮点数时出错" class="headerlink" title="如何避免计算机在处理浮点数时出错"></a>如何避免计算机在处理浮点数时出错</h4><ul><li>一些实际运算的误差可以忽略不计 </li><li>将浮点数转化为整数再进行运算，尤其在设计财务方面的处理时，一定要将小数转化为浮点数或者采用BCD(Binary,Coded,Decimal)的方式</li></ul><h4 id="二进制和十六进制"><a href="#二进制和十六进制" class="headerlink" title="二进制和十六进制"></a>二进制和十六进制</h4><p>二进制表示数据时，可能位数太长不利于查看，此时可以采用十六进制表示，二进制的4位正好相当于十六进制的1位， 例如： </p><pre><code>1011.0110 ==》 B.6 小数点后位数不够低位补0即可  </code></pre><h4 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h4><ul><li>二进制数0.1，用十进制数表示的话是多少? ：0.5</li><li>用小数点后有3位的二进制数，能表示十进制数0.625吗？ ： 可以，0.625转化为二进制为:0.101</li><li>将小数分为符号、尾数、基数、指数4部分进行表现的形式称为什么？:浮点数</li><li>二进制数的基数是什么？：2</li><li>通过把0作为数值范围的中间值，从而在不使用符号位的情况下来表示负数的表示方法称为什么？：EXCESS系统表现 </li><li>10101100.01010011这个二进制数，用十六进制数表示的话是多少？：AC.53 （每4位进行一次求值运算）</li></ul><blockquote><p>资料来源  </p></blockquote><p> <strong>程序是怎么跑起来的–《数据是用二进制表示的》</strong>  </p><h2 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h2><p>在编程中熟练使用内存就需要对内存进行详细的了解，看一下如下问题：  </p><ul><li>有十个地址信号引脚的内存IC(集成电路)，可以指定的地址范围是多少？： 0~1023</li><li>高级编程语言中的数据类型表示的是什么？ ：占据内存区域的大小和存储在该内存区域的数据类型</li><li>在32位内存地址的环境中，指针变量的长度是多少位？：32位</li><li>与物理内存有着相同构造的数组的数据类型长度是多少位？：1字节</li><li>用LIFO方式进行数据读写的数据结构成为什么？：栈</li><li>根据数据的大小链表分叉成两个方向的数据结构称为什么？：二叉查找树（从节点分成两个叉的树状数据结构） </li></ul><!--more--> <p> 如果对以上问题存在疑虑，那么就需要对内存进行一下了解了。  </p><h4 id="内存的物理机制"><a href="#内存的物理机制" class="headerlink" title="内存的物理机制"></a>内存的物理机制</h4><p>内存IC中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚，通过为其指定地址，来进行数据的读写。内存中能存储多少数据是由地址信号决定的；数据信号表示一次可以输入输出的数据字节数；控制信号控制内存的读写操作。内存IC内部有大量可以存储8位数据的地方，通过地址指定这些场所，之后即可进行数据的读写。  </p><h4 id="内存的逻辑模型"><a href="#内存的逻辑模型" class="headerlink" title="内存的逻辑模型"></a>内存的逻辑模型</h4><p>内存的逻辑模型类似与房屋一样，每一层都存储着数据，变量的数据类型不同，所占的数据内存大小也不同<br>  char、short、long这些数据类型代表在内存中开辟的空间大小是不一样的； </p><h4 id="简单的指针"><a href="#简单的指针" class="headerlink" title="简单的指针"></a>简单的指针</h4><p> 指针也是一种变量，它所表示的不是数据的值，而是存储着数据的内存地址，通过指针可以对任意地址的数据进行读写；32位的内存地址,指针变量的长度也是32位；char <em>d; short </em>e;long *f;使用数据类型声明指针表示的是从指针存储的地址中一次能够读写的数据字节数  </p><h4 id="数组是高效使用内存的基础"><a href="#数组是高效使用内存的基础" class="headerlink" title="数组是高效使用内存的基础"></a>数组是高效使用内存的基础</h4><p>数组是多个相同数据类型的数据在内存中连续排序的形式，数组和内存的物理构造是一样的  </p><h4 id="栈、队列以及环形缓冲区"><a href="#栈、队列以及环形缓冲区" class="headerlink" title="栈、队列以及环形缓冲区"></a>栈、队列以及环形缓冲区</h4><p>数据的出入顺序，栈：先进后出，栈的原意：干草堆积如山；队列：先进先出；<br>环形缓冲区：数组首位相连形成的存储结构  </p><h4 id="链表和二叉搜索树"><a href="#链表和二叉搜索树" class="headerlink" title="链表和二叉搜索树"></a>链表和二叉搜索树</h4><p> 链表：数组的每一个元素存储两个值：数据+下一个元素的索引<br> 二叉查找树：在链表的基础上往数组中追加元素时，考虑到数据的大小关系，将其分为左右两个方向的表现形式 </p><h3 id="内存和磁盘的关系"><a href="#内存和磁盘的关系" class="headerlink" title="内存和磁盘的关系"></a>内存和磁盘的关系</h3><p>关于内存和磁盘的关系有如下问题： </p><ul><li>存储程序方式指的是什么？：在存储装置中保存程序，并逐一运行的方式</li><li>通过使用内存来提高磁盘访问速度的机制是什么？：磁盘缓存</li><li>把磁盘的一部分作为假想内存来使用的机制称为什么？：虚拟内存</li><li>windows中，在程序运行时，存储着可以动态加载调用的函数和数据的文件称为什么？： DLL（Dynamic Link Library）</li><li>在EXE程序文件中，静态加载函数的方式是什么？：静态链接</li><li>在windows计算机中，一般磁盘的1个扇区是多少字节？：512个字节(扇区是磁盘保存数据的物理单位)  </li></ul><h4 id="程序必须读入到内存中才能执行"><a href="#程序必须读入到内存中才能执行" class="headerlink" title="程序必须读入到内存中才能执行"></a>程序必须读入到内存中才能执行</h4><p>   CPU解析和运行程序是从根据程序计数器从内存中读取，因此磁盘中的程序需要加载到内存中才能被执行 </p><h4 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h4><p>  把从磁盘获取的数据在内存空间中缓存一份，如果再次使用的时候直接从内存空间中获取，加快访问速度；<br>   例如：web浏览器的实现，网络请求回来的数据会缓存到磁盘中，然后再次需要显示数据的时候从磁盘中加载 </p><h4 id="虚拟内存把磁盘当作部分内存来使用"><a href="#虚拟内存把磁盘当作部分内存来使用" class="headerlink" title="虚拟内存把磁盘当作部分内存来使用"></a>虚拟内存把磁盘当作部分内存来使用</h4><p> 磁盘的一部分假想为内存使用，在内存不足时，也可以运行程序【把实际内存和磁盘上的虚拟内存的内容进行部分置换】<br>虚拟内存分为分页式和分段式两种；<br>      分页式：将程序按照页(page)为单位在磁盘的虚拟内存中分割，然后以页为单位与内存进行置换  </p><h4 id="节约内存的编程方法-操作系统内存固定的情况下"><a href="#节约内存的编程方法-操作系统内存固定的情况下" class="headerlink" title="节约内存的编程方法[操作系统内存固定的情况下]"></a>节约内存的编程方法[操作系统内存固定的情况下]</h4><ul><li>通过DLL文件实现函数共有，DLL文件是在程序运行期间可以直接调用的Library(函数和数据的集合)</li><li>通过调用_stdcall来减小程序文件的大小,主要是栈清理操作时能减少占用的内存</li></ul><h4 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h4><p>磁盘是通过将物理表面划分为多个空间来使用的，划分的方式有扇区方式和可变长方式 </p><ul><li>扇区方式：将磁盘划分为固定长度，</li><li>磁道：把磁盘表面分成若干同心圆的空间就是磁道。把磁道按照固定大小划分而成的空间就是扇区，一个扇区是512字节</li><li><p>可变长方式：将磁盘划分为长度可变的空间</p><blockquote><p>资料来源  </p></blockquote><p><strong>程序是怎么跑起来的–《熟练使用有棱有角的内存》和《内存和磁盘的亲密关系》</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对于程序员来说CPU是什么&quot;&gt;&lt;a href=&quot;#对于程序员来说CPU是什么&quot; class=&quot;headerlink&quot; title=&quot;对于程序员来说CPU是什么&quot;&gt;&lt;/a&gt;对于程序员来说CPU是什么&lt;/h2&gt;&lt;p&gt;在日常使用高级编程语言进行编程时，是否考虑过以下问题：   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序是什么&lt;/li&gt;
&lt;li&gt;程序的组成部分&lt;/li&gt;
&lt;li&gt;什么是机器语言&lt;/li&gt;
&lt;li&gt;运行的程序在计算机中的存储位置&lt;/li&gt;
&lt;li&gt;内存地址是什么&lt;/li&gt;
&lt;li&gt;负责程序解析和运行的是哪个&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-《软技能》事业篇</title>
    <link href="http://yoursite.com/2018/08/18/%E8%AF%BB%E3%80%8A%E8%BD%AF%E6%8A%80%E8%83%BD%E3%80%8B/"/>
    <id>http://yoursite.com/2018/08/18/读《软技能》/</id>
    <published>2018-08-18T09:37:48.000Z</published>
    <updated>2018-08-18T12:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>  《软技能》一书旨在让开发人员如何成为一名优秀的工程师，它涉及的主要七个方面：  </p><ul><li>事业</li><li>自我营销</li><li>学习</li><li>生产力</li><li>理财</li><li>身体</li><li>精神</li></ul><a id="more"></a>  <h2 id="事业"><a href="#事业" class="headerlink" title="事业"></a>事业</h2><p>   《软技能》中提出<strong>你所犯的最大的错误就是相信自己是在为别人工作。这样一来你对工作的安全感已燃尽。职业的驱动力一定是来自个体本身。</strong>      </p><p>文章中指出多数软件开发者所犯的最大的错误在于没有把软件开发当成一桩生意来看。职业规划应该像管理企业一样制定最优的决策和保证生产力的持续提升。所以应该把你现在的公司当做你的一个客户，然后像企业一样去思考，时刻去想作为一个企业我能提供什么，这样你的工作方式、处理自己财务的方式、需求新工作的方式都会得到改变。</p><h3 id="你的目标是什么"><a href="#你的目标是什么" class="headerlink" title="你的目标是什么"></a>你的目标是什么</h3><p>软件开发工程师要确定自己的目标，初级、中级、高级、资深等，还是走管理路线，你要确定自己的目标；<br>设立目标，这个很关键，为职业生涯设立一个大目标然后去拆分，月目标、周目标，时刻让自己知道在追求什么</p><h3 id="人际交往能力"><a href="#人际交往能力" class="headerlink" title="人际交往能力"></a>人际交往能力</h3><p>软件开发者整体给人的印象就是呆板不容易沟通，<strong>别管我，我只想一个人安静的写代码</strong>这句话同行们都应该说过。实际上软件开发就是与他人打交道的过程，假象你研发的东西没人使用，那他的意义在于什么呢？我们在工作中会与产品、测试、业务、运营等人员沟通，所以沟通是极其重要的。那么如何与人打交道，以下几点很受用：  </p><ul><li>每个人都希望感到自己很重要</li><li>永远不要批评</li><li>换位思考</li><li>避免争吵</li></ul><h3 id="破解面试之道"><a href="#破解面试之道" class="headerlink" title="破解面试之道"></a>破解面试之道</h3><ul><li>个人博客和github对于研发人员很重要，当面试官看过你的博客，那么面试成功率就会很大；   </li><li>突破常规从期待加入公司的员工入手，建立联系，简历走内部推荐模式；</li><li>确保自己仍旧保持技术能力，如果你力所不及，那么所有的面试技巧都不会帮助到你；</li><li>即使不换新工作也要出去面试，获取面试的经验，这样你真正面试的时候就会游刃有余；  </li></ul><h3 id="就业选择"><a href="#就业选择" class="headerlink" title="就业选择"></a>就业选择</h3><p>一个软件开发工程师可以从事哪些工作:   </p><ul><li>雇员 </li><li>独立咨询师</li><li>创业者</li></ul><h3 id="你是哪类开发人员"><a href="#你是哪类开发人员" class="headerlink" title="你是哪类开发人员"></a>你是哪类开发人员</h3><p>我们在选择律师的时候会根据具体的案件去选择，软件开发工程师也是你需要在自己的专业领域做的卓越，开发人员的专业领域包含：   </p><ul><li>Web开发栈</li><li>嵌入式系统</li><li>特定操作系统</li><li>移动开发</li><li>框架</li><li>软件系统</li></ul><h3 id="公司与公司是不一样"><a href="#公司与公司是不一样" class="headerlink" title="公司与公司是不一样"></a>公司与公司是不一样</h3><p>你选择的任职公司会影响你的整体幸福感、存在感和归属感；比较一下不同种类公司的优缺点</p><table><thead><tr><th>公司规模</th><th>优点</th><th>缺点  </th></tr></thead><tbody><tr><td>小公司</td><td>承担多种职责，灵活的角色转换，汇报潜力大</td><td>没法安静的写代码，稳定性差</td></tr><tr><td>中等公司</td><td>工作稳定，加班少</td><td>变化很慢，没有机会使用新技术</td></tr><tr><td>大公司</td><td>完备的流程化，培训机会多，大型有影响力的作用</td><td>充斥官僚作风，可能只负责代码库的一小部分</td></tr></tbody></table><p>在选择公司的时候要权衡利弊，多花时间思考自己喜欢在什么样的环境下工作，多大的规模符合你自己理想的工作环境   </p><h3 id="攀登晋升阶梯"><a href="#攀登晋升阶梯" class="headerlink" title="攀登晋升阶梯"></a>攀登晋升阶梯</h3><ul><li>承担更多的责任</li><li>引人注目  <ul><li>提供演讲和培训</li><li>发表意见</li><li>保证“曝光度”</li></ul></li><li>自学 <ul><li>参加培训</li><li>考取证书</li><li>继续深造 </li></ul></li><li>成为问题的解决者<ul><li>如果你能解决别人不能解决的问题，你就能轻而易举成为最有价值的人</li></ul></li><li>关于政治  <ul><li>保持警惕之心</li><li>脚踏实地</li></ul></li></ul><p>在晋升之路上，自学占有很大比重的，要确定自学的最有价值的东西是什么，然后指定计划去执行；  </p><h3 id="成为专业人士"><a href="#成为专业人士" class="headerlink" title="成为专业人士"></a>成为专业人士</h3><blockquote><p>专业人士严肃对待自己的责任和事业，愿意做出艰难的选择去做自己认为正确的事情–往往还要自己承担代价  </p></blockquote><p>如何成为专业人士：首先你要养成良好的习惯；你是否有自己的时间管理计划呢？第二天的工作内容是什么，你是如何安排的等等。追求品质，完善自我；工作的完成分为很多等级，开发人员应该极力追求质量的控制；想象一下你提交的版本有问题会引发多少连锁的反应，测试工程师，运维工程师等等都会受到牵连，所以交付质量非常重要；<br>成为专业人员是一个持续性的过程，要有很好的耐性。 </p><h3 id="假装自己能成功"><a href="#假装自己能成功" class="headerlink" title="假装自己能成功"></a>假装自己能成功</h3><p>假装自己能成功是一个自我暗示，能让自己增强自信心；我们都会面对困境–接到的任务自己一无所知，会感到不自在，无能为力。消除这种情绪就要“假装自己能成功”；<br>这个技巧同时适用于面试阶段，碰到不会的问题，可以表现自己有信心解决。但一定不能表现为自大。</p><h3 id="请勿陷入技术狂热"><a href="#请勿陷入技术狂热" class="headerlink" title="请勿陷入技术狂热"></a>请勿陷入技术狂热</h3><p>天生一物必有用，php是最好的语言可以当成个调侃，但不要去比对不同语言的孰好孰坏，一定要争论个第一出来，其实完全没有意义。我们应该对技术保持开放的心态，而不是固守自己已经了解的技术。突破于此你就会发现更多的机会向你涌来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  《软技能》一书旨在让开发人员如何成为一名优秀的工程师，它涉及的主要七个方面：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事业&lt;/li&gt;
&lt;li&gt;自我营销&lt;/li&gt;
&lt;li&gt;学习&lt;/li&gt;
&lt;li&gt;生产力&lt;/li&gt;
&lt;li&gt;理财&lt;/li&gt;
&lt;li&gt;身体&lt;/li&gt;
&lt;li&gt;精神&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随感" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>生活篇--说说三观</title>
    <link href="http://yoursite.com/2017/06/04/%E7%94%9F%E6%B4%BB%E7%AF%87--%E8%AF%B4%E8%AF%B4%E4%B8%89%E8%A7%82/"/>
    <id>http://yoursite.com/2017/06/04/生活篇--说说三观/</id>
    <published>2017-06-04T09:37:48.000Z</published>
    <updated>2018-06-23T04:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="人生观"><a href="#人生观" class="headerlink" title="人生观"></a>人生观</h3><blockquote><p>对于人生的根本态度与看法  </p></blockquote><p>   人生千姿百态，每个人都是一个演员在无剧本的人生舞台上做着自己的表演。有句话说<strong>意识决定形态</strong>，我个人浅显的理解就是你自己的意愿想通过哪种姿态展现自己， 那么在世人面前你就是以哪种姿态呈现。<br>有时候我们会感慨某某活成了我们自己想要的模样，其实本质上我们都有活成某种模样的意识但最终为什么差别很大？主要原因是缺乏行动，多数人都具有正确的人生观：积极生活、努力奋斗、追求幸福等；但又有多少勤勤恳恳的去实践自己的人生观呢？经常会听到说这人的做事态度不错，但请不要忘记最终衡量你的还是做事的结果。获取正确的人生观容易，困难的是通过正确的人生观来让生活极大丰富才是最困难的事情！<br><a id="more"></a></p><h4 id="人生观主要包含哪些"><a href="#人生观主要包含哪些" class="headerlink" title="人生观主要包含哪些"></a>人生观主要包含哪些</h4><ul><li>友谊观</li><li>恋爱观</li><li>审美观</li><li>道德观</li><li>苦乐观</li><li>幸福观</li></ul><h3 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h3><blockquote><p>它是人们对世界的基本看法和观点.世界观具有实践性，人的世界观是不断更新、不断完善、不断优化的；  </p></blockquote><p>世界观确实是在不断的更新中的，<strong>世界那么大，我想去看看</strong>本质上的追求是去丰富自己的世界观的，而不是仅仅看看风景，发发朋友圈而已。去一个地方应该在欣赏美景的同时去了解风土人情，通过比较差异来完善自己的认知，使得自己更为的丰富。</p><h3 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h3><blockquote><p> 用以区分好与坏的标准，是根据个人内心的尺度进行衡量和评价的，这些标准都可以称为价值观。  </p></blockquote><p>我们日常会听到<strong>某某的价值观出了问题</strong>，其实呢我们是在说某人对于问题的评判或者是做的某些行为严重的偏离了我们正常的认知；那么具体什么是正确的价值观呢？这个问题需要我们自己不断的去探寻、去学习。有些价值观是父母师长等人群灌输的；例如孝敬长者，尊师重道等基本的道德要求；真善美与假恶丑是需要自己去分辨的。特别是目前我们处于互联网时代，言论自由，你对于每一个事件的看法都是你价值观的体现；平时和朋友相处也是，交谈中你的价值观就被反应出来了，价值观一致的人才适合一起玩耍的！</p><h3 id="婚姻观"><a href="#婚姻观" class="headerlink" title="婚姻观"></a>婚姻观</h3><blockquote><p>对婚姻和家庭的看法和态度。</p></blockquote><p>我个人一直遵守家庭第一，其他第二的原则；把家庭照顾好了的前提下再向<em>大家</em>奉献，我觉得才是理想的状态。因为每个人的人生观不同所以也就没有评判对与错的必要；</p><h4 id="幸福婚姻应该包含哪些要素"><a href="#幸福婚姻应该包含哪些要素" class="headerlink" title="幸福婚姻应该包含哪些要素"></a>幸福婚姻应该包含哪些要素</h4><ul><li>童心</li><li>浪漫</li><li>幽默</li><li>亲昵</li><li>情话</li><li>沟通</li><li>欣赏</li></ul><p>日常我们经常听到<strong>三观尽毁</strong>和<strong>三观正才能一起玩耍</strong>；一直以来都没有好好的思考自己的<strong>三观</strong>到底是什么？其实我的日常生活中存在很多这样的习以为常的问题都被自己忽略了，真的很不应该，问题是应该被解决的，时间不会将它带走！追求简单生活，不要要逃避问题，而是要解决复杂的问题，这样生活才会简单！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;人生观&quot;&gt;&lt;a href=&quot;#人生观&quot; class=&quot;headerlink&quot; title=&quot;人生观&quot;&gt;&lt;/a&gt;人生观&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对于人生的根本态度与看法  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   人生千姿百态，每个人都是一个演员在无剧本的人生舞台上做着自己的表演。有句话说&lt;strong&gt;意识决定形态&lt;/strong&gt;，我个人浅显的理解就是你自己的意愿想通过哪种姿态展现自己， 那么在世人面前你就是以哪种姿态呈现。&lt;br&gt;有时候我们会感慨某某活成了我们自己想要的模样，其实本质上我们都有活成某种模样的意识但最终为什么差别很大？主要原因是缺乏行动，多数人都具有正确的人生观：积极生活、努力奋斗、追求幸福等；但又有多少勤勤恳恳的去实践自己的人生观呢？经常会听到说这人的做事态度不错，但请不要忘记最终衡量你的还是做事的结果。获取正确的人生观容易，困难的是通过正确的人生观来让生活极大丰富才是最困难的事情！&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随感" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构之单链表</title>
    <link href="http://yoursite.com/2017/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/01/05/数据结构之单链表/</id>
    <published>2017-01-05T12:44:54.000Z</published>
    <updated>2019-01-13T02:49:26.762Z</updated>
    
    <content type="html"><![CDATA[<p>线性表的顺序存储结构在查找指定位置的元素时操作较快，但是在插入和删除操作的时候需要移动大量数据的位置，操作较为耗时，造成这种结果的原因在于顺序存储是开辟一块连续的内存空间，各个数据之间紧紧相邻；那么解决顺序存储插入和删除问题就需要采取另外一种存储结构–链式存储；</p><a id="more"></a>  <h4 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h4><p>在顺序存储结构中数据元素只要存储数据元素信息就可以了，而链式存储结构还需要存储下一个结点的内存地址，即每个数据元素成为一个独立的结点，结点包含数据信息和地址信息两个部分；n个这样的结点就构成了链表，  </p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p> 因为结点中只存在一个地址指针，即该链表又称之为单链表   </p><h4 id="头结点"><a href="#头结点" class="headerlink" title="头结点"></a>头结点</h4><p>排在单链表的第一个结点前的结点叫头结点  </p><h4 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a>头指针</h4><p>链表第一个结点的存储位置即为头指针/ 头结点中存放的指针即为头指针  </p><h4 id="单链表的链式存储结构"><a href="#单链表的链式存储结构" class="headerlink" title="单链表的链式存储结构"></a>单链表的链式存储结构</h4><pre><code>typedef int ElemType;typedef struct Node{    ElemType data;    struct Node * next;}Node;typedef struct Node* LinkList;  </code></pre><p> 一个结点的构成包含数据域和指针区域；  </p><h4 id="单链表的初始化"><a href="#单链表的初始化" class="headerlink" title="单链表的初始化"></a>单链表的初始化</h4><pre><code>LinkList linkListInit(){Node* L ;L = (Node*)malloc(sizeof(Node));if (L == NULL) {    printf(&quot;申请内存空间失败\n&quot;);}L -&gt;next = NULL;return L;}     </code></pre><h4 id="创建单链表之头插入方法"><a href="#创建单链表之头插入方法" class="headerlink" title="创建单链表之头插入方法"></a>创建单链表之头插入方法</h4><pre><code>LinkList linkListCreateHeaderMethod(int numberOfNode){Node* L ;L = (Node*)malloc(sizeof(Node));if (L==NULL) {    return NULL;}L-&gt;next = NULL;for (int i =0; i&lt;numberOfNode; i++) {    Node *p;    p =(Node*) malloc(sizeof(Node));    p -&gt; data = i ;    p-&gt;next = L-&gt;next;   //将结点插入到表头L--&gt;|3|--&gt;|2|--&gt;|1|--&gt;NULL    L -&gt; next = p;}return L;}  </code></pre><p> 头插入法创建单链表是在头指针和第一个结点之间完成插入操作，新节点的指针存放的是上一个作为第一个结点的地址即L-&gt;next；然后再讲L-&gt;next指向新节点p即可；  </p><h4 id="创建单链表之尾插入方法"><a href="#创建单链表之尾插入方法" class="headerlink" title="创建单链表之尾插入方法"></a>创建单链表之尾插入方法</h4><pre><code>LinkList linkListCreateTailMethod(int numberOfNode){Node* L ;L = (Node*)malloc(sizeof(Node));if (L==NULL) {    return NULL;}L -&gt; next = NULL;Node* tempL = L;for (int i = 0; i&lt;numberOfNode; i++) {    Node* p ;    p = (Node*)malloc(sizeof(Node));    p -&gt;data = i ;    tempL -&gt; next = p ;    tempL = p ;}tempL -&gt;next = NULL;return L;} </code></pre><p> 尾插入就是将新建立的结点放在链表的最后；  </p><h4 id="单链表的插入操作"><a href="#单链表的插入操作" class="headerlink" title="单链表的插入操作"></a>单链表的插入操作</h4><pre><code>int linkListInsert(LinkList list ,int index,int e){    Node* pre ;    pre = list;    for (int i = 1; i&lt;index; i++) {        pre = pre -&gt;next;    }    if (pre) {        Node* newNode;        newNode  = (Node*)malloc(sizeof(Node));        newNode-&gt;data = e ;        newNode-&gt;next = pre-&gt;next;        pre-&gt;next = newNode;        return 1;    }    return 0;} </code></pre><h4 id="单链表的删除操作"><a href="#单链表的删除操作" class="headerlink" title="单链表的删除操作"></a>单链表的删除操作</h4><pre><code>int linkListDeleteNode(LinkList list ,int e){    Node *p,*pre = NULL;                   //pre为前驱结点，p为查找的结点。    p = list-&gt;next;    while(p-&gt;data != e)              //查找值为x的元素    {        pre = p;        p = p-&gt;next;    }    pre-&gt;next = p-&gt;next;          //删除操作，将其前驱next指向其后继。    free(p);    return 1;}  </code></pre><h4 id="单链表返回指定位置的结点数据"><a href="#单链表返回指定位置的结点数据" class="headerlink" title="单链表返回指定位置的结点数据"></a>单链表返回指定位置的结点数据</h4><pre><code>int GetElem(LinkList list,int index,ElemType *e){    int i=1;    LinkList p ;    p = list -&gt;next; // 默认链表名作为第一个结点的指针    while (i&lt;index&amp;&amp;p) {        p = p -&gt;next;        i++;    }    if (!p||i&gt;index) {       return 0;    }else{        *e = p-&gt;data;        return 1;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表的顺序存储结构在查找指定位置的元素时操作较快，但是在插入和删除操作的时候需要移动大量数据的位置，操作较为耗时，造成这种结果的原因在于顺序存储是开辟一块连续的内存空间，各个数据之间紧紧相邻；那么解决顺序存储插入和删除问题就需要采取另外一种存储结构–链式存储；&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构之线性表的顺序存储</title>
    <link href="http://yoursite.com/2017/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2017/01/04/数据结构之线性表的顺序存储/</id>
    <published>2017-01-04T12:57:54.000Z</published>
    <updated>2019-01-13T02:49:01.586Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><blockquote><p>零个或多个数据元素的有限序列；可以理解为数据按照顺序依次排列，除了头结点和尾结点外其他结点只存在唯一的前继和后继； 例如：平时购票的队伍、从北京到上海的京沪线等；</p></blockquote><h4 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h4><pre><code>#define MAXSIEZ 20typedef int ElemType;typedef struct {    ElemType data[MAXSIEZ];    int length;}SqList;</code></pre><p>线性表的顺序存储结构包含两部分，一个是存储数据的数组，一个实际存储数据元素个数的整型变量；其中MAXSIEZ是该线性表指定的最大存储容量！<br><a id="more"></a></p><h4 id="在线性表中获取指定位置的元素"><a href="#在线性表中获取指定位置的元素" class="headerlink" title="在线性表中获取指定位置的元素"></a>在线性表中获取指定位置的元素</h4><pre><code>int getElem(SqList list,int index,ElemType* e){if (list.length==0 || index&lt;1 ||index&gt;list.length) {    return 0;}else{    *e = list.data[index];    return 1;}}</code></pre><p>在线性表中获取指定位置的元素，其操作实质是在SqList的data数组中返回指定索引的值；操作中应该避免数组操作引发越界的操作；数组的下标是从0开始的，而线性表的顺序存储是从1开始</p><h4 id="在线性表中指定位置插入数据"><a href="#在线性表中指定位置插入数据" class="headerlink" title="在线性表中指定位置插入数据"></a>在线性表中指定位置插入数据</h4><pre><code> int listInsert(SqList *list,int index,ElemType e){if (index&gt;list-&gt;length+1||index&lt;1) {    return 0;}else{    if (index == list-&gt;length+1) {        list-&gt;data[index-1] = e;        return 1;    }else{        int lastIndex = list-&gt;length;        for (int i = lastIndex; i&gt;=index; i--) {            list-&gt;data[i] = list-&gt;data[i-1];        }        list-&gt;data[index-1] = e ;        list-&gt;length++; //元素插入完毕后增加list的长度        return 1;    }}}   </code></pre><p>  插入操作就是将存储在指定位置后面的所有元素依次向后移动一位；然后指定位置的数据更新为传入的参数，最后将线性表的长度+1；  </p><h4 id="在线性表中指定位置删除数据"><a href="#在线性表中指定位置删除数据" class="headerlink" title="在线性表中指定位置删除数据"></a>在线性表中指定位置删除数据</h4><pre><code> int  listDelete(SqList *list,int index,ElemType* e){if (list-&gt;length==0||index&lt;1||index&gt;list-&gt;length) {    return 0;}*e = list-&gt;data[index-1];for (int i = index; i&lt;list-&gt;length; i++) {    list-&gt;data[i-1] = list-&gt;data[i];}list-&gt;length--;return 1;}</code></pre><p> 在线性表中指定位置删除数据就是将存储在指定位置后面的所有元素依次向前移动一位，最后将线性表的长度+1；    </p><h4 id="SqList-list-与-SqList-list"><a href="#SqList-list-与-SqList-list" class="headerlink" title="SqList *list 与 SqList list"></a>SqList *list 与 SqList list</h4><ul><li>SqList *list 表示声明一个SqList类型的指针，该指针目前未指向任何内存区域，所以是一个野指针；</li><li>SqList list 表示声明了一个SqList类型的变量，在内存中已经开辟了相应的空间；  </li><li>为什么查找操作的时候传入的是list变量而删除和插入传入的是list指针，主要原因首先是结构体是值类型，查找操作传入list变量，在查找函数中存放的其实是list的一个值拷贝；插入和删除操作则要对传入的list做变更操作，所以要传入list指针；  </li></ul><p>关于值类型和引用类型的区分可以考虑 swap(int a,int b);和 swap(int* a,int* b);的区别</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;零个或多个数据元素的有限序列；可以理解为数据按照顺序依次排列，除了头结点和尾结点外其他结点只存在唯一的前继和后继； 例如：平时购票的队伍、从北京到上海的京沪线等；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;线性表的顺序存储结构&quot;&gt;&lt;a href=&quot;#线性表的顺序存储结构&quot; class=&quot;headerlink&quot; title=&quot;线性表的顺序存储结构&quot;&gt;&lt;/a&gt;线性表的顺序存储结构&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;#define MAXSIEZ 20
typedef int ElemType;
typedef struct {
    ElemType data[MAXSIEZ];
    int length;
}SqList;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;线性表的顺序存储结构包含两部分，一个是存储数据的数组，一个实际存储数据元素个数的整型变量；其中MAXSIEZ是该线性表指定的最大存储容量！&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
