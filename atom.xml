<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>華</title>
  
  <subtitle>人无远虑必有近忧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-13T02:37:47.408Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>华子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue-loader+webpack项目工程配置笔记</title>
    <link href="http://yoursite.com/2018/11/25/vue-loader-webpack%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/11/25/vue-loader-webpack项目工程配置/</id>
    <published>2018-11-25T12:11:36.000Z</published>
    <updated>2019-01-13T02:37:47.408Z</updated>
    
    <content type="html"><![CDATA[<p>由于近期被分配一个vue.js开发的业务模块，需要对此业务模块进行技术支持（bug修复和新需求的迭代）。经过了一周已完成业务熟悉和打包投产的工作，故梳理以下内容加强理解： </p><ul><li>相关名词概念</li><li>vue-loader+webpack项目配置</li><li>webpack配置项目加载各种静态资源以及CSS</li><li>webpack-dev-server的配置和使用  </li></ul><p>在接触web开发的过程中经常会听到以下的名词： </p><ul><li><code>Node.js</code> </li><li><code>NPM</code> </li><li><code>Vue.js</code></li><li><code>webpack</code><br>那么这些名词是什么，做什么用的呢？<a id="more"></a> </li></ul><h3 id="名词概念简介"><a href="#名词概念简介" class="headerlink" title="名词概念简介"></a>名词概念简介</h3><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><blockquote><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。  </p></blockquote><p><code>Node.js</code>使得JavaScript能够像PHP、Python等语言一样进行服务端开发。 </p><h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><blockquote><p>NPM的全称是Node Package Manager，是一个Node.js包管理和分发工具,有了NPM，可以很快的找到特定服务要使用的包，进行下载、安装以及管理已经安装的包  </p></blockquote><h5 id="npm的一些命令"><a href="#npm的一些命令" class="headerlink" title="npm的一些命令"></a>npm的一些命令</h5><ul><li><code>npm install &lt;packageName&gt;</code> :<code>npm install</code>首先会检查<code>node_modules</code>目录中是否存在要安装的模块，如果有就不在安装，及时远程仓库中存在新的版本，也不执行重新安装操作；</li><li><code>npm update &lt;packageName&gt;</code>:先到远程仓库查询，如果本地不存在或者远程仓库版本较新，则执行安装操作。</li><li><code>registry</code>：<code>npm</code>模块仓库提供了一个查询服务，叫做registry，执行<code>npm update react</code>实际是执行<code>https://registry.npmjs.org/react</code></li><li>模块的安装过程：发出<code>npm install</code>命令  –&gt;  <code>npm</code>向<code>registry</code>查询模块压缩包的网址 –&gt; 下载压缩包，存放在~/.npm目录下 –&gt; 解压压缩包到当前项目的node_modules目录</li></ul><h4 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h4><blockquote><p>Vue.js（读音 /vjuː/, 类似于 view）是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p></blockquote><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><blockquote><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle  </p></blockquote><p>通过以上对以上名词的大致了解，那么就开始一步步构建一个简单的web项目  </p><h3 id="webpack打包web工程"><a href="#webpack打包web工程" class="headerlink" title="webpack打包web工程"></a>webpack打包web工程</h3><h4 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h4><p>创建一个<code>web-project</code>的文件夹，命令行切换到<code>web-project</code>下，执行<code>npm init</code>,根据提示填写；<code>web-project</code>下会多出一个package.json的文件包含项目基本信息：  </p><pre><code>{     &quot;name&quot;: &quot;webproject&quot;,     &quot;version&quot;: &quot;1.0.0&quot;,     &quot;description&quot;: &quot;test create web project&quot;,     &quot;main&quot;: &quot;index.js&quot;,     &quot;scripts&quot;: {       &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;     },     &quot;author&quot;: &quot;hua&quot;,     &quot;license&quot;: &quot;ISC&quot;   }   </code></pre><h4 id="安装项目需要的组件"><a href="#安装项目需要的组件" class="headerlink" title="安装项目需要的组件"></a>安装项目需要的组件</h4><ul><li><code>npm install vue vue-loader webpack</code></li><li><code>npm install css-loader</code></li></ul><h4 id="构建一个vue页面"><a href="#构建一个vue页面" class="headerlink" title="构建一个vue页面"></a>构建一个vue页面</h4><p>在<code>web-project</code>下创建<code>src</code>目录，然后再<code>src</code>目录下创建<code>App.vue</code>文件，代码如下 ：  </p><pre><code>&lt;template&gt;     &lt;div id=&quot;text&quot;&gt;{{text}}&lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;        export default{            data(){                return{                    text:&apos;hello vue&apos;                }            }        }    &lt;/script&gt;    &lt;style&gt;    #text{        color: red    }    &lt;/style&gt;</code></pre><h4 id="创建项目的入口文件index-js"><a href="#创建项目的入口文件index-js" class="headerlink" title="创建项目的入口文件index.js"></a>创建项目的入口文件index.js</h4><p>在<code>web-project/src</code>下创建<code>index.js</code>文件，内容如下：  </p><pre><code>import Vue from &apos;vue&apos;import App from &apos;./app.vue&apos;const root = document.createElement(&apos;div&apos;)document.body.appendChild(root)new Vue({    render:(h) =&gt; h(App)}).$mount(root)</code></pre><h4 id="创建webpack的配置文件"><a href="#创建webpack的配置文件" class="headerlink" title="创建webpack的配置文件"></a>创建webpack的配置文件</h4><p>在<code>web-project</code>下创建<code>webpack.config.js</code>文件，内容如下：  </p><pre><code>  const path = require(&apos;path&apos;)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);const config = {    // 设置入口    entry:path.join(__dirname,&apos;src/index.js&apos;),    output:{        filename:&apos;bundle.js&apos;,//打包后js的名称        path:path.join(__dirname,&apos;dist&apos;)// 打包后文件存放的目录    },    plugins:[        new VueLoaderPlugin(),    ],    mode:&apos;development&apos;,    module:{        rules:[            {                test:/\.vue$/,//包含vue的文件使用vue-loader处理                loader:&apos;vue-loader&apos;            },            {                test:/\.css$/,                loader:&apos;css-loader&apos;            }        ]    }}module.exports = config</code></pre><h4 id="在package-json中添加配置"><a href="#在package-json中添加配置" class="headerlink" title="在package.json中添加配置"></a>在package.json中添加配置</h4><p>在<code>scripts</code>结点下添加<code>&quot;build&quot;: &quot;webpack --config webpack.config.js&quot;</code>  </p><h4 id="使用webpack打包工程"><a href="#使用webpack打包工程" class="headerlink" title="使用webpack打包工程"></a>使用webpack打包工程</h4><p>执行<code>npm run build</code>，在项目<code>web-project</code>目录下产生一个<code>dist</code>的文件夹，并且目录下有个<code>bundle.js</code>的文件，至此项目打包已经结束</p><h3 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h3><p>在日常的工作中webpack-dev-server能够使得我们的开发调试更简洁方便，下面让我们来一步步通过配置来使用webpack-dev-server； </p><h4 id="webpack-dev-server安装"><a href="#webpack-dev-server安装" class="headerlink" title="webpack-dev-server安装"></a>webpack-dev-server安装</h4><p>执行<code>npm install webpack-dev-server</code> 我们在打包的使用希望有个html文件承载我们的bundle.js，所以要安装一个html-webpack-plugin，执行<code>npm install html-webpack-plugin</code>   </p><p>在不同的操作系统中，我们希望执行的命令是统一的所以要安装cross-env，执行 <code>npm install cross-env</code> </p><h4 id="修改package-json中的配置"><a href="#修改package-json中的配置" class="headerlink" title="修改package.json中的配置"></a>修改package.json中的配置</h4><p> 在package.json文件中的scripts节点下，修改build节点为<code>cross-env NODE_ENV=production webpack --config webpack.config.js</code>，代表生产环境的命令脚本，新增dev节点，内容为<code>cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js</code>，为开发环境执行脚本。</p><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><pre><code>const path = require(&apos;path&apos;)const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);const isDev = process.env.NODE_ENV === &apos;development&apos;const HTMLPlugin = require(&apos;html-webpack-plugin&apos;)const webpack = require(&apos;webpack&apos;)const config = {    target:&apos;web&apos;,    // 设置入口    entry:path.join(__dirname,&apos;src/index.js&apos;),    output:{        filename:&apos;bundle.js&apos;,//打包后js的名称        path:path.join(__dirname,&apos;dist&apos;)// 打包后文件存放的目录    },    plugins:[        new VueLoaderPlugin(),        new webpack.DefinePlugin({            &apos;process.env&apos;:{                NODE_ENV:isDev ? &apos;&quot;development&quot;&apos;:&apos;&quot;production&quot;&apos;            }        }),        new HTMLPlugin()    ],    mode:&apos;development&apos;,    module:{        rules:[            {                test:/\.vue$/,//包含vue的文件使用vue-loader处理                loader:&apos;vue-loader&apos;            },            {                test:/\.css$/,                loader:&apos;css-loader&apos;            }        ]    }}if(isDev){   config.devServer={       port:8008,       host:&apos;0.0.0.0&apos;,       overlay:{           errors:true       },       hot:true   }   config.plugins.push(       new webpack.HotModuleReplacementPlugin(),       new webpack.NoEmitOnErrorsPlugin()   )}module.exports = config</code></pre><h3 id="页面显示"><a href="#页面显示" class="headerlink" title="页面显示"></a>页面显示</h3><p>此时在浏览器中输入<code>http://0.0.0.0:8008/</code>即可访问项目页面。  </p><blockquote><p>内容参照  </p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="external">阮一峰-npm 模块安装机制简介</a><br><a href="https://www.imooc.com/learn/935" target="_blank" rel="external">慕课网-Vue+Webpack打造todo应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于近期被分配一个vue.js开发的业务模块，需要对此业务模块进行技术支持（bug修复和新需求的迭代）。经过了一周已完成业务熟悉和打包投产的工作，故梳理以下内容加强理解： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相关名词概念&lt;/li&gt;
&lt;li&gt;vue-loader+webpack项目配置&lt;/li&gt;
&lt;li&gt;webpack配置项目加载各种静态资源以及CSS&lt;/li&gt;
&lt;li&gt;webpack-dev-server的配置和使用  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在接触web开发的过程中经常会听到以下的名词： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Node.js&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;NPM&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vue.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webpack&lt;/code&gt;&lt;br&gt;那么这些名词是什么，做什么用的呢？
    
    </summary>
    
      <category term="Vue.js" scheme="http://yoursite.com/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-《程序是怎么跑起来的》-part1</title>
    <link href="http://yoursite.com/2018/10/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B-part1/"/>
    <id>http://yoursite.com/2018/10/28/读书笔记-《程序是怎么跑起来的》-part1/</id>
    <published>2018-10-28T03:03:08.000Z</published>
    <updated>2019-01-13T03:10:51.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对于程序员来说CPU是什么"><a href="#对于程序员来说CPU是什么" class="headerlink" title="对于程序员来说CPU是什么"></a>对于程序员来说CPU是什么</h2><p>在日常使用高级编程语言进行编程时，是否考虑过以下问题：   </p><ul><li>程序是什么</li><li>程序的组成部分</li><li>什么是机器语言</li><li>运行的程序在计算机中的存储位置</li><li>内存地址是什么</li><li>负责程序解析和运行的是哪个</li></ul><a id="more"></a>  <p>如果以上的概念不能很清楚的描述出来，那么就需要了解一下对程序员来讲CPU是什么了。<br>对于CPU的解析首先需要知道程序的运行流程：使用一些高级语言<code>C</code>、<code>JAVA</code>、<code>Objective-C</code>等编写的程序 —-&gt; 编译器会将源码编译为机器语言的可执行文件 —-&gt; 程序运行后会将可执行文件加载到内存中形成副本 —-&gt; CPU解释并执行程序内容 【转化成的机器语言其实是由CPU中的寄存器来处理的】；例如 a = 1 + 2 这样的运算，转化为机器语言后是通过寄存器进行相加运算和存储的。  </p><h4 id="CPU的组成部分"><a href="#CPU的组成部分" class="headerlink" title="CPU的组成部分"></a>CPU的组成部分</h4><p>CPU是中央处理器，负责计算机的控制和运算，它主要包含以下4个部分： </p><ul><li>寄存器：暂时存储指令、数据处理对象【一个CPU会包含20~100个寄存器】</li><li>控制器：把内存上的指令、数据读入寄存器，并根据指令的执行结果来控制计算机【控制器的控制内容：控制键盘、鼠标和内存媒介的输入输出】</li><li>运算器：负责把从内存读到寄存器中的指令和数据进行运算</li><li>时钟： 负责发出CPU开始计时的时钟信号</li></ul><h4 id="程序运行机制中CPU的各部分都起到了哪些作用"><a href="#程序运行机制中CPU的各部分都起到了哪些作用" class="headerlink" title="程序运行机制中CPU的各部分都起到了哪些作用"></a>程序运行机制中CPU的各部分都起到了哪些作用</h4><p>程序启动 —&gt; 根据时钟信号 —&gt; 控制器从内存中读取指令和数据【对指令进行解释和执行】—&gt; 运算器对指令进行运算 —&gt; 控制器根据运算结果控制计算器 </p><h4 id="寄存器简介"><a href="#寄存器简介" class="headerlink" title="寄存器简介"></a>寄存器简介</h4><p>寄存器用来存储指令、数据处理对象，按照使用功能的不同大致分为8类：  </p><ul><li>累加寄存器：负责存储运算数据和运算的结果数据</li><li>基址寄存器：存储数据内存的起始地址</li><li>标志寄存器： 存储运算处理后的CPU的状态</li><li>指令寄存器 ：存储指令</li><li>栈寄存器  ： 存储栈区域的起始地址</li><li>通用寄存器 ： 存储任意数据</li><li>变址寄存器 ： 存储基地址寄存器的相对地址</li><li>程序计数器：存储下一条指令所在的内存地址</li></ul><h4 id="决定程序流程-–-程序计数器"><a href="#决定程序流程-–-程序计数器" class="headerlink" title="决定程序流程 – 程序计数器"></a>决定程序流程 – 程序计数器</h4><p>程序计数器中存储的是程序的执行指令，CPU的控制器会参照程序计数器中存储的内存地址，去查找相应的指令去执行</p><h4 id="条件分支和循环机制"><a href="#条件分支和循环机制" class="headerlink" title="条件分支和循环机制"></a>条件分支和循环机制</h4><p>CPU进行运算时，标志寄存器的数值会根据运算结果自动设定，条件分支在跳转指令前会进行比较运算  </p><h4 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h4><p>如何解决函数内部执行完毕后，CPU继续执行函数入口地址下一个程序计数器中存储的指令：使用机器语言的call指令和return指令可以解决：  </p><ul><li>call指令：会把调用函数后要执行的指令地址存在栈中，函数执行完毕后再函数的出口执行return指令；  </li><li>return指令：把保存在栈中指令设置到程序计数器中   </li></ul><h4 id="机器语言指令的主要类型和功能"><a href="#机器语言指令的主要类型和功能" class="headerlink" title="机器语言指令的主要类型和功能"></a>机器语言指令的主要类型和功能</h4><ul><li>数据传送指令：寄存器和内存、内存和内存、寄存器和外围设备之间的数据读写操作</li><li>运算指令 ： 累加寄存器执行算数运算、逻辑运算、比较运算和位移运算</li><li>跳转指令： 实现条件分支、循环、强制跳转等</li><li>call/return指令 ： 函数的调用/返回调用前的地址</li></ul><h4 id="对文章开头问题进行解答"><a href="#对文章开头问题进行解答" class="headerlink" title="对文章开头问题进行解答"></a>对文章开头问题进行解答</h4><ul><li>程序是什么 ：指导计算机执行操作的一组指令集</li><li>程序的组成部分 ： 指令和数据</li><li>什么是机器语言 ： CPU能够理解和执行的语言</li><li>运行的程序在计算机中的存储位置 ：内存</li><li>内存地址是什么 ： 代表数据和指令在内存中位置的整数值</li><li>负责程序解析和运行的是哪个 ： CPU  </li></ul><blockquote><p>资料来源  </p></blockquote><p> <strong>程序是怎么跑起来的–《对程序员来说CPU是什么》</strong>   </p><h2 id="数据是用二进制数表示的"><a href="#数据是用二进制数表示的" class="headerlink" title="数据是用二进制数表示的"></a>数据是用二进制数表示的</h2><p> 在计算机内部数据和信息是使用二进制来存储的，那么二进制是如何表示信息以及它的运算机制是怎么样的呢？如下有几个问题可以思考一下？  </p><ul><li>32位是几个字节</li><li>二进制01011100转化为十进制是多少</li><li>二进制数00001111左移两位，会变成原来的几倍</li><li>补码形式表示的8位二进制数11111111，用十进制表示的话是多少</li><li>补码形式表示的8位二进制数10101010，用16位的二进制表示的话是多少</li><li>反转部分图形模式，使用的是什么逻辑  </li></ul><p>以上问题如果不能清晰的回答那么就需要了解一下二进制的基础知识了。<br><!--more--></p><h4 id="二进制表示计算机信息的原因"><a href="#二进制表示计算机信息的原因" class="headerlink" title="二进制表示计算机信息的原因"></a>二进制表示计算机信息的原因</h4><p>二进制<strong>是计算机技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”</strong><br>由于计算机内部是由<em>集成电路（integrated circuit)</em>这种电子部件构成，IC只有两种状态，0V和5V，即有电流和无电流两种模式； 计算机处理信息最小的单元是位，二进制的位数一般是8位、16位、32位、也就是8的倍数，8位二进制数被称为一个字节， 内存和磁盘都是以字节单位来存储和读写数据的，因此字节是信息的基本单位。  </p><h4 id="二进制如何同十进制之间进行转化"><a href="#二进制如何同十进制之间进行转化" class="headerlink" title="二进制如何同十进制之间进行转化"></a>二进制如何同十进制之间进行转化</h4><p>先要了解一下位权的概念，首先了解十进制的位权，例如39十位上3的位权是10，个位9的位权是1，那么39的表示就是3x10+9x1 = 39；同样的二进制也是，例如101从右侧向左 1x2^0 + 0x2^1 + 1x2^1。这样二进制转化为十进制，只需要各个数位上的数字与位权相乘然后相加即可。<br>十进制转化为二进制，根据逢<code>二进一</code>的原则，利用短除法求余数的方式可以转化。 </p><h4 id="移位运算和乘除运算的关系"><a href="#移位运算和乘除运算的关系" class="headerlink" title="移位运算和乘除运算的关系"></a>移位运算和乘除运算的关系</h4><p>移位运算指的是将二进制数的各个数位进行左移或右移的操作。其中左移运算符<code>&lt;&lt;</code>,右移的运算符<code>&gt;&gt;</code>,移位运算代替乘除法，十进制左移会变成原来10倍、100倍、1000倍…同样在不考虑符号位的情况下二进制左移后会变成原来的2倍、4倍、8倍，相反右侧移动会变成1/2、1/4、1/8…</p><h4 id="便于计算机处理的补数-补码"><a href="#便于计算机处理的补数-补码" class="headerlink" title="便于计算机处理的补数(补码)"></a>便于计算机处理的补数(补码)</h4><p>二进制表示负数时会把最高位作为符号位来使用，因此最高位也被称为符号位，符号位为0表示正数，符号位为1表示负数；计算机中进行减法操作其实也是按照加法操作进行的；那么如何使用8位二进制来表示-1呢：  </p><pre><code>如何用二进制表示负数-1第一步： 取1的8位二进制表示 ： 00000001第二步：按位取反：   11111110第三步：执行+1操作： 11111111得到的11111111就是-1的8位二进制</code></pre><h4 id="逻辑右移和算术右移的区别"><a href="#逻辑右移和算术右移的区别" class="headerlink" title="逻辑右移和算术右移的区别"></a>逻辑右移和算术右移的区别</h4><p>关于逻辑右移：右移后左侧空位用0填充，而算术右移动：空出来的高位用符号位上的数字填充，下面看一下-4右移2位得到-1；</p><pre><code>-4 ：11111100  先右移2位得到111111，高位使用符号位数字填充11，就得到了-1 ：11111111</code></pre><p>关于符号扩充：保持值不变的情况下，将8位二进制准话为16位或是32位，不管正数还是负数都使用符号位上的数字去扩充高位即可。</p><h4 id="掌握逻辑运算的窍门"><a href="#掌握逻辑运算的窍门" class="headerlink" title="掌握逻辑运算的窍门"></a>掌握逻辑运算的窍门</h4><p>逻辑运算包含如下几种：  </p><ul><li>逻辑非 NOT ： 0变成1，1变成0</li><li>逻辑与  AND：两个都为1才是1，否则为0</li><li>逻辑或  OR ： 至少有一方为1，结果为1，其他为0 </li><li>逻辑异或 XOR： 排斥相同数值的运算，相同为0，不同为1  </li></ul><h4 id="对为文章开头问题的解答"><a href="#对为文章开头问题的解答" class="headerlink" title="对为文章开头问题的解答"></a>对为文章开头问题的解答</h4><ul><li>32位是几个字节 ：8个</li><li>二进制01011100转化为十进制是多少 ： 92</li><li>二进制数00001111左移两位，会变成原来的几倍 ： 4倍</li><li>补码形式表示的8位二进制数11111111，用十进制表示的话是多少 ： -1</li><li>补码形式表示的8位二进制数10101010，用16位的二进制表示的话是多少 ： 1111111110101010</li><li>反转部分图形模式，使用的是什么逻辑  ：XOR（异或）  </li></ul><blockquote><p>资料来源  </p></blockquote><p> <strong>程序是怎么跑起来的–《数据是用二进制表示的》</strong></p><h2 id="计算机进行小数运算"><a href="#计算机进行小数运算" class="headerlink" title="计算机进行小数运算"></a>计算机进行小数运算</h2><p>关于计算机进行小数运算可以先了解以下问题：  </p><ul><li>二进制数0.1，用十进制数表示的话是多少?</li><li>用小数点后有3位的二进制数，能表示十进制数0.625吗？</li><li>将小数分为符号、尾数、基数、指数4部分进行表现的形式称为什么？</li><li>二进制数的基数是什么？</li><li>通过把0作为数值范围的中间值，从而在不使用符号位的情况下来表示负数的表示方法称为什么？</li><li>10101100.01010011这个二进制数，用十六进制数表示的话是多少？  <!--more-->  </li></ul><p>以上问题是不是会有些模糊不清的几个呢，那么就需要了解计算机是如何对小数进行保存和操作的了。首先将1011.0011这个有小数点的二进制数转化成十进制该如何操作，整数部分使用位权和对应位置的数字相乘然后再进行相加操作即可，小数部分同理，只是位权变成了2^(-1)、2^(-2)… </p><pre><code>1011.0011  :二进制      1x2^3+0x2^2+1x2^1+1x2^0+0x2^(-1)+0x2^(-2)+1x2^(-3)+1x2^(-4) = 11.1875 :十进制  </code></pre><h4 id="将0-1累加100得到的结果不是10"><a href="#将0-1累加100得到的结果不是10" class="headerlink" title="将0.1累加100得到的结果不是10"></a>将0.1累加100得到的结果不是10</h4><pre><code>void sum_hundred_float(){    float sum = 0.0;    for (int i=0; i&lt;100; i++) {        sum +=0.1;    }    printf(&quot;%f\n&quot;,sum); //结果为：10.000002}  </code></pre><p>对于以上结果到底问题出现在哪呢？  </p><h4 id="计算机出错的原因"><a href="#计算机出错的原因" class="headerlink" title="计算机出错的原因"></a>计算机出错的原因</h4><p>有一些十进制的小数无法转换成二进制数的正确表示，只能够取近似值，例如十进制数0.1就无法用二进制数来表示；小数点后四位用二进制数表示时的数值范围：0.0000~0.1111，因此这里只能表示0.5、0.25、0.125、0.0625这四个二进制小数点后面的位权组合而成（相加总和）的小数</p><h4 id="什么是浮点数"><a href="#什么是浮点数" class="headerlink" title="什么是浮点数"></a>什么是浮点数</h4><p>浮点数的表示形式：符号+尾数+基数+指数<br>双精度浮点数和单精度浮点数在表示同一个数值时使用的位数不同   </p><h4 id="正则表达式和EXCESS系统"><a href="#正则表达式和EXCESS系统" class="headerlink" title="正则表达式和EXCESS系统"></a>正则表达式和EXCESS系统</h4><p>尾数部分使用正则表达式，可以将表现形式多样的浮点数统一为一种表现形式；例如：十进制的0.75就有很多表现形式，0.75 x 10^0 、0.75 x 10^1,但遵循小数点前是0，小数点后不为0的原则 0.75 x 10^0 是标准的形式；同样二进制中将小数点前面的值固定为1的正则表达式；<br>指数部分使用EXCESS系统，使用这种方式主要是为了表示负数时不使用符号位【待理解】 </p><h4 id="如何避免计算机在处理浮点数时出错"><a href="#如何避免计算机在处理浮点数时出错" class="headerlink" title="如何避免计算机在处理浮点数时出错"></a>如何避免计算机在处理浮点数时出错</h4><ul><li>一些实际运算的误差可以忽略不计 </li><li>将浮点数转化为整数再进行运算，尤其在设计财务方面的处理时，一定要将小数转化为浮点数或者采用BCD(Binary,Coded,Decimal)的方式</li></ul><h4 id="二进制和十六进制"><a href="#二进制和十六进制" class="headerlink" title="二进制和十六进制"></a>二进制和十六进制</h4><p>二进制表示数据时，可能位数太长不利于查看，此时可以采用十六进制表示，二进制的4位正好相当于十六进制的1位， 例如： </p><pre><code>1011.0110 ==》 B.6 小数点后位数不够低位补0即可  </code></pre><h4 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h4><ul><li>二进制数0.1，用十进制数表示的话是多少? ：0.5</li><li>用小数点后有3位的二进制数，能表示十进制数0.625吗？ ： 可以，0.625转化为二进制为:0.101</li><li>将小数分为符号、尾数、基数、指数4部分进行表现的形式称为什么？:浮点数</li><li>二进制数的基数是什么？：2</li><li>通过把0作为数值范围的中间值，从而在不使用符号位的情况下来表示负数的表示方法称为什么？：EXCESS系统表现 </li><li>10101100.01010011这个二进制数，用十六进制数表示的话是多少？：AC.53 （每4位进行一次求值运算）</li></ul><blockquote><p>资料来源  </p></blockquote><p> <strong>程序是怎么跑起来的–《数据是用二进制表示的》</strong>  </p><h2 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h2><p>在编程中熟练使用内存就需要对内存进行详细的了解，看一下如下问题：  </p><ul><li>有十个地址信号引脚的内存IC(集成电路)，可以指定的地址范围是多少？： 0~1023</li><li>高级编程语言中的数据类型表示的是什么？ ：占据内存区域的大小和存储在该内存区域的数据类型</li><li>在32位内存地址的环境中，指针变量的长度是多少位？：32位</li><li>与物理内存有着相同构造的数组的数据类型长度是多少位？：1字节</li><li>用LIFO方式进行数据读写的数据结构成为什么？：栈</li><li>根据数据的大小链表分叉成两个方向的数据结构称为什么？：二叉查找树（从节点分成两个叉的树状数据结构） </li></ul><!--more--> <p> 如果对以上问题存在疑虑，那么就需要对内存进行一下了解了。  </p><h4 id="内存的物理机制"><a href="#内存的物理机制" class="headerlink" title="内存的物理机制"></a>内存的物理机制</h4><p>内存IC中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚，通过为其指定地址，来进行数据的读写。内存中能存储多少数据是由地址信号决定的；数据信号表示一次可以输入输出的数据字节数；控制信号控制内存的读写操作。内存IC内部有大量可以存储8位数据的地方，通过地址指定这些场所，之后即可进行数据的读写。  </p><h4 id="内存的逻辑模型"><a href="#内存的逻辑模型" class="headerlink" title="内存的逻辑模型"></a>内存的逻辑模型</h4><p>内存的逻辑模型类似与房屋一样，每一层都存储着数据，变量的数据类型不同，所占的数据内存大小也不同<br>  char、short、long这些数据类型代表在内存中开辟的空间大小是不一样的； </p><h4 id="简单的指针"><a href="#简单的指针" class="headerlink" title="简单的指针"></a>简单的指针</h4><p> 指针也是一种变量，它所表示的不是数据的值，而是存储着数据的内存地址，通过指针可以对任意地址的数据进行读写；32位的内存地址,指针变量的长度也是32位；char <em>d; short </em>e;long *f;使用数据类型声明指针表示的是从指针存储的地址中一次能够读写的数据字节数  </p><h4 id="数组是高效使用内存的基础"><a href="#数组是高效使用内存的基础" class="headerlink" title="数组是高效使用内存的基础"></a>数组是高效使用内存的基础</h4><p>数组是多个相同数据类型的数据在内存中连续排序的形式，数组和内存的物理构造是一样的  </p><h4 id="栈、队列以及环形缓冲区"><a href="#栈、队列以及环形缓冲区" class="headerlink" title="栈、队列以及环形缓冲区"></a>栈、队列以及环形缓冲区</h4><p>数据的出入顺序，栈：先进后出，栈的原意：干草堆积如山；队列：先进先出；<br>环形缓冲区：数组首位相连形成的存储结构  </p><h4 id="链表和二叉搜索树"><a href="#链表和二叉搜索树" class="headerlink" title="链表和二叉搜索树"></a>链表和二叉搜索树</h4><p> 链表：数组的每一个元素存储两个值：数据+下一个元素的索引<br> 二叉查找树：在链表的基础上往数组中追加元素时，考虑到数据的大小关系，将其分为左右两个方向的表现形式 </p><h3 id="内存和磁盘的关系"><a href="#内存和磁盘的关系" class="headerlink" title="内存和磁盘的关系"></a>内存和磁盘的关系</h3><p>关于内存和磁盘的关系有如下问题： </p><ul><li>存储程序方式指的是什么？：在存储装置中保存程序，并逐一运行的方式</li><li>通过使用内存来提高磁盘访问速度的机制是什么？：磁盘缓存</li><li>把磁盘的一部分作为假想内存来使用的机制称为什么？：虚拟内存</li><li>windows中，在程序运行时，存储着可以动态加载调用的函数和数据的文件称为什么？： DLL（Dynamic Link Library）</li><li>在EXE程序文件中，静态加载函数的方式是什么？：静态链接</li><li>在windows计算机中，一般磁盘的1个扇区是多少字节？：512个字节(扇区是磁盘保存数据的物理单位)  </li></ul><h4 id="程序必须读入到内存中才能执行"><a href="#程序必须读入到内存中才能执行" class="headerlink" title="程序必须读入到内存中才能执行"></a>程序必须读入到内存中才能执行</h4><p>   CPU解析和运行程序是从根据程序计数器从内存中读取，因此磁盘中的程序需要加载到内存中才能被执行 </p><h4 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h4><p>  把从磁盘获取的数据在内存空间中缓存一份，如果再次使用的时候直接从内存空间中获取，加快访问速度；<br>   例如：web浏览器的实现，网络请求回来的数据会缓存到磁盘中，然后再次需要显示数据的时候从磁盘中加载 </p><h4 id="虚拟内存把磁盘当作部分内存来使用"><a href="#虚拟内存把磁盘当作部分内存来使用" class="headerlink" title="虚拟内存把磁盘当作部分内存来使用"></a>虚拟内存把磁盘当作部分内存来使用</h4><p> 磁盘的一部分假想为内存使用，在内存不足时，也可以运行程序【把实际内存和磁盘上的虚拟内存的内容进行部分置换】<br>虚拟内存分为分页式和分段式两种；<br>      分页式：将程序按照页(page)为单位在磁盘的虚拟内存中分割，然后以页为单位与内存进行置换  </p><h4 id="节约内存的编程方法-操作系统内存固定的情况下"><a href="#节约内存的编程方法-操作系统内存固定的情况下" class="headerlink" title="节约内存的编程方法[操作系统内存固定的情况下]"></a>节约内存的编程方法[操作系统内存固定的情况下]</h4><ul><li>通过DLL文件实现函数共有，DLL文件是在程序运行期间可以直接调用的Library(函数和数据的集合)</li><li>通过调用_stdcall来减小程序文件的大小,主要是栈清理操作时能减少占用的内存</li></ul><h4 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h4><p>磁盘是通过将物理表面划分为多个空间来使用的，划分的方式有扇区方式和可变长方式 </p><ul><li>扇区方式：将磁盘划分为固定长度，</li><li>磁道：把磁盘表面分成若干同心圆的空间就是磁道。把磁道按照固定大小划分而成的空间就是扇区，一个扇区是512字节</li><li><p>可变长方式：将磁盘划分为长度可变的空间</p><blockquote><p>资料来源  </p></blockquote><p><strong>程序是怎么跑起来的–《熟练使用有棱有角的内存》和《内存和磁盘的亲密关系》</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对于程序员来说CPU是什么&quot;&gt;&lt;a href=&quot;#对于程序员来说CPU是什么&quot; class=&quot;headerlink&quot; title=&quot;对于程序员来说CPU是什么&quot;&gt;&lt;/a&gt;对于程序员来说CPU是什么&lt;/h2&gt;&lt;p&gt;在日常使用高级编程语言进行编程时，是否考虑过以下问题：   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序是什么&lt;/li&gt;
&lt;li&gt;程序的组成部分&lt;/li&gt;
&lt;li&gt;什么是机器语言&lt;/li&gt;
&lt;li&gt;运行的程序在计算机中的存储位置&lt;/li&gt;
&lt;li&gt;内存地址是什么&lt;/li&gt;
&lt;li&gt;负责程序解析和运行的是哪个&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机基础" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-《软技能》事业篇</title>
    <link href="http://yoursite.com/2018/08/18/%E8%AF%BB%E3%80%8A%E8%BD%AF%E6%8A%80%E8%83%BD%E3%80%8B/"/>
    <id>http://yoursite.com/2018/08/18/读《软技能》/</id>
    <published>2018-08-18T09:37:48.000Z</published>
    <updated>2018-08-18T12:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>  《软技能》一书旨在让开发人员如何成为一名优秀的工程师，它涉及的主要七个方面：  </p><ul><li>事业</li><li>自我营销</li><li>学习</li><li>生产力</li><li>理财</li><li>身体</li><li>精神</li></ul><a id="more"></a>  <h2 id="事业"><a href="#事业" class="headerlink" title="事业"></a>事业</h2><p>   《软技能》中提出<strong>你所犯的最大的错误就是相信自己是在为别人工作。这样一来你对工作的安全感已燃尽。职业的驱动力一定是来自个体本身。</strong>      </p><p>文章中指出多数软件开发者所犯的最大的错误在于没有把软件开发当成一桩生意来看。职业规划应该像管理企业一样制定最优的决策和保证生产力的持续提升。所以应该把你现在的公司当做你的一个客户，然后像企业一样去思考，时刻去想作为一个企业我能提供什么，这样你的工作方式、处理自己财务的方式、需求新工作的方式都会得到改变。</p><h3 id="你的目标是什么"><a href="#你的目标是什么" class="headerlink" title="你的目标是什么"></a>你的目标是什么</h3><p>软件开发工程师要确定自己的目标，初级、中级、高级、资深等，还是走管理路线，你要确定自己的目标；<br>设立目标，这个很关键，为职业生涯设立一个大目标然后去拆分，月目标、周目标，时刻让自己知道在追求什么</p><h3 id="人际交往能力"><a href="#人际交往能力" class="headerlink" title="人际交往能力"></a>人际交往能力</h3><p>软件开发者整体给人的印象就是呆板不容易沟通，<strong>别管我，我只想一个人安静的写代码</strong>这句话同行们都应该说过。实际上软件开发就是与他人打交道的过程，假象你研发的东西没人使用，那他的意义在于什么呢？我们在工作中会与产品、测试、业务、运营等人员沟通，所以沟通是极其重要的。那么如何与人打交道，以下几点很受用：  </p><ul><li>每个人都希望感到自己很重要</li><li>永远不要批评</li><li>换位思考</li><li>避免争吵</li></ul><h3 id="破解面试之道"><a href="#破解面试之道" class="headerlink" title="破解面试之道"></a>破解面试之道</h3><ul><li>个人博客和github对于研发人员很重要，当面试官看过你的博客，那么面试成功率就会很大；   </li><li>突破常规从期待加入公司的员工入手，建立联系，简历走内部推荐模式；</li><li>确保自己仍旧保持技术能力，如果你力所不及，那么所有的面试技巧都不会帮助到你；</li><li>即使不换新工作也要出去面试，获取面试的经验，这样你真正面试的时候就会游刃有余；  </li></ul><h3 id="就业选择"><a href="#就业选择" class="headerlink" title="就业选择"></a>就业选择</h3><p>一个软件开发工程师可以从事哪些工作:   </p><ul><li>雇员 </li><li>独立咨询师</li><li>创业者</li></ul><h3 id="你是哪类开发人员"><a href="#你是哪类开发人员" class="headerlink" title="你是哪类开发人员"></a>你是哪类开发人员</h3><p>我们在选择律师的时候会根据具体的案件去选择，软件开发工程师也是你需要在自己的专业领域做的卓越，开发人员的专业领域包含：   </p><ul><li>Web开发栈</li><li>嵌入式系统</li><li>特定操作系统</li><li>移动开发</li><li>框架</li><li>软件系统</li></ul><h3 id="公司与公司是不一样"><a href="#公司与公司是不一样" class="headerlink" title="公司与公司是不一样"></a>公司与公司是不一样</h3><p>你选择的任职公司会影响你的整体幸福感、存在感和归属感；比较一下不同种类公司的优缺点</p><table><thead><tr><th>公司规模</th><th>优点</th><th>缺点  </th></tr></thead><tbody><tr><td>小公司</td><td>承担多种职责，灵活的角色转换，汇报潜力大</td><td>没法安静的写代码，稳定性差</td></tr><tr><td>中等公司</td><td>工作稳定，加班少</td><td>变化很慢，没有机会使用新技术</td></tr><tr><td>大公司</td><td>完备的流程化，培训机会多，大型有影响力的作用</td><td>充斥官僚作风，可能只负责代码库的一小部分</td></tr></tbody></table><p>在选择公司的时候要权衡利弊，多花时间思考自己喜欢在什么样的环境下工作，多大的规模符合你自己理想的工作环境   </p><h3 id="攀登晋升阶梯"><a href="#攀登晋升阶梯" class="headerlink" title="攀登晋升阶梯"></a>攀登晋升阶梯</h3><ul><li>承担更多的责任</li><li>引人注目  <ul><li>提供演讲和培训</li><li>发表意见</li><li>保证“曝光度”</li></ul></li><li>自学 <ul><li>参加培训</li><li>考取证书</li><li>继续深造 </li></ul></li><li>成为问题的解决者<ul><li>如果你能解决别人不能解决的问题，你就能轻而易举成为最有价值的人</li></ul></li><li>关于政治  <ul><li>保持警惕之心</li><li>脚踏实地</li></ul></li></ul><p>在晋升之路上，自学占有很大比重的，要确定自学的最有价值的东西是什么，然后指定计划去执行；  </p><h3 id="成为专业人士"><a href="#成为专业人士" class="headerlink" title="成为专业人士"></a>成为专业人士</h3><blockquote><p>专业人士严肃对待自己的责任和事业，愿意做出艰难的选择去做自己认为正确的事情–往往还要自己承担代价  </p></blockquote><p>如何成为专业人士：首先你要养成良好的习惯；你是否有自己的时间管理计划呢？第二天的工作内容是什么，你是如何安排的等等。追求品质，完善自我；工作的完成分为很多等级，开发人员应该极力追求质量的控制；想象一下你提交的版本有问题会引发多少连锁的反应，测试工程师，运维工程师等等都会受到牵连，所以交付质量非常重要；<br>成为专业人员是一个持续性的过程，要有很好的耐性。 </p><h3 id="假装自己能成功"><a href="#假装自己能成功" class="headerlink" title="假装自己能成功"></a>假装自己能成功</h3><p>假装自己能成功是一个自我暗示，能让自己增强自信心；我们都会面对困境–接到的任务自己一无所知，会感到不自在，无能为力。消除这种情绪就要“假装自己能成功”；<br>这个技巧同时适用于面试阶段，碰到不会的问题，可以表现自己有信心解决。但一定不能表现为自大。</p><h3 id="请勿陷入技术狂热"><a href="#请勿陷入技术狂热" class="headerlink" title="请勿陷入技术狂热"></a>请勿陷入技术狂热</h3><p>天生一物必有用，php是最好的语言可以当成个调侃，但不要去比对不同语言的孰好孰坏，一定要争论个第一出来，其实完全没有意义。我们应该对技术保持开放的心态，而不是固守自己已经了解的技术。突破于此你就会发现更多的机会向你涌来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  《软技能》一书旨在让开发人员如何成为一名优秀的工程师，它涉及的主要七个方面：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事业&lt;/li&gt;
&lt;li&gt;自我营销&lt;/li&gt;
&lt;li&gt;学习&lt;/li&gt;
&lt;li&gt;生产力&lt;/li&gt;
&lt;li&gt;理财&lt;/li&gt;
&lt;li&gt;身体&lt;/li&gt;
&lt;li&gt;精神&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随感" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C知识点的汇总</title>
    <link href="http://yoursite.com/2018/04/27/Objective-C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/04/27/Objective-C面试知识点汇总/</id>
    <published>2018-04-27T03:37:40.000Z</published>
    <updated>2019-01-13T11:04:36.156Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C相关知识点的汇总如下：</p><ul><li>属性 :   <a href="https://huatj0210.github.io/2017/01/04/Objective-C%E4%B9%8B%E5%B1%9E%E6%80%A7/" target="_blank" rel="external">Objective-C之属性</a></li><li>方法 :   <a href="https://huatj0210.github.io/2017/01/10/Objective-C%E4%B9%8B%E6%96%B9%E6%B3%95/" target="_blank" rel="external">Objective-C之方法</a></li><li>分类 :   <a href="https://huatj0210.github.io/2018/04/21/Objective-C%E4%B9%8B%E5%88%86%E7%B1%BB/" target="_blank" rel="external">Objective-C之分类</a></li><li>关联对象: </li><li>扩展 </li><li>代理</li><li>通知</li><li>KVO:  <a href="https://huatj0210.github.io/2017/02/20/Objective-C%E4%B9%8BKVO/" target="_blank" rel="external">Objective-C之KVO</a></li><li>KVC  <a href="https://huatj0210.github.io/2017/02/27/Objective-C%E4%B9%8BKVC/" target="_blank" rel="external">Objective-C之KVC</a></li><li>属性关键字</li></ul><a id="more"></a> <h3 id="Objective-C知识点思维导图如下："><a href="#Objective-C知识点思维导图如下：" class="headerlink" title="Objective-C知识点思维导图如下："></a>Objective-C知识点思维导图如下：</h3><p><img src="https://raw.githubusercontent.com/huaTJ0210/HZiOS/master/知识模块/2-Objective-C/Objective-C.png" alt="Objective-C知识点思维导图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C相关知识点的汇总如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属性 :   &lt;a href=&quot;https://huatj0210.github.io/2017/01/04/Objective-C%E4%B9%8B%E5%B1%9E%E6%80%A7/&quot;&gt;Objective-C之属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;方法 :   &lt;a href=&quot;https://huatj0210.github.io/2017/01/10/Objective-C%E4%B9%8B%E6%96%B9%E6%B3%95/&quot;&gt;Objective-C之方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分类 :   &lt;a href=&quot;https://huatj0210.github.io/2018/04/21/Objective-C%E4%B9%8B%E5%88%86%E7%B1%BB/&quot;&gt;Objective-C之分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;关联对象: &lt;/li&gt;
&lt;li&gt;扩展 &lt;/li&gt;
&lt;li&gt;代理&lt;/li&gt;
&lt;li&gt;通知&lt;/li&gt;
&lt;li&gt;KVO:  &lt;a href=&quot;https://huatj0210.github.io/2017/02/20/Objective-C%E4%B9%8BKVO/&quot;&gt;Objective-C之KVO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;KVC  &lt;a href=&quot;https://huatj0210.github.io/2017/02/27/Objective-C%E4%B9%8BKVC/&quot;&gt;Objective-C之KVC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;属性关键字&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C之分类</title>
    <link href="http://yoursite.com/2018/04/21/Objective-C%E4%B9%8B%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/04/21/Objective-C之分类/</id>
    <published>2018-04-21T14:30:40.000Z</published>
    <updated>2019-01-13T10:45:59.738Z</updated>
    
    <content type="html"><![CDATA[<p>在实际的开发过程中，经常会遇到给现有的系统类增加新方法的需求。根据面向对象语言的特性可以使用继承来实现，但仅仅为了增加一个方法需要把父类的所有属性以及方法都要继承，这种实现机制就显得过于繁琐了。在<code>Objective-C</code>语言中<code>分类</code>特性可以满足给现有类直接新增方法的需求。<br>具体使用是新建Category文件，这样在新建在Category的文件中就可以添加<strong>方法（实例方法、类方法）</strong>、<strong>协议</strong>、<strong>属性</strong>;其中属性的实现还需要根据关联对象来辅助才能实现；</p><h3 id="分类的用途"><a href="#分类的用途" class="headerlink" title="分类的用途"></a>分类的用途</h3><ul><li>声明私有方法:在当前类的.m文件中声明并实现，对外不进行暴露</li><li>分解体积庞大的类文件</li><li>公开frameWork中的一些私有方法【较少使用】</li><li>为系统类增加方法  <a id="more"></a><h3 id="分类的具体使用"><a href="#分类的具体使用" class="headerlink" title="分类的具体使用"></a>分类的具体使用</h3></li></ul><p>向<code>UIView</code>中新增<code>-(CGFloat)x</code>和<code>-(CGFloat)y</code>方法，并通过关联对象的方式新增属性<code>customeFlag</code>,同时新增了一个<code>UIViewCustomeDelegagte</code>的协议；具体实现如下所示：</p><h4 id="声明部分"><a href="#声明部分" class="headerlink" title="声明部分"></a>声明部分</h4><pre><code>#import &lt;UIKit/UIKit.h&gt;// --- add protocol ---@protocol UIViewCustomeDelegagte &lt;NSObject&gt;-(void)view:(UIView*)view selectedItem:(id)item;@end@interface UIView (HZ)@property(nonatomic,weak)id&lt;UIViewCustomeDelegagte&gt; customeDelegate;// -- add property@property(nonatomic,copy)NSString *customeFlag;// --- add method ----(CGFloat)x;-(CGFloat)y;-(void)testAddProtocol;@end  </code></pre><h4 id="实现部分"><a href="#实现部分" class="headerlink" title="实现部分"></a>实现部分</h4><pre><code>    #import &quot;UIView+HZ.h&quot;    #import &lt;objc/runtime.h&gt;    static const void* K_CUSTOMER_FLAG = @&quot;customeFlag&quot;;    static const void* K_CUSTOMER_DELEGATE= @&quot;customeDelegate&quot;;    @implementation UIView (HZ)    - (id&lt;UIViewCustomeDelegagte&gt;)customeDelegate{         return objc_getAssociatedObject(self, K_CUSTOMER_DELEGATE);    }    - (void)setCustomeDelegate:(id&lt;UIViewCustomeDelegagte&gt;)customeDelegate{        objc_setAssociatedObject(self, K_CUSTOMER_DELEGATE, customeDelegate, OBJC_ASSOCIATION_ASSIGN);    }    -(NSString *)customeFlag{        return objc_getAssociatedObject(self, K_CUSTOMER_FLAG);    }    -(void)setCustomeFlag:(NSString *)customeFlag{        objc_setAssociatedObject(self, K_CUSTOMER_FLAG, customeFlag, OBJC_ASSOCIATION_COPY_NONATOMIC);    }    -(CGFloat)x{        return self.frame.origin.x;    }    -(CGFloat)y{        return self.frame.origin.y;    }    -(void)testAddProtocol{        if ([self.customeDelegate respondsToSelector:@selector(view:selectedItem:)]) {            [self.customeDelegate view:self selectedItem:@&quot;selected item&quot;];        }}</code></pre><h3 id="分类的具体实现原理"><a href="#分类的具体实现原理" class="headerlink" title="分类的具体实现原理"></a>分类的具体实现原理</h3><p>分类的实现原理大致如下:</p><ul><li>创建的类文件经过编译后变成可执行的xx.o文件，系统读取镜像后，执行 remethodizeClass()</li><li>将所有的分类装载到宿主</li><li>将分类中的方法转化为二维数组，【倒序遍历—&gt;最后编译的类放在最前面】</li><li>对宿主类的方法列表进行扩容操作，然后进行内存的移动，将列表的前部位置空出供分类中的方法填充</li><li>注意事项： 出现不同分类中存在相同的方法，编译顺序的不同，导致函数的调用也会不同，最后编译的分类中的方法会被执行</li></ul><h3 id="分类的常见问题"><a href="#分类的常见问题" class="headerlink" title="分类的常见问题"></a>分类的常见问题</h3><ul><li>分类中出现与宿主类同名的方法，会出现什么问题？ ==》宿主中的方法会失效，调用的时候会使用分类的方法，不建议定义相同的名称；</li><li>出现多个分类文件，分类文件中存在相同方法时，调用方法时会出现什么问题？==》最后被编译的分类文件中的方法会生效 ，具体原因查看<code>attachLists</code>的代码实现；</li></ul><p><strong>以下是runtime源码中对于分类具体实现的大致调用顺序</strong>  </p><pre><code>  // 加载所有头文件，并从头文件中获取分类列表void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){   // 重新调整宿主类的结构，包括：添加方法、属性、协议等   remethodizeClass(Class cls) {      // 将分类中的内容添加到宿主类中      attachCategories(Class cls, category_list *cats, bool flush_caches){            // 如何添加的具体实现            attachLists(List* const * addedLists, uint32_t addedCount){             }      }  } } </code></pre><!--more-->      <h3 id="分类实现原理的代码解析"><a href="#分类实现原理的代码解析" class="headerlink" title="分类实现原理的代码解析"></a>分类实现原理的代码解析</h3><h4 id="read-images"><a href="#read-images" class="headerlink" title="_read_images()"></a>_read_images()</h4><p>  <code>_read_images()</code> 方法在获取分类时，第一步：遍历加载的.h文件列表，然后获取分类列表；第二部：将分类列表中的方法转换为一个二维数组<code>[[method1,method2,method3],[method4,method5],[method6]]</code>;第三步将二维数组中的每个元素包含的方法再添加到宿主类的<code>method_list</code>中；<strong>分类中的方法是添加在<code>method_list</code>头部</strong>   </p><pre><code>  void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){/*   Discover categories.   + 遍历所有.h文件，获取分类列表   + 将分类列表中的方法通过倒序遍历得到一个二维数组==&gt;[[method1,method2,method3],[method4,method5],[method6]]; */for (EACH_HEADER) {    category_t **catlist =    _getObjc2CategoryList(hi, &amp;count);    bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();    for (i = 0; i &lt; count; i++) {        category_t *cat = catlist[i];        Class cls = remapClass(cat-&gt;cls);        if (!cls) {            // Category&apos;s target class is missing (probably weak-linked).            // Disavow any knowledge of this category.            catlist[i] = nil;            if (PrintConnecting) {                _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;                             &quot;missing weak-linked target class&quot;,                             cat-&gt;name, cat);            }            continue;        }        /*          将二维数组中的每一个数组中的method添加到原生方法列表中         */        bool classExists = NO;        if (cat-&gt;instanceMethods ||  cat-&gt;protocols            ||  cat-&gt;instanceProperties)        {            addUnattachedCategoryForClass(cat, cls, hi);            if (cls-&gt;isRealized()) {                remethodizeClass(cls);                classExists = YES;            }            if (PrintConnecting) {                _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,                             cls-&gt;nameForLogging(), cat-&gt;name,                             classExists ? &quot;on existing class&quot; : &quot;&quot;);            }        }        if (cat-&gt;classMethods  ||  cat-&gt;protocols            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))        {            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);            if (cls-&gt;ISA()-&gt;isRealized()) {                remethodizeClass(cls-&gt;ISA());            }            if (PrintConnecting) {                _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,                             cls-&gt;nameForLogging(), cat-&gt;name);            }        }    }}ts.log(&quot;IMAGE TIMES: discover categories&quot;);// Category discovery MUST BE LAST to avoid potential races// when other threads call the new category code before}   #undef EACH_HEADER}   </code></pre><h4 id="remethodizeClass-Class-cls"><a href="#remethodizeClass-Class-cls" class="headerlink" title="remethodizeClass(Class cls)"></a>remethodizeClass(Class cls)</h4><p><code>remethodizeClass(Class cls)</code> 重新调整class，利用<code>attachCategories</code>将分类内容添加到宿主类中   </p><pre><code>static void remethodizeClass(Class cls){category_list *cats;bool isMeta;runtimeLock.assertWriting();isMeta = cls-&gt;isMetaClass();// Re-methodizing: check for more categoriesif ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {    if (PrintConnecting) {        _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,                      cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);    }    //     attachCategories(cls, cats, true /*flush caches*/);            free(cats);}}      </code></pre><hr><h4 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a>attachCategories</h4><p><code>attachCategories(Class cls, category_list *cats, bool flush_caches)</code>  将分类中的方法、属性、协议添加到宿主类中       </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123;</div><div class="line">if (!cats) return;</div><div class="line">if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line">bool isMeta = cls-&gt;isMetaClass();</div><div class="line">// fixme rearrange to remove these intermediate allocations</div><div class="line">method_list_t **mlists = (method_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*mlists));</div><div class="line">property_list_t **proplists = (property_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*proplists));</div><div class="line">protocol_list_t **protolists = (protocol_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*protolists));</div><div class="line">// Count backwards through cats to get newest categories first</div><div class="line">int mcount = 0;</div><div class="line">int propcount = 0;</div><div class="line">int protocount = 0;</div><div class="line">int i = cats-&gt;count;</div><div class="line">bool fromBundle = NO;</div><div class="line">while (i--) &#123;</div><div class="line">    auto&amp; entry = cats-&gt;list[i];</div><div class="line">    method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">    if (mlist) &#123;</div><div class="line">        mlists[mcount++] = mlist;</div><div class="line">        fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">    &#125;</div><div class="line">    property_list_t *proplist = </div><div class="line">        entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class="line">    if (proplist) &#123;</div><div class="line">        proplists[propcount++] = proplist;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class="line">    if (protolist) &#123;</div><div class="line">        protolists[protocount++] = protolist;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">auto rw = cls-&gt;data();</div><div class="line">prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">// 添加方法</div><div class="line">rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">free(mlists);</div><div class="line">if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class="line">// 添加属性</div><div class="line">rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">free(proplists);</div><div class="line">// 添加协议</div><div class="line">rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">free(protolists);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h4 id="attachLists"><a href="#attachLists" class="headerlink" title="attachLists"></a>attachLists</h4><p><code>void attachLists(List* const * addedLists, uint32_t addedCount)</code>主要是将分类中的内容添加到宿主类中；以method为例；第一步<br>扩充宿主元素的method_list得容量，具体扩充多少，由 要添加多少新方法来决定；第二步将宿主方法列表中的元素向后移动位置；第三步：将分类中的方法一次填充到宿主元素的methodList中；   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class="line">    if (addedCount == 0) return;</div><div class="line">    if (hasArray()) &#123;</div><div class="line">        // many lists -&gt; many lists</div><div class="line">        uint32_t oldCount = array()-&gt;count;</div><div class="line">        uint32_t newCount = oldCount + addedCount;</div><div class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">        array()-&gt;count = newCount;</div><div class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, </div><div class="line">                oldCount * sizeof(array()-&gt;lists[0]));</div><div class="line">        memcpy(array()-&gt;lists, addedLists, </div><div class="line">               addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">    &#125;</div><div class="line">    else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class="line">        // 0 lists -&gt; 1 list</div><div class="line">        list = addedLists[0];</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">        // 1 list -&gt; many lists</div><div class="line">        List* oldList = list;</div><div class="line">        uint32_t oldCount = oldList ? 1 : 0;</div><div class="line">        uint32_t newCount = oldCount + addedCount;</div><div class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class="line">        array()-&gt;count = newCount;</div><div class="line">        if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class="line">        memcpy(array()-&gt;lists, addedLists, </div><div class="line">               addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>文章参照  <a href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/" target="_blank" rel="external">Objective-C Category 的实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际的开发过程中，经常会遇到给现有的系统类增加新方法的需求。根据面向对象语言的特性可以使用继承来实现，但仅仅为了增加一个方法需要把父类的所有属性以及方法都要继承，这种实现机制就显得过于繁琐了。在&lt;code&gt;Objective-C&lt;/code&gt;语言中&lt;code&gt;分类&lt;/code&gt;特性可以满足给现有类直接新增方法的需求。&lt;br&gt;具体使用是新建Category文件，这样在新建在Category的文件中就可以添加&lt;strong&gt;方法（实例方法、类方法）&lt;/strong&gt;、&lt;strong&gt;协议&lt;/strong&gt;、&lt;strong&gt;属性&lt;/strong&gt;;其中属性的实现还需要根据关联对象来辅助才能实现；&lt;/p&gt;
&lt;h3 id=&quot;分类的用途&quot;&gt;&lt;a href=&quot;#分类的用途&quot; class=&quot;headerlink&quot; title=&quot;分类的用途&quot;&gt;&lt;/a&gt;分类的用途&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;声明私有方法:在当前类的.m文件中声明并实现，对外不进行暴露&lt;/li&gt;
&lt;li&gt;分解体积庞大的类文件&lt;/li&gt;
&lt;li&gt;公开frameWork中的一些私有方法【较少使用】&lt;/li&gt;
&lt;li&gt;为系统类增加方法
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>生活篇--说说三观</title>
    <link href="http://yoursite.com/2017/06/04/%E7%94%9F%E6%B4%BB%E7%AF%87--%E8%AF%B4%E8%AF%B4%E4%B8%89%E8%A7%82/"/>
    <id>http://yoursite.com/2017/06/04/生活篇--说说三观/</id>
    <published>2017-06-04T09:37:48.000Z</published>
    <updated>2018-06-23T04:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="人生观"><a href="#人生观" class="headerlink" title="人生观"></a>人生观</h3><blockquote><p>对于人生的根本态度与看法  </p></blockquote><p>   人生千姿百态，每个人都是一个演员在无剧本的人生舞台上做着自己的表演。有句话说<strong>意识决定形态</strong>，我个人浅显的理解就是你自己的意愿想通过哪种姿态展现自己， 那么在世人面前你就是以哪种姿态呈现。<br>有时候我们会感慨某某活成了我们自己想要的模样，其实本质上我们都有活成某种模样的意识但最终为什么差别很大？主要原因是缺乏行动，多数人都具有正确的人生观：积极生活、努力奋斗、追求幸福等；但又有多少勤勤恳恳的去实践自己的人生观呢？经常会听到说这人的做事态度不错，但请不要忘记最终衡量你的还是做事的结果。获取正确的人生观容易，困难的是通过正确的人生观来让生活极大丰富才是最困难的事情！<br><a id="more"></a></p><h4 id="人生观主要包含哪些"><a href="#人生观主要包含哪些" class="headerlink" title="人生观主要包含哪些"></a>人生观主要包含哪些</h4><ul><li>友谊观</li><li>恋爱观</li><li>审美观</li><li>道德观</li><li>苦乐观</li><li>幸福观</li></ul><h3 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h3><blockquote><p>它是人们对世界的基本看法和观点.世界观具有实践性，人的世界观是不断更新、不断完善、不断优化的；  </p></blockquote><p>世界观确实是在不断的更新中的，<strong>世界那么大，我想去看看</strong>本质上的追求是去丰富自己的世界观的，而不是仅仅看看风景，发发朋友圈而已。去一个地方应该在欣赏美景的同时去了解风土人情，通过比较差异来完善自己的认知，使得自己更为的丰富。</p><h3 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h3><blockquote><p> 用以区分好与坏的标准，是根据个人内心的尺度进行衡量和评价的，这些标准都可以称为价值观。  </p></blockquote><p>我们日常会听到<strong>某某的价值观出了问题</strong>，其实呢我们是在说某人对于问题的评判或者是做的某些行为严重的偏离了我们正常的认知；那么具体什么是正确的价值观呢？这个问题需要我们自己不断的去探寻、去学习。有些价值观是父母师长等人群灌输的；例如孝敬长者，尊师重道等基本的道德要求；真善美与假恶丑是需要自己去分辨的。特别是目前我们处于互联网时代，言论自由，你对于每一个事件的看法都是你价值观的体现；平时和朋友相处也是，交谈中你的价值观就被反应出来了，价值观一致的人才适合一起玩耍的！</p><h3 id="婚姻观"><a href="#婚姻观" class="headerlink" title="婚姻观"></a>婚姻观</h3><blockquote><p>对婚姻和家庭的看法和态度。</p></blockquote><p>我个人一直遵守家庭第一，其他第二的原则；把家庭照顾好了的前提下再向<em>大家</em>奉献，我觉得才是理想的状态。因为每个人的人生观不同所以也就没有评判对与错的必要；</p><h4 id="幸福婚姻应该包含哪些要素"><a href="#幸福婚姻应该包含哪些要素" class="headerlink" title="幸福婚姻应该包含哪些要素"></a>幸福婚姻应该包含哪些要素</h4><ul><li>童心</li><li>浪漫</li><li>幽默</li><li>亲昵</li><li>情话</li><li>沟通</li><li>欣赏</li></ul><p>日常我们经常听到<strong>三观尽毁</strong>和<strong>三观正才能一起玩耍</strong>；一直以来都没有好好的思考自己的<strong>三观</strong>到底是什么？其实我的日常生活中存在很多这样的习以为常的问题都被自己忽略了，真的很不应该，问题是应该被解决的，时间不会将它带走！追求简单生活，不要要逃避问题，而是要解决复杂的问题，这样生活才会简单！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;人生观&quot;&gt;&lt;a href=&quot;#人生观&quot; class=&quot;headerlink&quot; title=&quot;人生观&quot;&gt;&lt;/a&gt;人生观&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对于人生的根本态度与看法  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   人生千姿百态，每个人都是一个演员在无剧本的人生舞台上做着自己的表演。有句话说&lt;strong&gt;意识决定形态&lt;/strong&gt;，我个人浅显的理解就是你自己的意愿想通过哪种姿态展现自己， 那么在世人面前你就是以哪种姿态呈现。&lt;br&gt;有时候我们会感慨某某活成了我们自己想要的模样，其实本质上我们都有活成某种模样的意识但最终为什么差别很大？主要原因是缺乏行动，多数人都具有正确的人生观：积极生活、努力奋斗、追求幸福等；但又有多少勤勤恳恳的去实践自己的人生观呢？经常会听到说这人的做事态度不错，但请不要忘记最终衡量你的还是做事的结果。获取正确的人生观容易，困难的是通过正确的人生观来让生活极大丰富才是最困难的事情！&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随感" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C之KVC</title>
    <link href="http://yoursite.com/2017/02/27/Objective-C%E4%B9%8BKVC/"/>
    <id>http://yoursite.com/2017/02/27/Objective-C之KVC/</id>
    <published>2017-02-27T03:37:40.000Z</published>
    <updated>2019-01-13T10:59:51.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是KVC"><a href="#什么是KVC" class="headerlink" title="什么是KVC"></a>什么是KVC</h4><blockquote><p>key value coding：是一种使用字符串标识符间接访问对象属性的机制；  </p></blockquote><pre><code>NSObject 提供如下方法：     [obj setValue:&lt;#(nullable id)#&gt; forKey:&lt;#(nonnull NSString *)#&gt;];     [obj setValue:&lt;#(nullable id)#&gt; forKeyPath:&lt;#(nonnull NSString *)#&gt;];     [obj setValue:&lt;#(nullable id)#&gt; forUndefinedKey:&lt;#(nonnull NSString *)#&gt;];     [obj setValuesForKeysWithDictionary:&lt;#(nonnull NSDictionary&lt;NSString *,id&gt; *)#&gt;];     [obj valueForKey:&lt;#(nonnull NSString *)#&gt;];     [obj valueForKeyPath:&lt;#(nonnull NSString *)#&gt;];     [obj valueForUndefinedKey:&lt;#(nonnull NSString *)#&gt;];</code></pre><h4 id="如何使用KVC"><a href="#如何使用KVC" class="headerlink" title="如何使用KVC"></a>如何使用KVC</h4><pre><code>KVCObjectTest* kvcTest = [KVCObjectTest new];       // setvalue[kvcTest setValue:@&quot;hua&quot; forKey:@&quot;name&quot;];       // getvalue NSLog(@&quot;name:%@&quot;,[kvcTest valueForKey:@&quot;name&quot;]);</code></pre><a id="more"></a>   <h4 id="KVC的优点"><a href="#KVC的优点" class="headerlink" title="KVC的优点"></a>KVC的优点</h4><ul><li>能对对象的成员变量和私有属性进行操作  </li><li>自动拆装箱操作（price为CGFloat）<br><code>[obj setValue:@&quot;20.0&quot; forKey:@&quot;price&quot;];</code>  </li><li>对集合的操作能力<br><code>[obj setValue:objArray forKey:@&quot;relativeObjs&quot;];</code>  </li><li>对于集合的运算（relativeBooks为保存book对象的NSArray数组）  <pre><code>NSLog(@&quot;relativeBooksCount:%@&quot;,[book valueForKeyPath:@&quot;relativeBooks.@count&quot;]);NSLog(@&quot;relativeBooksPrice sum:%@&quot;,[book valueForKeyPath:@&quot;relativeBooks.@sum.price&quot;]);//-价格总和NSLog(@&quot;relativeBooksPrice avg:%@&quot;,[book valueForKeyPath:@&quot;relativeBooks.@avg.price&quot;]);//-价格的平均数NSLog(@&quot;relativeBooksPrice max:%@&quot;,[book //-valueForKeyPath:@&quot;relativeBooks.@max.price&quot;]);NSLog(@&quot;relativeBooksPrice min:%@&quot;,[book valueForKeyPath:@&quot;relativeBooks.@min.price&quot;]);</code></pre></li><li>kvc可以在一个语句中为多个属性赋值(对属性使用字典直接赋值(用字典直接初始化一个对象的成员变量（局限性）字典中的key要和成员变量意义对应)  <pre><code>Book* book1 = [[Book alloc] init];NSDictionary* bookPropertiesDict =@{@&quot;name&quot;:@&quot;OC入门&quot;,@&quot;price&quot;:@&quot;20.8&quot;};[book1 setValuesForKeysWithDictionary:bookPropertiesDict];NSLog(@&quot;%@&quot;,[book1 valueForKeyPath:@&quot;name&quot;]);</code></pre></li></ul><h4 id="KVC的实现"><a href="#KVC的实现" class="headerlink" title="KVC的实现"></a>KVC的实现</h4><ul><li>KVC运用了一个isa-swizzling技术，isa-swizzling就是类型混合指针机制。KVC主要通过isa- swizzling，来实现其内部查找定位的。   </li><li>isa 指针  <pre><code>struct objc_class {               Class isa;//指针，顾名思义，表示是一个什么，               //实例的isa指向类对象，类对象的isa指向元类               #if !__OBJC2__               Class super_class;  //指向父类               const char *name;  //类名               long version;               long info;               long instance_size               struct objc_ivar_list *ivars //成员变量列表               struct objc_method_list **methodLists; //方法列表               struct objc_cache *cache;//缓存               //一种优化，调用过的方法存入缓存列表，下次调用先找缓存               struct objc_protocol_list *protocols //协议列表               #endif           } OBJC2_UNAVAILABLE;</code></pre></li><li>实例代码经过编译器之后  <pre><code>[obj setValue:@&quot;objname&quot; forKey:@&quot;name&quot;]; 就会被编译器处理成： SEL sel = sel_get_uid (&quot;setValue:forKey:&quot;); IMP method = objc_msg_lookup (obj-&gt;isa,sel); method(obj, sel, @&quot;objname&quot;, @&quot;name&quot;);</code></pre></li><li>附加  <ul><li>SEL：选择器，是表示一个方法的selector的指针  <blockquote><p><code>typedef struct objc_selector *SEL;</code><br>Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL;本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。  </p></blockquote></li><li>IMP：实际上是一个函数指针，指向方法实现的首地址  <blockquote><p>id (*IMP)(id, SEL, …)<br> 参数1：实例方法或者是类方法 分别代表类实例的内存地址或是指向原类的指针   </p></blockquote></li><li>Method ：表示类定义的方法   <pre><code>typedef struct objc_method *Method;                 struct objc_method {                 SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名                 char *method_types                  OBJC2_UNAVAILABLE;                 IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现                 }</code></pre></li></ul></li></ul><h4 id="KVC内部的实现：一个对象在调用setValue的时候"><a href="#KVC内部的实现：一个对象在调用setValue的时候" class="headerlink" title="KVC内部的实现：一个对象在调用setValue的时候"></a>KVC内部的实现：一个对象在调用setValue的时候</h4><ul><li>首先根据方法名找到运行方法的时候所需要的环境参数（SEL）。   </li><li>他会从自己isa指针结合环境参数，找到具体的方法实现的接口（IMP）。   </li><li>再直接查找得来的具体的方法实现（method）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是KVC&quot;&gt;&lt;a href=&quot;#什么是KVC&quot; class=&quot;headerlink&quot; title=&quot;什么是KVC&quot;&gt;&lt;/a&gt;什么是KVC&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;key value coding：是一种使用字符串标识符间接访问对象属性的机制；  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;NSObject 提供如下方法：
     [obj setValue:&amp;lt;#(nullable id)#&amp;gt; forKey:&amp;lt;#(nonnull NSString *)#&amp;gt;];
     [obj setValue:&amp;lt;#(nullable id)#&amp;gt; forKeyPath:&amp;lt;#(nonnull NSString *)#&amp;gt;];
     [obj setValue:&amp;lt;#(nullable id)#&amp;gt; forUndefinedKey:&amp;lt;#(nonnull NSString *)#&amp;gt;];
     [obj setValuesForKeysWithDictionary:&amp;lt;#(nonnull NSDictionary&amp;lt;NSString *,id&amp;gt; *)#&amp;gt;];
     [obj valueForKey:&amp;lt;#(nonnull NSString *)#&amp;gt;];
     [obj valueForKeyPath:&amp;lt;#(nonnull NSString *)#&amp;gt;];
     [obj valueForUndefinedKey:&amp;lt;#(nonnull NSString *)#&amp;gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;如何使用KVC&quot;&gt;&lt;a href=&quot;#如何使用KVC&quot; class=&quot;headerlink&quot; title=&quot;如何使用KVC&quot;&gt;&lt;/a&gt;如何使用KVC&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;KVCObjectTest* kvcTest = [KVCObjectTest new];
       // setvalue
[kvcTest setValue:@&amp;quot;hua&amp;quot; forKey:@&amp;quot;name&amp;quot;];
       // getvalue
 NSLog(@&amp;quot;name:%@&amp;quot;,[kvcTest valueForKey:@&amp;quot;name&amp;quot;]);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C之KVO</title>
    <link href="http://yoursite.com/2017/02/20/Objective-C%E4%B9%8BKVO/"/>
    <id>http://yoursite.com/2017/02/20/Objective-C之KVO/</id>
    <published>2017-02-20T03:37:40.000Z</published>
    <updated>2019-01-13T11:01:07.956Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是KVO"><a href="#什么是KVO" class="headerlink" title="什么是KVO"></a>什么是KVO</h4><blockquote><p>KVO,即：Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。  </p></blockquote><a id="more"></a>   <h4 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h4><pre><code>// 添加监测-(void)test{    [self addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];}//属性改变后的响应-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context{    /**     * 检测改变的数据     change是一个字典     {     kind = 1;     new = newValue;//获取新数据 一定要使用@&quot;new&quot;作为key 在change字典中获取     old = oldValue;     }     根据监控的属性 通过字典key（new）来获取改变后的值     */    if ([keyPath isEqualToString:@&quot;name&quot;]) {        NSLog(@&quot;%@&quot;,[change objectForKey:@&quot;new&quot;]);    }}// 移除监测-(void)dealloc{    [self removeObserver:self forKeyPath:@&quot;name&quot;];}</code></pre><h4 id="KVO的内部实现"><a href="#KVO的内部实现" class="headerlink" title="KVO的内部实现"></a>KVO的内部实现</h4><p><a href="http://www.cocoachina.com/industry/20140107/7667.html" target="_blank" rel="external">KVO的内部实现</a><br><a href="http://www.cocoachina.com/industry/20140624/8936.html" target="_blank" rel="external">KVO简单探索</a>  </p><h4 id="自我实现KVO"><a href="#自我实现KVO" class="headerlink" title="自我实现KVO"></a>自我实现KVO</h4><p><a href="http://www.cocoachina.com/ios/20150313/11321.html" target="_blank" rel="external">自我实现KVO</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是KVO&quot;&gt;&lt;a href=&quot;#什么是KVO&quot; class=&quot;headerlink&quot; title=&quot;什么是KVO&quot;&gt;&lt;/a&gt;什么是KVO&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;KVO,即：Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C之方法</title>
    <link href="http://yoursite.com/2017/01/10/Objective-C%E4%B9%8B%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/01/10/Objective-C之方法/</id>
    <published>2017-01-10T10:00:32.000Z</published>
    <updated>2019-01-13T10:54:16.521Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C方法相关内容 </p><blockquote><p>文章参考 <a href="http://tech.glowing.com/cn/objective-c-runtime/" target="_blank" rel="external">Objective-C Runtime</a></p></blockquote><p>在项目编码中最为常见的就是[object message];这种形式的消息发送，对于其他面向对象语言来说就是实例对象调用类中实现的实例方法；[object message]这种形式到底做了什么呢？<br><a id="more"></a></p><h4 id="objc-object-objc-class-以及-objc-method"><a href="#objc-object-objc-class-以及-objc-method" class="headerlink" title="objc_object, objc_class 以及 objc_method"></a>objc_object, objc_class 以及 objc_method</h4><p>在Objective-C中类、对象、方法都是C语言中结构体类型；具体数据类型可以参照<code>objc/objc.h</code>文件</p><pre><code> // 类 struct objc_class {                        Class isa;//指针，顾名思义，表示是一个什么，                        //实例的isa指向类对象，类对象的isa指向元类                        #if !__OBJC2__                        Class super_class;  //指向父类                        const char *name;  //类名                        long version;                        long info;                        long instance_size                        struct objc_ivar_list *ivars //成员变量列表                        struct objc_method_list **methodLists; //方法列表                        struct objc_cache *cache;//缓存一种优化，调用过的方法存入缓存列表，下次调用先找缓存                        struct objc_protocol_list *protocols //协议列表                        #endif            } OBJC2_UNAVAILABLE; //对象             struct objc_object {                    Class isa  OBJC_ISA_AVAILABILITY;            };// 方法            struct objc_method {                    SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名                    char *method_types                  OBJC2_UNAVAILABLE;                    IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现            }</code></pre><h4 id="消息的传递"><a href="#消息的传递" class="headerlink" title="消息的传递"></a>消息的传递</h4><h5 id="在People类中声明并实现walk方法则消息会正常被传递"><a href="#在People类中声明并实现walk方法则消息会正常被传递" class="headerlink" title="在People类中声明并实现walk方法则消息会正常被传递"></a>在<code>People</code>类中声明并实现<code>walk</code>方法则消息会正常被传递</h5><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface HZPeople : NSObject-(void)walk;@end#import &quot;HZPeople.h&quot;#import &lt;objc/objc-runtime.h&gt;@implementation HZPeople-(void)walk{    NSLog(@&quot;people walk!!&quot;);}</code></pre><p>控制台能正常打印 <code>people walk!!</code>   </p><h5 id="如果只声明并不是实现walk方法则会调用-BOOL-resolveInstanceMethod-SEL-sel-允许在此进行对类增加方法"><a href="#如果只声明并不是实现walk方法则会调用-BOOL-resolveInstanceMethod-SEL-sel-允许在此进行对类增加方法" class="headerlink" title="如果只声明并不是实现walk方法则会调用+(BOOL)resolveInstanceMethod:(SEL)sel;允许在此进行对类增加方法"></a>如果只声明并不是实现<code>walk</code>方法则会调用<code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>;允许在此进行对类增加方法</h5><pre><code>    #import &lt;Foundation/Foundation.h&gt;    @interface HZPeople : NSObject    -(void)walk;    @end    #import &quot;HZPeople.h&quot;    #import &lt;objc/objc-runtime.h&gt;    @implementation HZPeople    void anotherPeopleWalk(id obj ,SEL _cmd){NSLog(@&quot;anotherPeopleWalk!&quot;);}    +(BOOL)resolveInstanceMethod:(SEL)sel{NSLog(@&quot;resolveInstanceMethod!&quot;);if (sel == @selector(walk)) {  // 通过imp_implementationWithBlock执行新增方法事项    IMP fooIMP = imp_implementationWithBlock(^(id _self) {        NSLog(@&quot;Doing foo&quot;);    });    // 给类动态添加执行方法    class_addMethod([self class], sel, fooIMP, &quot;v@:&quot;);  //  class_addMethod([self class], sel, (IMP)anotherPeopleWalk, &quot;v@:&quot;);    return YES;}return [super resolveInstanceMethod:sel];}</code></pre><p>控制台会先打印<code>resolveInstanceMethod</code>然后打印<code>Doing foo</code>   </p><h5 id="BOOL-resolveInstanceMethod-SEL-sel中没有实现方法的新增则会调用-id-forwardingTargetForSelector-SEL-aSelector允许对消息转发给其他对象"><a href="#BOOL-resolveInstanceMethod-SEL-sel中没有实现方法的新增则会调用-id-forwardingTargetForSelector-SEL-aSelector允许对消息转发给其他对象" class="headerlink" title="+(BOOL)resolveInstanceMethod:(SEL)sel中没有实现方法的新增则会调用-(id)forwardingTargetForSelector:(SEL)aSelector允许对消息转发给其他对象"></a><code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>中没有实现方法的新增则会调用<code>-(id)forwardingTargetForSelector:(SEL)aSelector</code>允许对消息转发给其他对象</h5><pre><code>   #import &lt;Foundation/Foundation.h&gt;    #import &quot;HZMan.h&quot;    @interface HZPeople : NSObject    @property(nonatomic,strong)HZMan* man;    -(void)walk;    @end    #import &quot;HZPeople.h&quot;    #import &lt;objc/objc-runtime.h&gt;    @implementation HZPeople    -(id)forwardingTargetForSelector:(SEL)aSelector{if (aSelector == @selector(walk)) {    // 将消息转发给HZMan中的walk方法    return self.man;}return [super forwardingTargetForSelector:aSelector];}</code></pre><h5 id="id-forwardingTargetForSelector-SEL-aSelector如果没有实现还有最后的机会进行一次消息转发；这个需要重写-NSMethodSignature-methodSignatureForSelector-SEL-aSelector为执行方法进行签名，最后在实现-void-forwardInvocation-NSInvocation-anInvocation完成一次消息的完整转发"><a href="#id-forwardingTargetForSelector-SEL-aSelector如果没有实现还有最后的机会进行一次消息转发；这个需要重写-NSMethodSignature-methodSignatureForSelector-SEL-aSelector为执行方法进行签名，最后在实现-void-forwardInvocation-NSInvocation-anInvocation完成一次消息的完整转发" class="headerlink" title="-(id)forwardingTargetForSelector:(SEL)aSelector如果没有实现还有最后的机会进行一次消息转发；这个需要重写- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector为执行方法进行签名，最后在实现-(void)forwardInvocation:(NSInvocation *)anInvocation完成一次消息的完整转发"></a><code>-(id)forwardingTargetForSelector:(SEL)aSelector</code>如果没有实现还有最后的机会进行一次消息转发；这个需要重写<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>为执行方法进行签名，最后在实现<code>-(void)forwardInvocation:(NSInvocation *)anInvocation</code>完成一次消息的完整转发</h5><pre><code> #import &lt;Foundation/Foundation.h&gt;    #import &quot;HZMan.h&quot;    @interface HZPeople : NSObject    @property(nonatomic,strong)HZMan* man;    -(void)walk;    @end    #import &quot;HZPeople.h&quot;    #import &lt;objc/objc-runtime.h&gt;    @implementation HZPeople    - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {NSMethodSignature* signature = [super methodSignatureForSelector:aSelector];if(!signature){    signature = [_man methodSignatureForSelector:aSelector];}return signature;}-(void)forwardInvocation:(NSInvocation *)anInvocation{    SEL sel = anInvocation.selector;    if ([self .man respondsToSelector:sel]) {        [anInvocation invokeWithTarget:self.man];    }else{        [self doesNotRecognizeSelector:sel];    }}</code></pre><h5 id="如果最终也没有对消息进行处理就只能执行doesNotRecognizeSelector-sel抛出异常了"><a href="#如果最终也没有对消息进行处理就只能执行doesNotRecognizeSelector-sel抛出异常了" class="headerlink" title="如果最终也没有对消息进行处理就只能执行doesNotRecognizeSelector:sel抛出异常了"></a>如果最终也没有对消息进行处理就只能执行<code>doesNotRecognizeSelector:sel</code>抛出异常了</h5><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><ul><li>SEL: Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL,本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。</li><li>IMP：实际上是一个函数指针，指向方法实现的首地址</li><li><p>Method ：表示类定义的方法</p><pre><code>typedef struct objc_method *Method; struct objc_method {     SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名     char *method_types                  OBJC2_UNAVAILABLE;     IMP method_imp                      OBJC2_UNAVAILABLE;  // 方法实现}</code></pre></li></ul><h3 id="load-和-initialize"><a href="#load-和-initialize" class="headerlink" title="+load 和 +initialize"></a><code>+load</code> 和 <code>+initialize</code></h3><ul><li><code>+load</code>:类加载时调用，程序生命周期内仅仅调用一次</li><li><code>+initialize</code> ：会在第一次调用类的类方法或实例方法之前被调用。【类第一次被使用】</li></ul><h3 id="objc-msgSend-的理解："><a href="#objc-msgSend-的理解：" class="headerlink" title="objc_msgSend 的理解："></a>objc_msgSend 的理解：</h3><ul><li>objc_msgSend(id self,SEL cmd,…);</li><li>[someobject sendMsg:param];=&gt;本质上是转化成<code>objc_msgsend(someobject,selector(sendMsg),param);</code></li><li>消息的传递：首先会在当前对象的类的方法列表（先查缓存表）中查，若是没有找到会向父类中查找，若没有则消息转发，如若没有报异常信息</li></ul><h3 id="理解消息转发机制（method-forwarding）"><a href="#理解消息转发机制（method-forwarding）" class="headerlink" title="理解消息转发机制（method forwarding）"></a>理解消息转发机制（method forwarding）</h3><p>消息转发分为两个主要的部分：动态方法解析和消息转发</p><ul><li>动态方法解析：重写<code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>方法，动态的使用<code>class_add</code>为当前类增加方法</li><li>消息转发：转发方式有如下两种：<ul><li>将消息转发给制定的对象：重写<code>-(id)forwardingTargetForSelector:(SEL)aSelector</code>指定接收消息的对象</li><li>若没有指定转发给哪个对象接收消息，则将消息包装为NSInvocation对象做转发，首先需要对selector做方法的签名；重写<code>-(NSMethodSignature*)methodSignatureForSelector:(SEL)aSelector</code>,然后重写<code>-(void)forwardInvocation:(NSInvocation*)anInvocation</code>完成消息的最终转发</li></ul></li></ul><h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><p>NSInvocation用来描述objective-c的消息，一个NSInvocation对象包含消息的基本元素：目标、selector、参数、返回值  </p><h4 id="普通方法调用"><a href="#普通方法调用" class="headerlink" title="普通方法调用"></a>普通方法调用</h4><pre><code>- (void)methodOne{    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];    [dateFormatter setDateFormat:@&quot;YYYY-MM-dd&quot;];    HZMethodTarget * method = [HZMethodTarget new];    NSString * currentDate = [method stringForDate:[NSDate date] usingFormatter:dateFormatter];    NSLog(@&quot;currentDate:%@&quot;,currentDate);}</code></pre><h4 id="使用NSInvocation对象执行方法的调用"><a href="#使用NSInvocation对象执行方法的调用" class="headerlink" title="使用NSInvocation对象执行方法的调用"></a>使用NSInvocation对象执行方法的调用</h4><pre><code>- (void)methodTwo{    HZMethodTarget * method = [HZMethodTarget new];    SEL aSel = @selector(stringForDate:usingFormatter:);    NSMethodSignature *methodSignature = [HZMethodTarget instanceMethodSignatureForSelector:aSel];    NSInvocation *anInvocation = [NSInvocation invocationWithMethodSignature:methodSignature];    [anInvocation setTarget:method];    [anInvocation setSelector:aSel];    NSDate *currentDate = [NSDate date];    [anInvocation setArgument:&amp;currentDate atIndex:2];    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];    [dateFormatter setDateFormat:@&quot;YYYY-MM-dd&quot;];    [anInvocation setArgument:&amp;dateFormatter atIndex:3];    [anInvocation retainArguments];    [anInvocation invoke];    //使用局部变量接收函数的返回值会引发崩溃[]  NSString *result = nil;-[CFString release]: message sent to deallocated instance 0x600002be0bc0    [anInvocation getReturnValue:&amp;_result];    NSLog(@&quot;result==&gt;:%@&quot;,_result);}</code></pre><h3 id="方法交换（method-swizzle）"><a href="#方法交换（method-swizzle）" class="headerlink" title="方法交换（method swizzle）"></a>方法交换（method swizzle）</h3><p>为了对系统某些API新增一些功能时，例如：页面数据统计，需要在<code>viewWillAppear</code>方法中打点;  </p><pre><code>#import &quot;UIViewController+Tracking.h&quot;#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load {    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        Class class = [self class];        SEL originalSelector = @selector(viewWillAppear:);        SEL swizzledSelector = @selector(tracking_viewWillAppear:);        Method originalMethod = class_getInstanceMethod(class, originalSelector);        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);        method_exchangeImplementations(originalMethod, swizzledMethod);    });}#pragma mark - Method Swizzling- (void)tracking_viewWillAppear:(BOOL)animated {    NSLog(@&quot;Method Swizzling viewWillAppear: %@&quot;, self);    [self tracking_viewWillAppear:animated];}@end</code></pre><h4 id="method-swizzle的使用场景"><a href="#method-swizzle的使用场景" class="headerlink" title="method swizzle的使用场景"></a>method swizzle的使用场景</h4><ul><li>页面统计打点</li><li>按钮避免多次点击</li><li>集合(NSArray/NSDictionary)避免传入nil引发崩溃</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C方法相关内容 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文章参考 &lt;a href=&quot;http://tech.glowing.com/cn/objective-c-runtime/&quot;&gt;Objective-C Runtime&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在项目编码中最为常见的就是[object message];这种形式的消息发送，对于其他面向对象语言来说就是实例对象调用类中实现的实例方法；[object message]这种形式到底做了什么呢？&lt;br&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构之单链表</title>
    <link href="http://yoursite.com/2017/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/01/05/数据结构之单链表/</id>
    <published>2017-01-05T12:44:54.000Z</published>
    <updated>2019-01-13T02:49:26.762Z</updated>
    
    <content type="html"><![CDATA[<p>线性表的顺序存储结构在查找指定位置的元素时操作较快，但是在插入和删除操作的时候需要移动大量数据的位置，操作较为耗时，造成这种结果的原因在于顺序存储是开辟一块连续的内存空间，各个数据之间紧紧相邻；那么解决顺序存储插入和删除问题就需要采取另外一种存储结构–链式存储；</p><a id="more"></a>  <h4 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h4><p>在顺序存储结构中数据元素只要存储数据元素信息就可以了，而链式存储结构还需要存储下一个结点的内存地址，即每个数据元素成为一个独立的结点，结点包含数据信息和地址信息两个部分；n个这样的结点就构成了链表，  </p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p> 因为结点中只存在一个地址指针，即该链表又称之为单链表   </p><h4 id="头结点"><a href="#头结点" class="headerlink" title="头结点"></a>头结点</h4><p>排在单链表的第一个结点前的结点叫头结点  </p><h4 id="头指针"><a href="#头指针" class="headerlink" title="头指针"></a>头指针</h4><p>链表第一个结点的存储位置即为头指针/ 头结点中存放的指针即为头指针  </p><h4 id="单链表的链式存储结构"><a href="#单链表的链式存储结构" class="headerlink" title="单链表的链式存储结构"></a>单链表的链式存储结构</h4><pre><code>typedef int ElemType;typedef struct Node{    ElemType data;    struct Node * next;}Node;typedef struct Node* LinkList;  </code></pre><p> 一个结点的构成包含数据域和指针区域；  </p><h4 id="单链表的初始化"><a href="#单链表的初始化" class="headerlink" title="单链表的初始化"></a>单链表的初始化</h4><pre><code>LinkList linkListInit(){Node* L ;L = (Node*)malloc(sizeof(Node));if (L == NULL) {    printf(&quot;申请内存空间失败\n&quot;);}L -&gt;next = NULL;return L;}     </code></pre><h4 id="创建单链表之头插入方法"><a href="#创建单链表之头插入方法" class="headerlink" title="创建单链表之头插入方法"></a>创建单链表之头插入方法</h4><pre><code>LinkList linkListCreateHeaderMethod(int numberOfNode){Node* L ;L = (Node*)malloc(sizeof(Node));if (L==NULL) {    return NULL;}L-&gt;next = NULL;for (int i =0; i&lt;numberOfNode; i++) {    Node *p;    p =(Node*) malloc(sizeof(Node));    p -&gt; data = i ;    p-&gt;next = L-&gt;next;   //将结点插入到表头L--&gt;|3|--&gt;|2|--&gt;|1|--&gt;NULL    L -&gt; next = p;}return L;}  </code></pre><p> 头插入法创建单链表是在头指针和第一个结点之间完成插入操作，新节点的指针存放的是上一个作为第一个结点的地址即L-&gt;next；然后再讲L-&gt;next指向新节点p即可；  </p><h4 id="创建单链表之尾插入方法"><a href="#创建单链表之尾插入方法" class="headerlink" title="创建单链表之尾插入方法"></a>创建单链表之尾插入方法</h4><pre><code>LinkList linkListCreateTailMethod(int numberOfNode){Node* L ;L = (Node*)malloc(sizeof(Node));if (L==NULL) {    return NULL;}L -&gt; next = NULL;Node* tempL = L;for (int i = 0; i&lt;numberOfNode; i++) {    Node* p ;    p = (Node*)malloc(sizeof(Node));    p -&gt;data = i ;    tempL -&gt; next = p ;    tempL = p ;}tempL -&gt;next = NULL;return L;} </code></pre><p> 尾插入就是将新建立的结点放在链表的最后；  </p><h4 id="单链表的插入操作"><a href="#单链表的插入操作" class="headerlink" title="单链表的插入操作"></a>单链表的插入操作</h4><pre><code>int linkListInsert(LinkList list ,int index,int e){    Node* pre ;    pre = list;    for (int i = 1; i&lt;index; i++) {        pre = pre -&gt;next;    }    if (pre) {        Node* newNode;        newNode  = (Node*)malloc(sizeof(Node));        newNode-&gt;data = e ;        newNode-&gt;next = pre-&gt;next;        pre-&gt;next = newNode;        return 1;    }    return 0;} </code></pre><h4 id="单链表的删除操作"><a href="#单链表的删除操作" class="headerlink" title="单链表的删除操作"></a>单链表的删除操作</h4><pre><code>int linkListDeleteNode(LinkList list ,int e){    Node *p,*pre = NULL;                   //pre为前驱结点，p为查找的结点。    p = list-&gt;next;    while(p-&gt;data != e)              //查找值为x的元素    {        pre = p;        p = p-&gt;next;    }    pre-&gt;next = p-&gt;next;          //删除操作，将其前驱next指向其后继。    free(p);    return 1;}  </code></pre><h4 id="单链表返回指定位置的结点数据"><a href="#单链表返回指定位置的结点数据" class="headerlink" title="单链表返回指定位置的结点数据"></a>单链表返回指定位置的结点数据</h4><pre><code>int GetElem(LinkList list,int index,ElemType *e){    int i=1;    LinkList p ;    p = list -&gt;next; // 默认链表名作为第一个结点的指针    while (i&lt;index&amp;&amp;p) {        p = p -&gt;next;        i++;    }    if (!p||i&gt;index) {       return 0;    }else{        *e = p-&gt;data;        return 1;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性表的顺序存储结构在查找指定位置的元素时操作较快，但是在插入和删除操作的时候需要移动大量数据的位置，操作较为耗时，造成这种结果的原因在于顺序存储是开辟一块连续的内存空间，各个数据之间紧紧相邻；那么解决顺序存储插入和删除问题就需要采取另外一种存储结构–链式存储；&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构之线性表的顺序存储</title>
    <link href="http://yoursite.com/2017/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2017/01/04/数据结构之线性表的顺序存储/</id>
    <published>2017-01-04T12:57:54.000Z</published>
    <updated>2019-01-13T02:49:01.586Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><blockquote><p>零个或多个数据元素的有限序列；可以理解为数据按照顺序依次排列，除了头结点和尾结点外其他结点只存在唯一的前继和后继； 例如：平时购票的队伍、从北京到上海的京沪线等；</p></blockquote><h4 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h4><pre><code>#define MAXSIEZ 20typedef int ElemType;typedef struct {    ElemType data[MAXSIEZ];    int length;}SqList;</code></pre><p>线性表的顺序存储结构包含两部分，一个是存储数据的数组，一个实际存储数据元素个数的整型变量；其中MAXSIEZ是该线性表指定的最大存储容量！<br><a id="more"></a></p><h4 id="在线性表中获取指定位置的元素"><a href="#在线性表中获取指定位置的元素" class="headerlink" title="在线性表中获取指定位置的元素"></a>在线性表中获取指定位置的元素</h4><pre><code>int getElem(SqList list,int index,ElemType* e){if (list.length==0 || index&lt;1 ||index&gt;list.length) {    return 0;}else{    *e = list.data[index];    return 1;}}</code></pre><p>在线性表中获取指定位置的元素，其操作实质是在SqList的data数组中返回指定索引的值；操作中应该避免数组操作引发越界的操作；数组的下标是从0开始的，而线性表的顺序存储是从1开始</p><h4 id="在线性表中指定位置插入数据"><a href="#在线性表中指定位置插入数据" class="headerlink" title="在线性表中指定位置插入数据"></a>在线性表中指定位置插入数据</h4><pre><code> int listInsert(SqList *list,int index,ElemType e){if (index&gt;list-&gt;length+1||index&lt;1) {    return 0;}else{    if (index == list-&gt;length+1) {        list-&gt;data[index-1] = e;        return 1;    }else{        int lastIndex = list-&gt;length;        for (int i = lastIndex; i&gt;=index; i--) {            list-&gt;data[i] = list-&gt;data[i-1];        }        list-&gt;data[index-1] = e ;        list-&gt;length++; //元素插入完毕后增加list的长度        return 1;    }}}   </code></pre><p>  插入操作就是将存储在指定位置后面的所有元素依次向后移动一位；然后指定位置的数据更新为传入的参数，最后将线性表的长度+1；  </p><h4 id="在线性表中指定位置删除数据"><a href="#在线性表中指定位置删除数据" class="headerlink" title="在线性表中指定位置删除数据"></a>在线性表中指定位置删除数据</h4><pre><code> int  listDelete(SqList *list,int index,ElemType* e){if (list-&gt;length==0||index&lt;1||index&gt;list-&gt;length) {    return 0;}*e = list-&gt;data[index-1];for (int i = index; i&lt;list-&gt;length; i++) {    list-&gt;data[i-1] = list-&gt;data[i];}list-&gt;length--;return 1;}</code></pre><p> 在线性表中指定位置删除数据就是将存储在指定位置后面的所有元素依次向前移动一位，最后将线性表的长度+1；    </p><h4 id="SqList-list-与-SqList-list"><a href="#SqList-list-与-SqList-list" class="headerlink" title="SqList *list 与 SqList list"></a>SqList *list 与 SqList list</h4><ul><li>SqList *list 表示声明一个SqList类型的指针，该指针目前未指向任何内存区域，所以是一个野指针；</li><li>SqList list 表示声明了一个SqList类型的变量，在内存中已经开辟了相应的空间；  </li><li>为什么查找操作的时候传入的是list变量而删除和插入传入的是list指针，主要原因首先是结构体是值类型，查找操作传入list变量，在查找函数中存放的其实是list的一个值拷贝；插入和删除操作则要对传入的list做变更操作，所以要传入list指针；  </li></ul><p>关于值类型和引用类型的区分可以考虑 swap(int a,int b);和 swap(int* a,int* b);的区别</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;零个或多个数据元素的有限序列；可以理解为数据按照顺序依次排列，除了头结点和尾结点外其他结点只存在唯一的前继和后继； 例如：平时购票的队伍、从北京到上海的京沪线等；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;线性表的顺序存储结构&quot;&gt;&lt;a href=&quot;#线性表的顺序存储结构&quot; class=&quot;headerlink&quot; title=&quot;线性表的顺序存储结构&quot;&gt;&lt;/a&gt;线性表的顺序存储结构&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;#define MAXSIEZ 20
typedef int ElemType;
typedef struct {
    ElemType data[MAXSIEZ];
    int length;
}SqList;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;线性表的顺序存储结构包含两部分，一个是存储数据的数组，一个实际存储数据元素个数的整型变量；其中MAXSIEZ是该线性表指定的最大存储容量！&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C之属性</title>
    <link href="http://yoursite.com/2017/01/04/Objective-C%E4%B9%8B%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/01/04/Objective-C之属性/</id>
    <published>2017-01-04T10:00:32.000Z</published>
    <updated>2019-01-13T10:54:54.861Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C属性相关内容 </p><h3 id="property关键字的作用"><a href="#property关键字的作用" class="headerlink" title="@property关键字的作用"></a><code>@property</code>关键字的作用</h3><ul><li>生成实例变量 _propertyName</li><li>生成setter方法</li><li>生成getter方法  </li></ul><h3 id="property-特质（会影响编译器生成的存取方法）"><a href="#property-特质（会影响编译器生成的存取方法）" class="headerlink" title="@property 特质（会影响编译器生成的存取方法）"></a><code>@property</code> 特质（会影响编译器生成的存取方法）</h3><ul><li>原子性 : 默认情况下是atomic，确保原子性<ul><li>atomic </li><li>nonatomic</li></ul></li><li>读写<ul><li>readwrite</li><li>readonly</li></ul></li><li>内存管理<ul><li>assign ：基本数据类型</li><li>weak ： 表示非拥有关系，所指对象销毁，会自动置为nil；</li><li>strong ：表示一种拥有属性，为其设置新值时，先保留新值，再释放旧值，然后将新值赋上</li><li>copy ：特质同strong，只是在设置值的时候，不保留新值，而是直接将其copy</li></ul></li><li>方法名： getter=<name></name></li></ul><a id="more"></a><h3 id="自定义初始化方法"><a href="#自定义初始化方法" class="headerlink" title="自定义初始化方法"></a>自定义初始化方法</h3><pre><code>-(instancetype)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName{  if(self = [super init]){  // 避免传入的值是一个可变对象    _firstName = [firstName copy];    _lastName = [lastName copy];  }  return self;}</code></pre><h3 id="当重写setter和getter方法时，编译器会报错-propertyName未定义"><a href="#当重写setter和getter方法时，编译器会报错-propertyName未定义" class="headerlink" title="当重写setter和getter方法时，编译器会报错_propertyName未定义"></a>当重写setter和getter方法时，编译器会报错_propertyName未定义</h3><p>   此时需要使用<code>@synthesize</code>来合成 <code>propertyName = _propertyName；</code><br>   <code>@synthesize</code>另外一个作用是给实例变量取别名 </p><h3 id="dynamic"><a href="#dynamic" class="headerlink" title="@dynamic"></a>@dynamic</h3><p>   告知编译器setter和getter方法不需要自动生成</p><h3 id="在对象内部尽量直接访问实例变量"><a href="#在对象内部尽量直接访问实例变量" class="headerlink" title="在对象内部尽量直接访问实例变量"></a>在对象内部尽量直接访问实例变量</h3><ul><li>可以避免使用存储方法，不经过“方法的派发”</li><li>折中方案（写入使用存储方法，读取直接访问实例变量）</li><li>直接访问实例变量不会触发内存管理语义</li><li>初始化方法中，直接访问实例变量</li><li>惰性加载 </li></ul><h3 id="理解对象等同性"><a href="#理解对象等同性" class="headerlink" title="理解对象等同性"></a>理解对象等同性</h3><pre><code>NSString *foo = @&quot;123&quot;;NSString *bar = [NSString stringWithFormat:@&quot;%i&quot;,123];BOOL equalA = (foo == bar);//equalA = NO,== 比较的是两个指针BOOL equalB = [foo isEqual:bar];//equalB = YES</code></pre><h3 id="使用类族模式（工厂模式）"><a href="#使用类族模式（工厂模式）" class="headerlink" title="使用类族模式（工厂模式）"></a>使用类族模式（工厂模式）</h3><p><code>+ （UIButton*）buttonWithType:(UIButtonType)type</code></p><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><ul><li>objc_setAssociatedObject(object,key,value,policy)</li><li>objc_getAssociatedObject(object,key)</li></ul><p><strong>使用场景</strong>  </p><ul><li>给一些系统类添加属性    </li><li>在分类中添加属性<ul><li>在分类中定义属性</li><li>重写属性的setter和getter方法（使用关联对象）</li></ul></li></ul><h3 id="比较assign和weak的差别"><a href="#比较assign和weak的差别" class="headerlink" title="比较assign和weak的差别"></a>比较assign和weak的差别</h3><ul><li>assign修饰基本数据类型，weak修饰对象类型</li><li>修饰对象使用weak，当对象被释放时，对象指针会被置为nil，使用assign则不会</li></ul><h3 id="深浅拷贝-、自定义对象的拷贝"><a href="#深浅拷贝-、自定义对象的拷贝" class="headerlink" title="深浅拷贝 、自定义对象的拷贝"></a>深浅拷贝 、自定义对象的拷贝</h3><ul><li>copy<ul><li>不可变对象{NSString/NSArray/NSDictionary} : 浅拷贝，堆上不开辟新空间，得到的也是不可变对象</li><li>可变对象 {NSMutableString/NSMutableArray/NSMutableDictionary}:深拷贝，堆上开辟空间，得到的是不可变对象</li></ul></li><li>mutableCopy：对于可变/不可变对象来说都是深拷贝，堆上开辟新空间，得到的是可变对象</li><li>能否对一些不可变对象使用strong关键词修饰？<br>  不可以，当指针从不可变对象，改为指向可变对象时，数据发生改变，可能会造成不可预知的问题</li><li>自定义对象的实现拷贝<ul><li>遵守NSCopying协议</li><li>实现copyWithZone:(NSZone*)zone</li></ul></li></ul><h3 id="copy-strong-MRC下的setter方法重写"><a href="#copy-strong-MRC下的setter方法重写" class="headerlink" title="copy / strong MRC下的setter方法重写"></a>copy / strong MRC下的setter方法重写</h3><ul><li><p>copy</p><pre><code>-(void)setName:(NSString*)name{     _name = [name copy];}</code></pre></li><li><p>strong</p><pre><code>-(void)setName:(NSString*)name{      if(_name!=name){        [_name release];        _name = [name retain];      }  }</code></pre></li></ul><h3 id="分类、协议中属性的使用"><a href="#分类、协议中属性的使用" class="headerlink" title="分类、协议中属性的使用"></a>分类、协议中属性的使用</h3><ul><li><p>分类中正常不能添加属性，但可以通过联合的方式添加</p><pre><code> #import &quot;HZProperty+HZ.h&quot;#import &lt;objc/runtime.h&gt;const void *key = &quot;hobit&quot;;@implementation HZProperty (HZ)-(void)method{    objc_setAssociatedObject(self, &amp;key, @&quot;123&quot;, OBJC_ASSOCIATION_COPY);    NSString * hobit = objc_getAssociatedObject(self, &amp;key);    NSLog(@&quot;==&gt;%@&quot;,hobit);}@end</code></pre></li><li><p>协议中很少使用</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C属性相关内容 &lt;/p&gt;
&lt;h3 id=&quot;property关键字的作用&quot;&gt;&lt;a href=&quot;#property关键字的作用&quot; class=&quot;headerlink&quot; title=&quot;@property关键字的作用&quot;&gt;&lt;/a&gt;&lt;code&gt;@property&lt;/code&gt;关键字的作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;生成实例变量 _propertyName&lt;/li&gt;
&lt;li&gt;生成setter方法&lt;/li&gt;
&lt;li&gt;生成getter方法  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;property-特质（会影响编译器生成的存取方法）&quot;&gt;&lt;a href=&quot;#property-特质（会影响编译器生成的存取方法）&quot; class=&quot;headerlink&quot; title=&quot;@property 特质（会影响编译器生成的存取方法）&quot;&gt;&lt;/a&gt;&lt;code&gt;@property&lt;/code&gt; 特质（会影响编译器生成的存取方法）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;原子性 : 默认情况下是atomic，确保原子性&lt;ul&gt;
&lt;li&gt;atomic &lt;/li&gt;
&lt;li&gt;nonatomic&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;读写&lt;ul&gt;
&lt;li&gt;readwrite&lt;/li&gt;
&lt;li&gt;readonly&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存管理&lt;ul&gt;
&lt;li&gt;assign ：基本数据类型&lt;/li&gt;
&lt;li&gt;weak ： 表示非拥有关系，所指对象销毁，会自动置为nil；&lt;/li&gt;
&lt;li&gt;strong ：表示一种拥有属性，为其设置新值时，先保留新值，再释放旧值，然后将新值赋上&lt;/li&gt;
&lt;li&gt;copy ：特质同strong，只是在设置值的时候，不保留新值，而是直接将其copy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法名： getter=&lt;name&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Swfit-属性&amp;方法</title>
    <link href="http://yoursite.com/2016/02/13/Swfit-%E5%B1%9E%E6%80%A7-%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/02/13/Swfit-属性-方法/</id>
    <published>2016-02-13T11:06:00.000Z</published>
    <updated>2019-01-13T11:06:30.193Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
