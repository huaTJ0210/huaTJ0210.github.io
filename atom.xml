<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>華</title>
  
  <subtitle>人无远虑必有近忧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-29T05:48:05.427Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>华子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序如何运行-二进制</title>
    <link href="http://yoursite.com/2018/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://yoursite.com/2018/10/29/计算机-二进制/</id>
    <published>2018-10-29T03:30:12.000Z</published>
    <updated>2018-10-29T05:48:05.427Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机内部数据和信息是使用二进制来存储的，那么二进制是如何表示信息以及它的运算机制是怎么样的呢？如下有几个问题可以思考一下？  </p><ul><li>32位是几个字节</li><li>二进制01011100转化为十进制是多少</li><li>二进制数00001111左移两位，会变成原来的几倍</li><li>补码形式表示的8位二进制数11111111，用十进制表示的话是多少</li><li>补码形式表示的8位二进制数10101010，用16位的二进制表示的话是多少</li><li>反转部分图形模式，使用的是什么逻辑  </li></ul><p>以上问题如果不能清晰的回答那么就需要了解一下二进制的基础知识了。<br><a id="more"></a></p><h4 id="二进制表示计算机信息的原因"><a href="#二进制表示计算机信息的原因" class="headerlink" title="二进制表示计算机信息的原因"></a>二进制表示计算机信息的原因</h4><p>二进制<strong>计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”</strong><br>由于计算机内部是由<em>集成电路（integrated circuit)</em>这种电子部件构成，IC只有两种状态，0V和5V，即有电流和无电流两种模式； 计算机处理信息最小的单元是位，二进制的位数一般是8位、16位、32位、也就是8的倍数，8位二进制数被称为一个字节， 内存和磁盘都是以字节单位来存储和读写数据的，因此字节是信息的基本单位。  </p><h4 id="二进制如何同十进制之间进行转化"><a href="#二进制如何同十进制之间进行转化" class="headerlink" title="二进制如何同十进制之间进行转化"></a>二进制如何同十进制之间进行转化</h4><p>先要了解一下位权的概念，首先了解十进制的位权，例如39十位上3的位权是10，个位9的位权是1，那么39的表示就是3x10+9x1 = 39；同样的二进制也是，例如101从右侧向左 1x2^0 + 0x2^1 + 1x2^1。这样二进制转化为十进制，只需要各个数位上的数字与位权相乘然后相加即可。<br>十进制转化为二进制，根据逢<code>二进一</code>的原则，利用短除法求余数的方式可以转化。 </p><h4 id="移位运算和乘除运算的关系"><a href="#移位运算和乘除运算的关系" class="headerlink" title="移位运算和乘除运算的关系"></a>移位运算和乘除运算的关系</h4><p>移位运算指的是将二进制数的各个数位进行左移或右移的操作。其中左移运算符<code>&lt;&lt;</code>,右移的运算符<code>&gt;&gt;</code>,移位运算代替乘除法，十进制左移会变成原来10倍、100倍、1000倍…同样在不考虑符号位的情况下二进制左移后会变成原来的2倍、4倍、8倍，相反右侧移动会变成1/2、1/4、1/8…</p><h4 id="便于计算机处理的补数-补码"><a href="#便于计算机处理的补数-补码" class="headerlink" title="便于计算机处理的补数(补码)"></a>便于计算机处理的补数(补码)</h4><p>二进制表示负数时会把最高位作为符号位来使用，因此最高位也被称为符号位，符号位为0表示正数，符号位为1表示负数；计算机中进行减法操作其实也是按照加法操作进行的；那么如何使用8位二进制来表示-1呢：  </p><pre><code>如何用二进制表示负数-1第一步： 取1的8位二进制表示 ： 00000001第二步：按位取反：   11111110第三步：执行+1操作： 11111111得到的11111111就是-1的8位二进制</code></pre><h4 id="逻辑右移和算术右移的区别"><a href="#逻辑右移和算术右移的区别" class="headerlink" title="逻辑右移和算术右移的区别"></a>逻辑右移和算术右移的区别</h4><p>关于逻辑右移：右移后左侧空位用0填充，而算术右移动：空出来的高位用符号位上的数字填充，下面看一下-4右移2位得到-1；</p><pre><code>-4 ：11111100  先右移2位得到111111，高位使用符号位数字填充11，就得到了-1 ：11111111</code></pre><p>关于符号扩充：保持值不变的情况下，将8位二进制准话为16位或是32位，不管正数还是负数都使用符号位上的数字去扩充高位即可。</p><h4 id="掌握逻辑运算的窍门"><a href="#掌握逻辑运算的窍门" class="headerlink" title="掌握逻辑运算的窍门"></a>掌握逻辑运算的窍门</h4><p>逻辑运算包含如下几种：  </p><ul><li>逻辑非 NOT ： 0变成1，1变成0</li><li>逻辑与  AND：两个都为1才是1，否则为0</li><li>逻辑或  OR ： 至少有一方为1，结果为1，其他为0 </li><li>逻辑异或 XOR： 排斥相同数值的运算，相同为0，不同为1  </li></ul><h4 id="对为文章开头问题的解答"><a href="#对为文章开头问题的解答" class="headerlink" title="对为文章开头问题的解答"></a>对为文章开头问题的解答</h4><ul><li>32位是几个字节 ：8个</li><li>二进制01011100转化为十进制是多少 ： 92</li><li>二进制数00001111左移两位，会变成原来的几倍 ： 4倍</li><li>补码形式表示的8位二进制数11111111，用十进制表示的话是多少 ： -1</li><li>补码形式表示的8位二进制数10101010，用16位的二进制表示的话是多少 ： 1111111110101010</li><li>反转部分图形模式，使用的是什么逻辑  ：XOR（异或）  </li></ul><blockquote><p>资料来源  </p></blockquote><p> <strong>程序是怎么跑起来的–《数据是用二进制表示的》</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机内部数据和信息是使用二进制来存储的，那么二进制是如何表示信息以及它的运算机制是怎么样的呢？如下有几个问题可以思考一下？  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32位是几个字节&lt;/li&gt;
&lt;li&gt;二进制01011100转化为十进制是多少&lt;/li&gt;
&lt;li&gt;二进制数00001111左移两位，会变成原来的几倍&lt;/li&gt;
&lt;li&gt;补码形式表示的8位二进制数11111111，用十进制表示的话是多少&lt;/li&gt;
&lt;li&gt;补码形式表示的8位二进制数10101010，用16位的二进制表示的话是多少&lt;/li&gt;
&lt;li&gt;反转部分图形模式，使用的是什么逻辑  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上问题如果不能清晰的回答那么就需要了解一下二进制的基础知识了。&lt;br&gt;
    
    </summary>
    
      <category term="程序如何运行" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>程序如何运行-cpu简述</title>
    <link href="http://yoursite.com/2018/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA-cpu%E7%AE%80%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/10/28/计算机-cpu简述/</id>
    <published>2018-10-28T03:03:08.000Z</published>
    <updated>2018-10-29T05:45:05.816Z</updated>
    
    <content type="html"><![CDATA[<p>在日常使用高级编程语言进行编程时，是否考虑过以下问题：   </p><ul><li>程序是什么</li><li>程序的组成部分</li><li>什么是机器语言</li><li>运行的程序在计算机中的存储位置</li><li>内存地址是什么</li><li>负责程序解析和运行的是哪个</li></ul><a id="more"></a>  <p>如果以上的概念不能很清楚的描述出来，那么就需要了解一下对程序员来讲CPU是什么了。<br>对于CPU的解析首先需要知道程序的运行流程：使用一些高级语言<code>C</code>、<code>JAVA</code>、<code>Objective-C</code>等编写的程序 —-&gt; 编译器会将源码编译为机器语言的可执行文件 —-&gt; 程序运行后会将可执行文件加载到内存中形成副本 —-&gt; CPU解释并执行程序内容 【转化成的机器语言其实是由CPU中的寄存器来处理的】；例如 a = 1 + 2 这样的运算，转化为机器语言后是通过寄存器进行相加运算和存储的。  </p><h4 id="CPU的组成部分"><a href="#CPU的组成部分" class="headerlink" title="CPU的组成部分"></a>CPU的组成部分</h4><p>CPU是中央处理器，负责计算机的控制和运算，它主要包含以下4个部分： </p><ul><li>寄存器：暂时存储指令、数据处理对象【一个CPU会包含20~100个寄存器】</li><li>控制器：把内存上的指令、数据读入寄存器，并根据指令的执行结果来控制计算机【控制器的控制内容：控制键盘、鼠标和内存媒介的输入输出】</li><li>运算器：负责把从内存读到寄存器中的指令和数据进行运算</li><li>时钟： 负责发出CPU开始计时的时钟信号</li></ul><h4 id="程序运行机制中CPU的各部分都起到了哪些作用"><a href="#程序运行机制中CPU的各部分都起到了哪些作用" class="headerlink" title="程序运行机制中CPU的各部分都起到了哪些作用"></a>程序运行机制中CPU的各部分都起到了哪些作用</h4><p>程序启动 —&gt; 根据时钟信号 —&gt; 控制器从内存中读取指令和数据【对指令进行解释和执行】—&gt; 运算器对指令进行运算 —&gt; 控制器根据运算结果控制计算器 </p><h4 id="寄存器简介"><a href="#寄存器简介" class="headerlink" title="寄存器简介"></a>寄存器简介</h4><p>寄存器用来存储指令、数据处理对象，按照使用功能的不同大致分为8类：  </p><ul><li>累加寄存器：负责存储运算数据和运算的结果数据</li><li>基址寄存器：存储数据内存的起始地址</li><li>标志寄存器： 存储运算处理后的CPU的状态</li><li>指令寄存器 ：存储指令</li><li>栈寄存器  ： 存储栈区域的起始地址</li><li>通用寄存器 ： 存储任意数据</li><li>变址寄存器 ： 存储基地址寄存器的相对地址</li><li>程序计数器：存储下一条指令所在的内存地址</li></ul><h4 id="决定程序流程-–-程序计数器"><a href="#决定程序流程-–-程序计数器" class="headerlink" title="决定程序流程 – 程序计数器"></a>决定程序流程 – 程序计数器</h4><p>程序计数器中存储的是程序的执行指令，CPU的控制器会参照程序计数器中存储的内存地址，去查找相应的指令去执行</p><h4 id="条件分支和循环机制"><a href="#条件分支和循环机制" class="headerlink" title="条件分支和循环机制"></a>条件分支和循环机制</h4><p>CPU进行运算时，标志寄存器的数值会根据运算结果自动设定，条件分支在跳转指令前会进行比较运算  </p><h4 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h4><p>如何解决函数内部执行完毕后，CPU继续执行函数入口地址下一个程序计数器中存储的指令：使用机器语言的call指令和return指令可以解决：  </p><ul><li>call指令：会把调用函数后要执行的指令地址存在栈中，函数执行完毕后再函数的出口执行return指令；  </li><li>return指令：把保存在栈中指令设置到程序计数器中   </li></ul><h4 id="机器语言指令的主要类型和功能"><a href="#机器语言指令的主要类型和功能" class="headerlink" title="机器语言指令的主要类型和功能"></a>机器语言指令的主要类型和功能</h4><ul><li>数据传送指令：寄存器和内存、内存和内存、寄存器和外围设备之间的数据读写操作</li><li>运算指令 ： 累加寄存器执行算数运算、逻辑运算、比较运算和位移运算</li><li>跳转指令： 实现条件分支、循环、强制跳转等</li><li>call/return指令 ： 函数的调用/返回调用前的地址</li></ul><h4 id="对文章开头问题进行解答"><a href="#对文章开头问题进行解答" class="headerlink" title="对文章开头问题进行解答"></a>对文章开头问题进行解答</h4><ul><li>程序是什么 ：指导计算机执行操作的一组指令集</li><li>程序的组成部分 ： 指令和数据</li><li>什么是机器语言 ： CPU能够理解和执行的语言</li><li>运行的程序在计算机中的存储位置 ：内存</li><li>内存地址是什么 ： 代表数据和指令在内存中位置的整数值</li><li>负责程序解析和运行的是哪个 ： CPU  </li></ul><blockquote><p>资料来源  </p></blockquote><p> <strong>程序是怎么跑起来的–《对程序员来说CPU是什么》</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常使用高级编程语言进行编程时，是否考虑过以下问题：   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序是什么&lt;/li&gt;
&lt;li&gt;程序的组成部分&lt;/li&gt;
&lt;li&gt;什么是机器语言&lt;/li&gt;
&lt;li&gt;运行的程序在计算机中的存储位置&lt;/li&gt;
&lt;li&gt;内存地址是什么&lt;/li&gt;
&lt;li&gt;负责程序解析和运行的是哪个&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="程序如何运行" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/"/>
    
    
      <category term="计算机基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Swift-Swift4弱引用的实现总结篇</title>
    <link href="http://yoursite.com/2018/09/27/Swift-%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93%E7%AF%87/"/>
    <id>http://yoursite.com/2018/09/27/Swift-弱引用的实现总结篇/</id>
    <published>2018-09-27T07:01:14.000Z</published>
    <updated>2018-09-27T14:11:30.661Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>知识小集</code>上读到一篇Swift GG 团队翻译Mike Ash的Swift 4 弱引用实现，其中提及到<code>对象的内存存储</code>、<code>引用计数的存储</code>、<code>关联对象的存储</code>、<code>Side Table</code>等内容，特做一下笔记记录并把模糊的概念梳理清楚；  </p><h4 id="Swift弱引用旧实现"><a href="#Swift弱引用旧实现" class="headerlink" title="Swift弱引用旧实现"></a>Swift弱引用旧实现</h4><p>Swift对象有两个引用计数：强引用计数和弱引用计数；当强引用计数为0时，系统会将对象清理；但是此时若弱引用计数不为0则对象所在的内存空间不会被清理，造成僵尸对象的存在；<br>再次使用弱引用指针时，如果检测指向的为僵尸对象，则将弱引用-1，直至弱引用为0的时候才会将僵尸对象清理；这种实现机制会造成内存空间的浪费；另外一个缺陷是并发读取非线程安全。<br><a id="more"></a></p><h4 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h4><ul><li>源码中可以直接访问的存储属性</li><li>对象的类信息</li><li>各种引用计数信息</li><li>Objective-C运行时存储的辅助信息（弱引用表和关联对象）</li></ul><p>以上四类其中类信息和存储属性内联在对象内存中，辅助类信息存在外部表中；关联对象较为特殊它存在一个全局的哈希表中；而引用计数又会根据操作系统和CPU架构的使用 <code>TaggedPointer</code>、 <code>NONPOINTER_ISA</code> 、<code>散列表</code>等进行存储</p><h4 id="Side-Tables"><a href="#Side-Tables" class="headerlink" title="Side Tables"></a>Side Tables</h4><p>在Swift弱引用的新版实现中引入了Side Tables ，把弱引用指针由指向原对象改为指向Side Table；这样就解决了强引用计数为0时，存储对象的内存空间未能被及时的释放的问题；    </p><blockquote><p>资料来源  </p></blockquote><p><a href="https://mp.weixin.qq.com/s/PWDbya8sa_ltnD1EG8UXiA" target="_blank" rel="external">Swift 4 弱引用实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;知识小集&lt;/code&gt;上读到一篇Swift GG 团队翻译Mike Ash的Swift 4 弱引用实现，其中提及到&lt;code&gt;对象的内存存储&lt;/code&gt;、&lt;code&gt;引用计数的存储&lt;/code&gt;、&lt;code&gt;关联对象的存储&lt;/code&gt;、&lt;code&gt;Side Table&lt;/code&gt;等内容，特做一下笔记记录并把模糊的概念梳理清楚；  &lt;/p&gt;
&lt;h4 id=&quot;Swift弱引用旧实现&quot;&gt;&lt;a href=&quot;#Swift弱引用旧实现&quot; class=&quot;headerlink&quot; title=&quot;Swift弱引用旧实现&quot;&gt;&lt;/a&gt;Swift弱引用旧实现&lt;/h4&gt;&lt;p&gt;Swift对象有两个引用计数：强引用计数和弱引用计数；当强引用计数为0时，系统会将对象清理；但是此时若弱引用计数不为0则对象所在的内存空间不会被清理，造成僵尸对象的存在；&lt;br&gt;再次使用弱引用指针时，如果检测指向的为僵尸对象，则将弱引用-1，直至弱引用为0的时候才会将僵尸对象清理；这种实现机制会造成内存空间的浪费；另外一个缺陷是并发读取非线程安全。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-《软技能》事业篇</title>
    <link href="http://yoursite.com/2018/08/18/%E8%AF%BB%E3%80%8A%E8%BD%AF%E6%8A%80%E8%83%BD%E3%80%8B/"/>
    <id>http://yoursite.com/2018/08/18/读《软技能》/</id>
    <published>2018-08-18T09:37:48.000Z</published>
    <updated>2018-08-18T12:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>  《软技能》一书旨在让开发人员如何成为一名优秀的工程师，它涉及的主要七个方面：  </p><ul><li>事业</li><li>自我营销</li><li>学习</li><li>生产力</li><li>理财</li><li>身体</li><li>精神</li></ul><a id="more"></a>  <h2 id="事业"><a href="#事业" class="headerlink" title="事业"></a>事业</h2><p>   《软技能》中提出<strong>你所犯的最大的错误就是相信自己是在为别人工作。这样一来你对工作的安全感已燃尽。职业的驱动力一定是来自个体本身。</strong>      </p><p>文章中指出多数软件开发者所犯的最大的错误在于没有把软件开发当成一桩生意来看。职业规划应该像管理企业一样制定最优的决策和保证生产力的持续提升。所以应该把你现在的公司当做你的一个客户，然后像企业一样去思考，时刻去想作为一个企业我能提供什么，这样你的工作方式、处理自己财务的方式、需求新工作的方式都会得到改变。</p><h3 id="你的目标是什么"><a href="#你的目标是什么" class="headerlink" title="你的目标是什么"></a>你的目标是什么</h3><p>软件开发工程师要确定自己的目标，初级、中级、高级、资深等，还是走管理路线，你要确定自己的目标；<br>设立目标，这个很关键，为职业生涯设立一个大目标然后去拆分，月目标、周目标，时刻让自己知道在追求什么</p><h3 id="人际交往能力"><a href="#人际交往能力" class="headerlink" title="人际交往能力"></a>人际交往能力</h3><p>软件开发者整体给人的印象就是呆板不容易沟通，<strong>别管我，我只想一个人安静的写代码</strong>这句话同行们都应该说过。实际上软件开发就是与他人打交道的过程，假象你研发的东西没人使用，那他的意义在于什么呢？我们在工作中会与产品、测试、业务、运营等人员沟通，所以沟通是极其重要的。那么如何与人打交道，以下几点很受用：  </p><ul><li>每个人都希望感到自己很重要</li><li>永远不要批评</li><li>换位思考</li><li>避免争吵</li></ul><h3 id="破解面试之道"><a href="#破解面试之道" class="headerlink" title="破解面试之道"></a>破解面试之道</h3><ul><li>个人博客和github对于研发人员很重要，当面试官看过你的博客，那么面试成功率就会很大；   </li><li>突破常规从期待加入公司的员工入手，建立联系，简历走内部推荐模式；</li><li>确保自己仍旧保持技术能力，如果你力所不及，那么所有的面试技巧都不会帮助到你；</li><li>即使不换新工作也要出去面试，获取面试的经验，这样你真正面试的时候就会游刃有余；  </li></ul><h3 id="就业选择"><a href="#就业选择" class="headerlink" title="就业选择"></a>就业选择</h3><p>一个软件开发工程师可以从事哪些工作:   </p><ul><li>雇员 </li><li>独立咨询师</li><li>创业者</li></ul><h3 id="你是哪类开发人员"><a href="#你是哪类开发人员" class="headerlink" title="你是哪类开发人员"></a>你是哪类开发人员</h3><p>我们在选择律师的时候会根据具体的案件去选择，软件开发工程师也是你需要在自己的专业领域做的卓越，开发人员的专业领域包含：   </p><ul><li>Web开发栈</li><li>嵌入式系统</li><li>特定操作系统</li><li>移动开发</li><li>框架</li><li>软件系统</li></ul><h3 id="公司与公司是不一样"><a href="#公司与公司是不一样" class="headerlink" title="公司与公司是不一样"></a>公司与公司是不一样</h3><p>你选择的任职公司会影响你的整体幸福感、存在感和归属感；比较一下不同种类公司的优缺点</p><table><thead><tr><th>公司规模</th><th>优点</th><th>缺点  </th></tr></thead><tbody><tr><td>小公司</td><td>承担多种职责，灵活的角色转换，汇报潜力大</td><td>没法安静的写代码，稳定性差</td></tr><tr><td>中等公司</td><td>工作稳定，加班少</td><td>变化很慢，没有机会使用新技术</td></tr><tr><td>大公司</td><td>完备的流程化，培训机会多，大型有影响力的作用</td><td>充斥官僚作风，可能只负责代码库的一小部分</td></tr></tbody></table><p>在选择公司的时候要权衡利弊，多花时间思考自己喜欢在什么样的环境下工作，多大的规模符合你自己理想的工作环境   </p><h3 id="攀登晋升阶梯"><a href="#攀登晋升阶梯" class="headerlink" title="攀登晋升阶梯"></a>攀登晋升阶梯</h3><ul><li>承担更多的责任</li><li>引人注目  <ul><li>提供演讲和培训</li><li>发表意见</li><li>保证“曝光度”</li></ul></li><li>自学 <ul><li>参加培训</li><li>考取证书</li><li>继续深造 </li></ul></li><li>成为问题的解决者<ul><li>如果你能解决别人不能解决的问题，你就能轻而易举成为最有价值的人</li></ul></li><li>关于政治  <ul><li>保持警惕之心</li><li>脚踏实地</li></ul></li></ul><p>在晋升之路上，自学占有很大比重的，要确定自学的最有价值的东西是什么，然后指定计划去执行；  </p><h3 id="成为专业人士"><a href="#成为专业人士" class="headerlink" title="成为专业人士"></a>成为专业人士</h3><blockquote><p>专业人士严肃对待自己的责任和事业，愿意做出艰难的选择去做自己认为正确的事情–往往还要自己承担代价  </p></blockquote><p>如何成为专业人士：首先你要养成良好的习惯；你是否有自己的时间管理计划呢？第二天的工作内容是什么，你是如何安排的等等。追求品质，完善自我；工作的完成分为很多等级，开发人员应该极力追求质量的控制；想象一下你提交的版本有问题会引发多少连锁的反应，测试工程师，运维工程师等等都会受到牵连，所以交付质量非常重要；<br>成为专业人员是一个持续性的过程，要有很好的耐性。 </p><h3 id="假装自己能成功"><a href="#假装自己能成功" class="headerlink" title="假装自己能成功"></a>假装自己能成功</h3><p>假装自己能成功是一个自我暗示，能让自己增强自信心；我们都会面对困境–接到的任务自己一无所知，会感到不自在，无能为力。消除这种情绪就要“假装自己能成功”；<br>这个技巧同时适用于面试阶段，碰到不会的问题，可以表现自己有信心解决。但一定不能表现为自大。</p><h3 id="请勿陷入技术狂热"><a href="#请勿陷入技术狂热" class="headerlink" title="请勿陷入技术狂热"></a>请勿陷入技术狂热</h3><p>天生一物必有用，php是最好的语言可以当成个调侃，但不要去比对不同语言的孰好孰坏，一定要争论个第一出来，其实完全没有意义。我们应该对技术保持开放的心态，而不是固守自己已经了解的技术。突破于此你就会发现更多的机会向你涌来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  《软技能》一书旨在让开发人员如何成为一名优秀的工程师，它涉及的主要七个方面：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事业&lt;/li&gt;
&lt;li&gt;自我营销&lt;/li&gt;
&lt;li&gt;学习&lt;/li&gt;
&lt;li&gt;生产力&lt;/li&gt;
&lt;li&gt;理财&lt;/li&gt;
&lt;li&gt;身体&lt;/li&gt;
&lt;li&gt;精神&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随感" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA</title>
    <link href="http://yoursite.com/2018/07/21/IntelliJ-IDEA-%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/07/21/IntelliJ-IDEA-安装/</id>
    <published>2018-07-21T07:57:54.000Z</published>
    <updated>2018-08-18T02:03:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h3><blockquote><p>IDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言。  </p></blockquote><p><a href="https://confluence.jetbrains.com/display/IDEADEV/IDEA+2018.1+EAP" target="_blank" rel="external">download</a>    </p><a id="more"></a> <h3 id="license-server-address"><a href="#license-server-address" class="headerlink" title="license server address"></a>license server address</h3><p>失效可以更换其他的地址 </p><ul><li><a href="http://idea.java.sx/" target="_blank" rel="external">http://idea.java.sx/</a></li><li><a href="http://idea.congm.in/" target="_blank" rel="external">http://idea.congm.in/</a></li><li><a href="http://idea.toocruel.net" target="_blank" rel="external">http://idea.toocruel.net</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IntelliJ-IDEA&quot;&gt;&lt;a href=&quot;#IntelliJ-IDEA&quot; class=&quot;headerlink&quot; title=&quot;IntelliJ IDEA&quot;&gt;&lt;/a&gt;IntelliJ IDEA&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;IDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持HTML，CSS，PHP，MySQL，Python等。免费版只支持Java等少数语言。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://confluence.jetbrains.com/display/IDEADEV/IDEA+2018.1+EAP&quot;&gt;download&lt;/a&gt;    &lt;/p&gt;
    
    </summary>
    
      <category term="IDE" scheme="http://yoursite.com/categories/IDE/"/>
    
    
      <category term="IDE" scheme="http://yoursite.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>iOS篇-页面优化（-）</title>
    <link href="http://yoursite.com/2018/07/04/iOS%E7%AF%87-%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%EF%BC%88-%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/04/iOS篇-页面优化（-）/</id>
    <published>2018-07-04T14:57:54.000Z</published>
    <updated>2018-07-08T04:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文主要涉及到的知识点："><a href="#本文主要涉及到的知识点：" class="headerlink" title="本文主要涉及到的知识点："></a>本文主要涉及到的知识点：</h3><ul><li>图像显示原理  </li><li>CPU和GPU的职责</li><li>UI卡顿掉帧的原因</li><li>视图的绘制</li><li>视图的异步绘制</li><li>离屏渲染</li><li>性能优化的集合  </li></ul><a id="more"></a><h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><p>CPU和GPU两个硬件通过总线相连接，CPU负责视图的计算，GPU负责视图渲染，GPU将渲染的位图提交给帧缓冲区（frame buffer），视频控制器接收到VSync信号后将位图在显示器上显示；<br><img src="https://upload-images.jianshu.io/upload_images/117735-1f696b1bc58ad56f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图像显示原理.png">    </p><p><strong>对应具体视图的显示</strong><br><img src="https://upload-images.jianshu.io/upload_images/117735-b1a696a84cd46d7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.39.30.png"></p><h3 id="CPU和GPU的职责"><a href="#CPU和GPU的职责" class="headerlink" title="CPU和GPU的职责"></a>CPU和GPU的职责</h3><p> <strong>CPU的主要职责</strong>    </p><ul><li>Layout -&gt; UI布局【自动布局】、文本计算</li><li>Display -&gt; 绘制【Core Graphics绘制：为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢】</li><li>Prepare -&gt; 图片的编解码【PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸;iOS只有在真正绘制的时候才去解压】</li><li>Commit -&gt; 将位图提交给GPU  </li></ul><p><strong>GPU的主要职责</strong>   </p><ul><li>将图层内容渲染到屏幕上   </li></ul><p><strong>影响GPU的操作</strong>    </p><ul><li>太多的几何结构，视图层级复杂</li><li>重绘：由重叠的半透明图层引起 </li><li>离屏绘制：不能直接在屏幕上绘制，必须绘制到离屏图片上下文中  </li><li>过大的图片  </li></ul><h3 id="UI卡顿掉帧的原因"><a href="#UI卡顿掉帧的原因" class="headerlink" title="UI卡顿掉帧的原因"></a>UI卡顿掉帧的原因</h3><p>在页面滑动流畅一般是60FPS，也就是16.7ms要产生一帧的图像渲染出来，如果CPU+GPU在一次VSync信号结束的16.7ms内没有产生一个帧图像在屏幕中显示就会产生卡顿掉帧；<br><img src="https://upload-images.jianshu.io/upload_images/117735-a22f468c86495bbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.44.28.png">  </p><h3 id="视图的绘制"><a href="#视图的绘制" class="headerlink" title="视图的绘制"></a>视图的绘制</h3><p>如下图所示，UIView在接收到setNeedsDisplay的时候并不会直接进行视图的绘制工作，而是等整个流程走完，在当前runloop快结束的时候才会调用setNeedsDisplay标记的视图的drawRect方法<br><img src="https://upload-images.jianshu.io/upload_images/117735-4977b484d21e0045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午9.54.03.png">  </p><p><img src="https://upload-images.jianshu.io/upload_images/117735-8b1ebc403dec24c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午10.02.06.png"></p><h3 id="视图的异步绘制"><a href="#视图的异步绘制" class="headerlink" title="视图的异步绘制"></a>视图的异步绘制</h3><p><img src="https://upload-images.jianshu.io/upload_images/117735-52c1e98b800ef016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2018-07-04 下午10.06.29.png"></p><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p><strong>GPU的渲染分为两种</strong>   </p><ul><li>On-Screen Rendering (当前屏幕渲染)：GPU的渲染是在当前用于显示的屏幕缓冲区进行的  </li><li>Off-Screen Rendering（离屏渲染）：GPU在当前屏幕缓冲区以外开辟一个缓存区进行渲染操作</li></ul><p><strong>离屏渲染的坏处</strong>  </p><ul><li>创建新缓冲区：要进行离屏渲染，首先要创建一个新的缓冲区  </li><li>上下文切换：离屏渲染的整个过程，要多次切换上下文，On-Screen -&gt; Off-Screen ,当离屏渲染结束后要将渲染结果显示，需要将上下文再次切换回来，而上下文的切换代价很大  </li></ul><p><strong>会触发离屏渲染的操作</strong>   </p><ul><li>为图层设置遮罩（layer.mask）</li><li>layer.masksToBounds/view.clipsToBounds 设置为true</li><li>layer.opacity小于1.0</li><li>layer.shadow</li><li>layer.cornerRadius</li><li>drawRect中进行绘制  </li></ul><p><strong>如何优化离屏渲染</strong>  </p><ul><li>控件圆角的设置：CAShaperLayer/Core Graphics 结合UIBezierPath 绘制圆角 </li><li>阴影的绘制：设置shadowPath</li><li>使用instrument的Core Animation检测：图层的离屏渲染、图层是否透明</li></ul><h3 id="性能优化的集合"><a href="#性能优化的集合" class="headerlink" title="性能优化的集合"></a>性能优化的集合</h3><ul><li>避免使用CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:<br>原因：实现这两个方法中的其中之一就必须需要一个绘制上下文，这个上下文的大小基本和原有图层的内存占有量一致；所以重绘的代价太高 </li><li>对于Core Graphics 可以使用CAShapLayer来替换绘制图形、直线和曲线，使用CATextLayer绘制文本，CAGradientLayer绘制渐变 </li><li>列表加载远程图片，直接加载会导致界面卡顿；因为图片资源大，导致加载时间长；在另外的线程中加载图片，在主线程中更新显示内容【SDWebImageView】</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文主要涉及到的知识点：&quot;&gt;&lt;a href=&quot;#本文主要涉及到的知识点：&quot; class=&quot;headerlink&quot; title=&quot;本文主要涉及到的知识点：&quot;&gt;&lt;/a&gt;本文主要涉及到的知识点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;图像显示原理  &lt;/li&gt;
&lt;li&gt;CPU和GPU的职责&lt;/li&gt;
&lt;li&gt;UI卡顿掉帧的原因&lt;/li&gt;
&lt;li&gt;视图的绘制&lt;/li&gt;
&lt;li&gt;视图的异步绘制&lt;/li&gt;
&lt;li&gt;离屏渲染&lt;/li&gt;
&lt;li&gt;性能优化的集合  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS篇-AutoreleasePool的实现原理</title>
    <link href="http://yoursite.com/2018/04/19/iOS%E7%AF%87-AutoreleasePool%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/19/iOS篇-AutoreleasePool的实现原理/</id>
    <published>2018-04-19T10:32:59.000Z</published>
    <updated>2018-08-20T13:10:10.100Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲述以下几个问题：  </p><ul><li>AutoreleasePool的实现原理</li><li>AutoreleasePool的嵌套</li><li>AutoreleasePool在MRC和ARC下的区别【待】</li><li>Autorelease的实现原理</li></ul><a id="more"></a>    <h3 id="AutoreleasePool的实现原理"><a href="#AutoreleasePool的实现原理" class="headerlink" title="AutoreleasePool的实现原理"></a>AutoreleasePool的实现原理</h3><p>AutoreleasePool的实现是以AutoreleasePoolPage（栈结构）为结点通过双向链表的形式组合而成的；</p><p>在ARC下使用<code>@autoreleasePool{}</code>编译器会将代码改写为如下：  </p><pre><code>void* ctx = objc_autoreleasePoolPush();// 业务代码objc_autoreleasePoolPop(ctx);   </code></pre><p><code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>实际调用了AutoreleasePoolPage的<code>push()</code>和<code>pop()</code>方法；   </p><p>首先看一下AutoreleasePoolPage的数据结构：   </p><pre><code>{  id *next;  AutoreleasePoolPage* const parent;  AutoreleasePoolPage* const child;  pthread_t const thread;}      栈顶【          】 &lt;-低地址         【 ...      】 next -&gt; 【待插入的Autorelease对象的位置          】          【nil(哨兵)】 &lt;- AutoreleasePoolPage::push()         【 id obj2  】 栈底部 -&gt;【 id obj1  】         【 AutoreleasePoolPage 自身占用的地址 】&lt;-  高地址</code></pre><h4 id="AutoreleasePoolPage执行push-操作"><a href="#AutoreleasePoolPage执行push-操作" class="headerlink" title="AutoreleasePoolPage执行push()操作"></a>AutoreleasePoolPage执行push()操作</h4><p>AutoreleasePoolPage执行<code>push()</code>操作会创建一个自动释放池，并在next指针的位置插入一个哨兵对象，用来标记新创建的AutoreleasePool的边界；</p><h3 id="Autorelease的实现原理"><a href="#Autorelease的实现原理" class="headerlink" title="Autorelease的实现原理"></a>Autorelease的实现原理</h3><p>向对象发送autorelease消息，系统首先会判断next指针是否指向了栈顶，如果没有会将对象指针存储在next指针位置，并且会把next指针向后移动；如果next指针指向了栈顶，就会增加一个栈结点；然后再进行对象指针的存储和next指针后移的操作；</p><h4 id="AutoreleasePoolPage执行pop-操作"><a href="#AutoreleasePoolPage执行pop-操作" class="headerlink" title="AutoreleasePoolPage执行pop()操作"></a>AutoreleasePoolPage执行pop()操作</h4><p>AutoreleasePoolPage执行<code>pop()</code>操作,会进行如下操作  </p><ul><li>根据哨兵对象（AutoreleasePoolPage执行<code>push()</code>操作返回的对象）找到相应位置</li><li>给上次<code>push()</code>操作之后的添加的对象依次发送release消息</li><li>回退next指针到正确的位置</li></ul><h3 id="AutoreleasePool在MRC和ARC下的区别-？"><a href="#AutoreleasePool在MRC和ARC下的区别-？" class="headerlink" title="AutoreleasePool在MRC和ARC下的区别  ？"></a>AutoreleasePool在MRC和ARC下的区别  ？</h3><h4 id="AutoreleasePool为什么会以双向链表的方式实现"><a href="#AutoreleasePool为什么会以双向链表的方式实现" class="headerlink" title="AutoreleasePool为什么会以双向链表的方式实现"></a>AutoreleasePool为什么会以双向链表的方式实现</h4><pre><code>// Pool1@autoreleasePool{  // Pool2   @autoreleasePool{   } } // Pool3@autoreleasePool{}  </code></pre><p>Pool的创建顺序：Pool 1 —&gt; Pool 2 —&gt; Pool 3，drain顺序是Pool 2 —&gt; Pool 1 —&gt;Pool 3，如果要想实现这种顺序，采取FIFO做不到，普通的栈也不行。如果用链表操作可以做到，因为涉及到链表的首（Pool 2）或尾（Pool 3）插入，应该用双向链表来管理才合适</p><h3 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h3><ul><li><a href="https://blog.csdn.net/lizitao/article/details/56485100" target="_blank" rel="external">Autorelease Pool的实现原理总结</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI" target="_blank" rel="external">Using Autorelease Pool Blocks</a></li><li><a href="http://www.cocoachina.com/ios/20150610/12093.html" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要讲述以下几个问题：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AutoreleasePool的实现原理&lt;/li&gt;
&lt;li&gt;AutoreleasePool的嵌套&lt;/li&gt;
&lt;li&gt;AutoreleasePool在MRC和ARC下的区别【待】&lt;/li&gt;
&lt;li&gt;Autorelease的实现原理&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS篇-weak的实现原理</title>
    <link href="http://yoursite.com/2018/04/19/iOS%E7%AF%87-weak%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/19/iOS篇-weak的实现原理/</id>
    <published>2018-04-19T10:32:59.000Z</published>
    <updated>2018-08-19T11:18:44.410Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲述weak指针如何被插入到弱引用数组和在所指对象被释放有事如何被置为nil的：</p><p>实际开发过程中使用weak关键字来修饰对象是为了避免引用循环（delegate等）；<br>同时weak指针在对象被释放后还会自动置为nil，接下来我们看一下系统是如何实现weak操作的；</p><p><code>id __weak weakObj = obj</code>经过编译器会成如下：  </p><pre><code>{  id weakObj;  objc_initWeak(&amp;weakObj,obj);}  </code></pre><p>通过查看源码，函数的调用顺序如下 <code>objc_initWeak()</code> ===&gt;<code>storeWeak（）</code>  ===&gt; <code>weak_register_no_lock()</code><br><a id="more"></a><br>将weakObj插入到弱引用表的流程如下：  </p><ul><li>iOS内存管理的一种方式是采取散列表（SideTables），通过obj对象在SideTables中找到存储obj内存管理相关信息的SideTable</li><li>获取在SideTable的弱引用表（weak_table_t * weak_table）</li><li><p>通过hash函数（hash(obj)）在弱引用表中找到对象存储的弱引用数组（如果没有，则创建一个新的），然后将weakObj插入；  </p><h3 id="对象释放后，weak指针自动置为nil；"><a href="#对象释放后，weak指针自动置为nil；" class="headerlink" title="对象释放后，weak指针自动置为nil；"></a>对象释放后，weak指针自动置为nil；</h3><p>其中的实现原理类似将weak指针插入到弱引用数组中，首先获取弱引用数组，然后使用for循环将数组中的所有weak指针置为nil；</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要讲述weak指针如何被插入到弱引用数组和在所指对象被释放有事如何被置为nil的：&lt;/p&gt;
&lt;p&gt;实际开发过程中使用weak关键字来修饰对象是为了避免引用循环（delegate等）；&lt;br&gt;同时weak指针在对象被释放后还会自动置为nil，接下来我们看一下系统是如何实现weak操作的；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;id __weak weakObj = obj&lt;/code&gt;经过编译器会成如下：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  id weakObj;
  objc_initWeak(&amp;amp;weakObj,obj);
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过查看源码，函数的调用顺序如下 &lt;code&gt;objc_initWeak()&lt;/code&gt; ===&amp;gt;&lt;code&gt;storeWeak（）&lt;/code&gt;  ===&amp;gt; &lt;code&gt;weak_register_no_lock()&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-单链表查找环问题</title>
    <link href="http://yoursite.com/2018/03/11/LeetCode-%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/11/LeetCode-单链表查找环问题/</id>
    <published>2018-03-11T14:32:59.000Z</published>
    <updated>2018-08-20T15:42:03.031Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><ul><li>给定一个链表，判断链表中是否有环。不使用额外空间解决</li><li>给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 null。</li><li>求有环单链表的环长</li><li>求有环单链表的链表长</li><li>如何判断两个单链表有交？第一个交点在哪里？</li></ul><a id="more"></a><p><img src="http://images.cnitblog.com/i/466768/201404/162209501501814.png" alt=""></p><h3 id="给定一个链表，判断链表中是否有环。不使用额外空间解决"><a href="#给定一个链表，判断链表中是否有环。不使用额外空间解决" class="headerlink" title="给定一个链表，判断链表中是否有环。不使用额外空间解决"></a>给定一个链表，判断链表中是否有环。不使用额外空间解决</h3><p>使用slow和fast两个指针遍历链表，fast的比slow快一步，当fast遍历不为null，并且fast==slow则说明单链表中存在环；  </p><h3 id="给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回-null。"><a href="#给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回-null。" class="headerlink" title="给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 null。"></a>给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 null。</h3><p><img src="http://images.cnitblog.com/i/466768/201406/151647291089597.png" alt="">  </p><p>Pos:为slow和fast第一的交点；<br>Join：链表开始入环的第一个结点；<br>x：Join到Pos的距离；<br>LenA： head到join的距离<br>R : 环的长度<br>第一次相遇slow走的距离：S = LenA + x；<br>第一次相遇fast走的距离：2S = LenA + x + n<em>R；<br>由此可以得出： LenA = n</em>R - x；<br><strong>第一次碰撞点Pos到连接点Join的距离 + n*R=头指针到连接点Join的距离</strong><br>因此算法为：<em>当slow与fast第一次相遇后，将slow指向head结点，然后slow与fast以同样的速度依次遍历，再次相遇时slow指向的结点就是链表开始入环的结点</em></p><h3 id="求有环单链表的环长"><a href="#求有环单链表的环长" class="headerlink" title="求有环单链表的环长"></a>求有环单链表的环长</h3><p>在环上相遇后，记录第一次相遇点为Pos，之后指针slow继续每次走1步，fast每次走2步。在下次相遇的时候fast比slow正好又多走了一圈，也就是多走的距离等于环长。    </p><h3 id="求有环单链表的链表长"><a href="#求有环单链表的链表长" class="headerlink" title="求有环单链表的链表长"></a>求有环单链表的链表长</h3><p>Head遍历到Join的距离 + 环长 =  链表长</p><h3 id="如何判断两个单链表有交点？第一个交点在哪里？"><a href="#如何判断两个单链表有交点？第一个交点在哪里？" class="headerlink" title="如何判断两个单链表有交点？第一个交点在哪里？"></a>如何判断两个单链表有交点？第一个交点在哪里？</h3><p>如果两个链表相交，那么他们最后一个结点一定相同；否则不相交； 由此可以遍历两个链表，拿到最后一个结点做对比，相同则相交，不同则不相交；</p><p>判断出两个链表相交后就是判断他们的交点了。假设第一个链表长度为len1，第二个问len2，然后找出长度较长的，让长度较长的链表指针向后移动|len1 - len2| (len1-len2的绝对值)，然后在开始遍历两个链表，判断节点是否相同即可</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p><a href="https://blog.csdn.net/jiary5201314/article/details/50990349" target="_blank" rel="external">判断两个链表是否相交并找出交点</a><br><a href="https://blog.csdn.net/gdutliuyun827/article/details/44155105" target="_blank" rel="external">求有环单链表中的环长、环起点、链表长</a></p></blockquote><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plain"><figcaption><span>class Solution3 &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     // 判断单链表中是否存在环</div><div class="line">    public boolean hasCycle(ListNode head) &#123;</div><div class="line">        boolean flag = false;</div><div class="line">        ListNode fast = head;</div><div class="line">        ListNode slow = head;</div><div class="line">        while (fast !=null &amp;&amp; fast.next !=null)&#123;</div><div class="line">            fast = fast.next.next;</div><div class="line">            slow = slow.next;</div><div class="line">            if (fast == slow) &#123;</div><div class="line">                flag = true;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return flag;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     // 获取单链表第一次入环的结点</div><div class="line">    public ListNode getFirstNodeInCycle(ListNode head) &#123;</div><div class="line">        if(head == null) &#123;</div><div class="line">            return null;</div><div class="line">        &#125; else &#123;</div><div class="line">            ListNode fast = head;</div><div class="line">            ListNode slow = head;</div><div class="line">            while(fast != null &amp;&amp; fast.next != null) &#123;</div><div class="line">                slow = slow.next;</div><div class="line">                fast = fast.next.next;</div><div class="line">                if(fast == slow)&#123;</div><div class="line">                    //有环，则返回环的第一个节点</div><div class="line">                    slow = head;</div><div class="line">                    while(slow != fast)&#123;</div><div class="line">                        slow = slow.next;</div><div class="line">                        fast = fast.next;</div><div class="line">                    &#125;</div><div class="line">                    return slow;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 求环的长度</div><div class="line">    public int cycleLength(ListNode head) &#123;</div><div class="line">        int meet = 0;</div><div class="line">        int length = 0;</div><div class="line">        ListNode fast = head;</div><div class="line">        ListNode slow = head;</div><div class="line">        while (fast !=null &amp;&amp; fast.next !=null)&#123;</div><div class="line">            fast = fast.next.next;</div><div class="line">            slow = slow.next;</div><div class="line">            if (fast == slow &amp;&amp; meet==0) &#123;</div><div class="line">                meet ++;</div><div class="line">            &#125;</div><div class="line">            if (meet == 1)&#123;</div><div class="line">                length ++;</div><div class="line">            &#125;</div><div class="line">            if (meet  == 2)&#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return length;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class ListNode&#123;</div><div class="line">    int val;</div><div class="line">    ListNode next;</div><div class="line">    ListNode(int x)&#123;</div><div class="line">        val = x;</div><div class="line">        next = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定一个链表，判断链表中是否有环。不使用额外空间解决&lt;/li&gt;
&lt;li&gt;给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 null。&lt;/li&gt;
&lt;li&gt;求有环单链表的环长&lt;/li&gt;
&lt;li&gt;求有环单链表的链表长&lt;/li&gt;
&lt;li&gt;如何判断两个单链表有交？第一个交点在哪里？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>leetCode-707-设计链表</title>
    <link href="http://yoursite.com/2018/03/10/leetCode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/10/leetCode-707-设计链表/</id>
    <published>2018-03-10T12:32:59.000Z</published>
    <updated>2018-08-20T13:17:07.909Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：  </p><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。<br>在链表类中实现这些功能：  </p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。   </li></ul><a id="more"></a><figure class="highlight plain"><figcaption><span>class MyLinkedList &#123;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  private class LinkNode&#123;</div><div class="line">      public int val;</div><div class="line">      public LinkNode next;</div><div class="line">      public LinkNode(int val,LinkNode next)&#123;</div><div class="line">          this.val = val;</div><div class="line">          this.next = next;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private LinkNode dummyHeader;//虚拟头结点</div><div class="line">  private int size; // 链表当前存储个数</div><div class="line"></div><div class="line">  /** Initialize your data structure here. */</div><div class="line">  public MyLinkedList() &#123;</div><div class="line">      this.size = 0;</div><div class="line">      this.dummyHeader = new LinkNode(0,null);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</div><div class="line">  public int get(int index) &#123;</div><div class="line">      if(index &lt; 0 || index &gt;= size )&#123;</div><div class="line">          return -1;</div><div class="line">      &#125;else&#123;</div><div class="line">          LinkNode cur =  dummyHeader.next;</div><div class="line">          for(int i = 0; i &lt; index; i++)&#123;</div><div class="line">              cur = cur.next;</div><div class="line">          &#125;</div><div class="line">          return cur.val;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</div><div class="line">  public void addAtHead(int val) &#123;</div><div class="line">      addAtIndex(0,val);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /** Append a node of value val to the last element of the linked list. */</div><div class="line">  public void addAtTail(int val) &#123;</div><div class="line">      addAtIndex(size,val);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</div><div class="line">  public void addAtIndex(int index, int val) &#123;</div><div class="line">      if(index &lt; 0 || index &gt; size)&#123;</div><div class="line">         // throw new IllegalArgumentException(&quot;index is illegal&quot;);</div><div class="line">      &#125;else&#123;</div><div class="line">            LinkNode pre =  dummyHeader;</div><div class="line">              for(int i = 0; i&lt; index; i++)&#123;</div><div class="line">                   pre = pre.next;</div><div class="line">              &#125;</div><div class="line">            LinkNode insertNode = new  LinkNode(val,null);</div><div class="line">            insertNode.next = pre.next;</div><div class="line">            pre.next =  insertNode;</div><div class="line">          size++;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /** Delete the index-th node in the linked list, if the index is valid. */</div><div class="line">  public void deleteAtIndex(int index) &#123;</div><div class="line">      if(index &lt; 0 || index &gt;=size || size == 0)&#123;</div><div class="line">         // throw new IllegalArgumentException(&quot;index is illegal&quot;);</div><div class="line">          return;</div><div class="line">      &#125;</div><div class="line">      LinkNode pre =  dummyHeader;</div><div class="line">      for(int i = 0; i &lt; index; i++)&#123;</div><div class="line">          pre = pre.next;</div><div class="line">      &#125;</div><div class="line">      LinkNode delNode = pre.next;</div><div class="line">      pre.next = delNode.next;</div><div class="line">      delNode = null;</div><div class="line">      size--;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目描述：  &lt;/p&gt;
&lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。&lt;br&gt;在链表类中实现这些功能：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。&lt;/li&gt;
&lt;li&gt;addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。&lt;/li&gt;
&lt;li&gt;addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。&lt;/li&gt;
&lt;li&gt;addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。&lt;/li&gt;
&lt;li&gt;deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。   &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS篇-App启动优化</title>
    <link href="http://yoursite.com/2018/01/18/iOS%E7%AF%87-App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/18/iOS篇-App启动优化/</id>
    <published>2018-01-18T12:49:47.000Z</published>
    <updated>2018-08-19T05:53:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://techblog.toutiao.com/2017/01/17/iosspeed/" target="_blank" rel="external">今日头条iOS客户端启动速度优化</a>  </p><p><a href="http://www.cocoachina.com/ios/20170816/20267.html" target="_blank" rel="external">贝聊APP启动优化</a></p><p>app从点击icon到展示具体的页面可以分为两个部分：main()函数调用前、main()函数执行到第一个视图控制器完全展示,所以app的启动优化可以从这两个方面来做调整； </p><h2 id="main-函数调用前系统都做了哪些操作"><a href="#main-函数调用前系统都做了哪些操作" class="headerlink" title="main()函数调用前系统都做了哪些操作"></a>main()函数调用前系统都做了哪些操作</h2><pre><code>App启动 ==&gt; Load所有的可执行文件（*.o）==&gt; 加载dyld（动态连接器）                                                     |                                                     |                                                     v                                                 加载app用到的所有动态链接库        动态链接库 = {            libObjc ： runtime            libSystem            libDispatch : GCD        libSystem_block : block        }        Objc setUp(静态调整) = {          1： 注册Objc类          2： 将catagory的定义插入方法列表中          3： 保证每一个selector唯一        }</code></pre><h3 id="main-函数执行之前可以做的优化"><a href="#main-函数执行之前可以做的优化" class="headerlink" title="main()函数执行之前可以做的优化"></a>main()函数执行之前可以做的优化</h3><ul><li>减少 +(void)load的使用，或者将不必须的逻辑移到+initialize中</li><li>app在加载完可执行文件后，经历过Objc setUp会依次调用+(void)load函数，如果有耗时操作则会增加app的启动时间；</li><li>清除一些不使用的动态链接库</li><li>移除不使用的类文件、方法、三方库  </li></ul><a id="more"></a> <h2 id="main-函数的执行做了哪些操作"><a href="#main-函数的执行做了哪些操作" class="headerlink" title="main()函数的执行做了哪些操作"></a>main()函数的执行做了哪些操作</h2><pre><code>                                  加载info.plist                                         |④                               ①，       |                  ③App----执行-&gt; main() ---call--&gt; UIApplicationMain()------AppDelegate                                          |②                      ⑤，create&amp;manage    | create              Runloop &lt;--------------- UIApplication                                           |                                           |                                           V                             didFinishLaunchingWithOptions                                           |                                           |                                           V                          create  window&amp;rootViewController</code></pre><h3 id="main-函数执行之后可以优化的地方"><a href="#main-函数执行之后可以优化的地方" class="headerlink" title="main()函数执行之后可以优化的地方"></a>main()函数执行之后可以优化的地方</h3><ul><li><p>didFinishLaunchingWithOptions </p><ul><li>初始化三方SDK，</li><li>IO操作，</li><li>加载（本地、远程）资源 </li></ul></li></ul><h4 id="具体-【头条做法】"><a href="#具体-【头条做法】" class="headerlink" title="具体 【头条做法】"></a>具体 【头条做法】</h4><p>  （1） 纯代码方式而不是storyboard加载首页UI。<br>  （2） 对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。<br>  （3） 对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载  </p><h4 id="贝聊的优化"><a href="#贝聊的优化" class="headerlink" title="贝聊的优化"></a>贝聊的优化</h4><p>   (1）    日志、统计等必须在 APP 一起动就最先配置的事件属于必须一启动就加载的<br>     (2)    项目配置、环境配置、用户信息的初始化 、推送、IM等事件选择合适的时机加载，【如展示广告页】<br>     (3)  其他 SDK 和配置事件在第一个控制器执行viewDidAppear中加载<br>     (4）展示的第一个视图控制器优化可以先展示空壳UI，然后在viewDidAppear中进行数据请求和数据解析，然后再做UI更新操作</p><h4 id="现有项目的启动具体优化"><a href="#现有项目的启动具体优化" class="headerlink" title="现有项目的启动具体优化"></a>现有项目的启动具体优化</h4><ul><li>首次安装解压zip资源包放在异步线程中；</li><li>基于session的网络传输替换，避免同步请求；使用token机制</li><li>launchScreen使用的图片用tinyPNG进行压缩处理</li><li>将不必要的网络请求延后处理；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://techblog.toutiao.com/2017/01/17/iosspeed/&quot;&gt;今日头条iOS客户端启动速度优化&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20170816/20267.html&quot;&gt;贝聊APP启动优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;app从点击icon到展示具体的页面可以分为两个部分：main()函数调用前、main()函数执行到第一个视图控制器完全展示,所以app的启动优化可以从这两个方面来做调整； &lt;/p&gt;
&lt;h2 id=&quot;main-函数调用前系统都做了哪些操作&quot;&gt;&lt;a href=&quot;#main-函数调用前系统都做了哪些操作&quot; class=&quot;headerlink&quot; title=&quot;main()函数调用前系统都做了哪些操作&quot;&gt;&lt;/a&gt;main()函数调用前系统都做了哪些操作&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;App启动 ==&amp;gt; Load所有的可执行文件（*.o）==&amp;gt; 加载dyld（动态连接器）
                                                     |
                                                     |
                                                     v
                                                 加载app用到的所有动态链接库


        动态链接库 = {
            libObjc ： runtime
            libSystem
            libDispatch : GCD
        libSystem_block : block
        }

        Objc setUp(静态调整) = {

          1： 注册Objc类
          2： 将catagory的定义插入方法列表中
          3： 保证每一个selector唯一
        }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;main-函数执行之前可以做的优化&quot;&gt;&lt;a href=&quot;#main-函数执行之前可以做的优化&quot; class=&quot;headerlink&quot; title=&quot;main()函数执行之前可以做的优化&quot;&gt;&lt;/a&gt;main()函数执行之前可以做的优化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;减少 +(void)load的使用，或者将不必须的逻辑移到+initialize中&lt;/li&gt;
&lt;li&gt;app在加载完可执行文件后，经历过Objc setUp会依次调用+(void)load函数，如果有耗时操作则会增加app的启动时间；&lt;/li&gt;
&lt;li&gt;清除一些不使用的动态链接库&lt;/li&gt;
&lt;li&gt;移除不使用的类文件、方法、三方库  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift-类和结构体</title>
    <link href="http://yoursite.com/2017/09/28/Swift-%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2017/09/28/Swift-类和结构体/</id>
    <published>2017-09-28T07:57:54.000Z</published>
    <updated>2018-10-02T01:50:24.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swift中结构体和类的相同点"><a href="#Swift中结构体和类的相同点" class="headerlink" title="Swift中结构体和类的相同点"></a>Swift中结构体和类的相同点</h3><ul><li>均可以定义属性和方法</li><li>使用构造函数来初始化成员变量</li><li>使用扩展来增加自身功能</li><li>遵守协议</li></ul><h3 id="Swift中结构体和类的不同点"><a href="#Swift中结构体和类的不同点" class="headerlink" title="Swift中结构体和类的不同点"></a>Swift中结构体和类的不同点</h3><ul><li>结构体是值类型，赋值时是值拷贝</li><li>类是引用类型，赋值只是指针拷贝，但指向的还是同一块内存地址</li><li>类能够通过继承扩展自身功能，结构体不可以</li><li><p>结构体有默认的初始化每一个成员变量的初始化函数，类没有</p><a id="more"></a></li></ul><h3 id="Swift的基本数据类型多是值类型"><a href="#Swift的基本数据类型多是值类型" class="headerlink" title="Swift的基本数据类型多是值类型"></a>Swift的基本数据类型多是值类型</h3><p><code>String</code> <code>Array</code> <code>Dictionary</code>以及基本的整型、浮点型、布尔型都是值类型，底层都是结构体实现的   </p><h3 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h3><p>如果希望检测两个常量或者变量是否引用同一个实例可以使用恒等运算符：</p><ul><li>等价于（ === ）</li><li>不等价于 ( !== ) </li></ul><h3 id="结构体和类的选择原则"><a href="#结构体和类的选择原则" class="headerlink" title="结构体和类的选择原则"></a>结构体和类的选择原则</h3><p>在实际项目中如何选择结构体或类的使用呢，可以将下列情况作为选择结构体的依据： </p><ul><li>定义的数据结构是用来封装少量相关简单数据值的</li><li>数据结构实例被赋值或传递，封装的数据只是被拷贝而不是引用传递</li><li>数据结构中存储的也是值类型的属性</li><li>数据结构不需要去继承另一个既有类型的属性或者行为</li></ul><h3 id="属性篇"><a href="#属性篇" class="headerlink" title="属性篇"></a>属性篇</h3><pre><code>class Person1 {    // 存储属性    var firstName : String?    var lastName : String?    /*      实例属性：属于一个特定类型的实例持有      类型属性：某个类型所有实例共享的数据，使用static关键字修饰    */     static var commonID : String?    //计算属性：不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值    var name : String{        get{           return firstName! + lastName!        }        set(newName){           // 更改属性的值        }    }    // 属性观察器    var weight : Float = 0.0{        willSet(newValue){        }        didSet{            print(oldValue)        }      }     // 拥有私有 Setter 的公共属性,本类中可以设置，     public private(set) var area: Double = 0     // 懒加载属性          lazy var testString: String = {        print(&quot;about to initialize the property&quot;)        return &quot;TestString&quot;    }()     // 全局变量：在函数、方法、闭包或任何类型之外定义的变量     // 局部变量：在函数、方法或闭包内部定义的变量}  </code></pre><h3 id="方法篇"><a href="#方法篇" class="headerlink" title="方法篇"></a>方法篇</h3><pre><code>class Methods: NSObject {  var count:Int = 0  // 实例方法  func increment(){      count += 1  }  func incrementBy(_ amount:Int){      count += amount  }  func reset(){      count = 0  }  // 类型方法【静态方法】  class func sum() -&gt; Void{  }   }  </code></pre><h3 id="下标（subscript）"><a href="#下标（subscript）" class="headerlink" title="下标（subscript）"></a>下标（subscript）</h3><pre><code>class Subscripts: NSObject {   // 下标    func testFunc(){        let threeTimeTable = TimesTable(multiplier: 3)        print(threeTimeTable[6])    }}struct TimesTable {    let multiplier:Int    subscript(index:Int)-&gt;Int{      return multiplier * index    }}</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code>class Vehicle {    var currentFeed = 0.0    var description:String{      return &quot;traveling at \(currentFeed)miles per hour&quot;    }    func makeNoise(){    }    // 防止重写    可以通过把方法，属性或下标标记为final来防止它们被重写}class Bicycle: Vehicle {    let hasBasket = false    // 重写方法    override func makeNoise() {        print(&quot;子类重写父类的方法！！！&quot;)    }}class Car: Vehicle {    var gear = 1    // 重写属性    override var description:String{       return super.description + &quot;in gear \(gear)&quot;    }}</code></pre><blockquote><p>资料来源  （update date 20180928）</p></blockquote><p> <a href="https://mp.weixin.qq.com/s/iDRru2bH2gUPfXE6W3FfWw" target="_blank" rel="external">SwiftGG翻译组-Swift 中的属性</a><br> <a href="http://wiki.jikexueyuan.com/project/swift/chapter2/10_Properties.html" target="_blank" rel="external">属性</a><br> <a href="http://wiki.jikexueyuan.com/project/swift/chapter2/09_Classes_and_Structures.html" target="_blank" rel="external">类和结构体</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Swift中结构体和类的相同点&quot;&gt;&lt;a href=&quot;#Swift中结构体和类的相同点&quot; class=&quot;headerlink&quot; title=&quot;Swift中结构体和类的相同点&quot;&gt;&lt;/a&gt;Swift中结构体和类的相同点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;均可以定义属性和方法&lt;/li&gt;
&lt;li&gt;使用构造函数来初始化成员变量&lt;/li&gt;
&lt;li&gt;使用扩展来增加自身功能&lt;/li&gt;
&lt;li&gt;遵守协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Swift中结构体和类的不同点&quot;&gt;&lt;a href=&quot;#Swift中结构体和类的不同点&quot; class=&quot;headerlink&quot; title=&quot;Swift中结构体和类的不同点&quot;&gt;&lt;/a&gt;Swift中结构体和类的不同点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;结构体是值类型，赋值时是值拷贝&lt;/li&gt;
&lt;li&gt;类是引用类型，赋值只是指针拷贝，但指向的还是同一块内存地址&lt;/li&gt;
&lt;li&gt;类能够通过继承扩展自身功能，结构体不可以&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构体有默认的初始化每一个成员变量的初始化函数，类没有&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift-闭包</title>
    <link href="http://yoursite.com/2017/09/27/Swift-%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/09/27/Swift-闭包/</id>
    <published>2017-09-27T14:57:54.000Z</published>
    <updated>2018-09-27T06:58:14.920Z</updated>
    
    <content type="html"><![CDATA[<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是匿名的函数代码块，可以在代码中传递或使用，语法如下：  </p><pre><code>{  （parameters）-&gt; (return type) in   statements}  </code></pre><a id="more"></a>      <h4 id="闭包类型"><a href="#闭包类型" class="headerlink" title="闭包类型"></a>闭包类型</h4><h5 id="属性为闭包类型"><a href="#属性为闭包类型" class="headerlink" title="属性为闭包类型"></a>属性为闭包类型</h5><pre><code>class Closure: NSObject {// 定义属性为闭包类型var handler: (([String]) -&gt; Void)?func testHandler() -&gt; Void {    let closure = Closure()    // 闭包赋值    closure.handler = {        (result) -&gt; Void in        print(result)    }    // 调用闭包    if closure.handler != nil{        closure.handler!([&quot;11&quot;,&quot;22&quot;,&quot;33&quot;])    }}}  </code></pre><h5 id="函数入参为闭包类型"><a href="#函数入参为闭包类型" class="headerlink" title="函数入参为闭包类型"></a>函数入参为闭包类型</h5><pre><code>class Closure: NSObject {    func requestFeed(){        loadServerData { (result) in            print(result)        }    }    // 函数的入参为闭包类型    func loadServerData(compelteHandler: @escaping (([String]) -&gt; Void)){        DispatchQueue.global().async {// 模拟数据请求            Thread.sleep(forTimeInterval: 2.0)            DispatchQueue.main.async {                compelteHandler([&quot;11&quot;,&quot;22&quot;,&quot;33&quot;]);            }        }    }}</code></pre><h4 id="逃逸闭包和非逃逸闭包"><a href="#逃逸闭包和非逃逸闭包" class="headerlink" title="逃逸闭包和非逃逸闭包"></a>逃逸闭包和非逃逸闭包</h4><ul><li>逃逸闭包：闭包的执行超过了所在函数的作用域；一般的函数内部执行一步操作通过闭包来返回请求的数据时，是使用逃逸闭包；用关键字 <code>@escaping</code> 修饰闭包类型</li><li>非逃逸闭包: 闭包的执行在函数的作用域之内</li></ul><h4 id="闭包的值捕获"><a href="#闭包的值捕获" class="headerlink" title="闭包的值捕获"></a>闭包的值捕获</h4><pre><code>func makeIncrementor(forIncrement amount:Int)-&gt;()-&gt;Int{    var runningTotal = 0    func incrementor()-&gt;Int{        runningTotal += amount        return runningTotal    }    return incrementor}let incrementorByTen = makeIncrementor(forIncrement: 10)incrementorByTen() //10incrementorByTen() // 20</code></pre><h4 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h4><p> 函数入参的最后一个参数为闭包，那么书写在函数括号之后的闭包表达式称之为尾随闭包</p><pre><code>func someFunctionThatTakesAClosure(closure: () -&gt; Void) {    // 函数体部分}// 以下是不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(closure: {    // 闭包主体部分})// 以下是使用尾随闭包进行函数调用someFunctionThatTakesAClosure() {    // 闭包主体部分}</code></pre><blockquote><p>资料来源  </p></blockquote><p><a href="http://wiki.jikexueyuan.com/project/swift/chapter2/07_Closures.html#trailing_closures" target="_blank" rel="external">The Swift Programming Language 中文版-闭包</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h4&gt;&lt;p&gt;闭包是匿名的函数代码块，可以在代码中传递或使用，语法如下：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  （parameters）-&amp;gt; (return type) in
   statements
}  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS篇-视图对象</title>
    <link href="http://yoursite.com/2017/09/06/iOS%E7%AF%87-UIView&amp;CALayer&amp;UIWindow/"/>
    <id>http://yoursite.com/2017/09/06/iOS篇-UIView&amp;CALayer&amp;UIWindow/</id>
    <published>2017-09-06T05:30:00.000Z</published>
    <updated>2018-10-22T06:27:30.533Z</updated>
    
    <content type="html"><![CDATA[<p>在web开发中经常使用标签<code>div</code>来进行页面的布局，而在iOS开发中界面可视化元素基本都是<code>UIView</code>或是其子类元素构成，本文主要介绍如下内容： </p><ul><li><code>UIView</code>和<code>CALayer</code>简介</li><li><code>UIView</code>的生命周期和布局函数</li><li>有了UIView为什么还要有CALayer </li><li>UIWindow 简介</li><li>视图的绘制过程</li><li>视图的基本属性</li><li>运行循环和重绘视图 </li><li>UI事件传递&amp;响应 </li></ul><h4 id="UIView和CALayer简介"><a href="#UIView和CALayer简介" class="headerlink" title="UIView和CALayer简介"></a><code>UIView</code>和<code>CALayer</code>简介</h4><p><code>UIView</code>有两个主要功能：（1）负责渲染视图矩阵区域中的内容，但<code>UIView</code>真正绘图的部分是由<code>CALayer</code>类来管理的；设置<code>UIView</code>的一些行为属性，其实质是设置<code>CALayer</code>的相关属性。（2）视图通过层级关系管理子视图，响应该区域中发生的触碰事件；<br><code>CALayer</code>是<code>UIView</code>的一个属性，<code>CALayer</code>的contents用来显示内容（backing store –bitmap的位图），但<code>CALayer</code>不能响应事件，可以通过操作<code>CALayer</code>来设置视图的圆角、阴影、边框的颜色和宽度等。<br><a id="more"></a>  </p><h4 id="UIView的生命周期和布局函数"><a href="#UIView的生命周期和布局函数" class="headerlink" title="UIView的生命周期和布局函数"></a><code>UIView</code>的生命周期和布局函数</h4><p>以下执行步骤是一个UIView从创建、设置属性、添加到父视图所执行的动作步骤：</p><ul><li>视图的创建可以通过xib或者手写代码的方式，xib创建视图调用的初始化方法为<code>-(instancetype)initWithCoder:(NSCoder *)aDecoder</code>,手写代码创建视图调用的初始化方法为<code>- (instancetype)initWithFrame:(CGRect)frame</code> ;如果需要对视图进行额外的设置可以在初始化方法中进行设置；   </li><li>当我们创建了一个视图对象，需要对其属性进行设置时，会调用<code>-(void)setNeedsDisplay</code>对该视图打标记，设置一次属性就会触发一次<code>-(void)setNeedsDisplay</code>；</li><li>当把视图添加到父视图上时会触发<code>-(void)layoutSubviews</code>,此函数可以重新定义子元素的位置和大小；<code>layoutSubviews</code>函数还会在frame发生变化、addsubView等动作下被触发；</li><li>如果重写了视图的<code>- (void)drawRect:(CGRect)rect</code>，那么此函数将会被调用  </li></ul><p>如果有需求直接触发<code>layoutSubviews</code> 可以调用<code>-(void)layoutIfNeeded</code>来触发；而直接显式的调用<code>-(void)setNeedsDisplay</code>会触发<code>- (void)drawRect:(CGRect)rect</code>；使用<code>setNeedsLayout</code>标记的视图在当前runloop快结束的时候会调用<code>layoutSubviews</code></p><h4 id="有了UIView为什么还要有CALayer"><a href="#有了UIView为什么还要有CALayer" class="headerlink" title="有了UIView为什么还要有CALayer"></a>有了UIView为什么还要有CALayer</h4><ul><li><code>UIView</code>作为<code>CALayer</code>的一个管理类</li><li>遵循单一职责原则</li><li>iOS和MacOS的统一，两者共用core animation的API</li></ul><h4 id="UIWindow-简介"><a href="#UIWindow-简介" class="headerlink" title="UIWindow 简介"></a>UIWindow 简介</h4><ul><li><p>什么是UIWindow  </p><blockquote><p>The UIWindow class defines an object known as a window that manages and coordinates the views an app displays on a device screen. Unless an app can display content on an external device screen, an app has only one window.<br>UIWindow类定义了一个window对象来管理和协调显示在屏幕上的视图，除非一个app可以显示在额外的屏幕上，否则一个app只有一个window对象 任何一个应用有且只有一个UIWindow对象，它就像一个容器包含应用中的所有视图；应用需要在启动时创建并设置UIWindow；   </p></blockquote></li><li><p>如何设置UIWindow  </p></li></ul><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // UIWindow 的设置    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];    [self.window setBackgroundColor:[UIColor whiteColor]];    [self.window setRootViewController:[[UIViewController alloc] init]];    [self.window makeKeyAndVisible];    return YES;}</code></pre><ul><li>什么是keyWindow  <blockquote><p>用来接收键盘以及非触摸类的消息事件的UIWindow，而且程序中每个时刻只能有一个UIWindow是keyWindow。  </p></blockquote></li><li>设置UIWindowLevel<br>通过将UIWindow的UIWindowLevel设置的更高，可以将UIWindow盖在所有的应用界面之上；这个在做遮罩的时候可以选择做一个自定义的UIWindow显示在界面上；  </li></ul><h4 id="视图的绘制过程"><a href="#视图的绘制过程" class="headerlink" title="视图的绘制过程"></a>视图的绘制过程</h4><p> <code>UIView</code>从Draw到Render主要包含过程如下:</p><ul><li><code>UIView</code>包含一个<code>CALayer</code>属性，<code>CALayer</code>中包含一个<code>content</code>指针指向缓存块<em>backing store</em></li><li><code>UIView</code>的绘制和渲染是两个过程；一个视图由CPU进行Frame布局，首先准备视图和图层的层级关系，然后查询视图是否有重写<code>drawRect：</code>或者<code>drawLayer:inContext:</code>方法，如果有CPU会执行drawRect，然后CPU会将处理视图和图层层级关系打包，通过context将数据写入backing store</li><li>backing store写完后，通知render server将图层数据交给OpenGL ES 进行纹理生成和着色，生成前后帧缓存，再根据硬件的刷新频率，一般以设备的Vsync信号和CADisplayLink为标准，进行前后帧的切换。</li><li>最后将要显示在画面上的后帧缓存交给GPU去渲染，进行采集图片和形状，运行变换，应用纹理的混合，最终将bitMap数据显示在屏幕上</li><li>CPU绘制后把内容放入到缓存里，GPU负责从缓存里读取数据然后渲染到屏幕上。</li></ul><p>GPU的操作涉及多个View的拼接（Compositing），纹理（Texture）的渲染等最后显示到屏幕上。GPU将纹理渲染到屏幕主要涉及到一下几个问题：  </p><ul><li>合成（Compositing）: 将多个纹理拼到一起的过程，对应UIKIT，是指处理多个View合到一起的情况，如果View没有叠加GPU只需要做普通的渲染即可，如果多个View之间有叠加部分，GPU需要做混合操作</li><li>尺寸(Size) ：主要是image 大图直接填充到小尺寸的imageView中，不做处理，那么GPU就需要额外的操作，计算量会飙升</li><li>渲染分为当前屏幕渲染和离屏渲染   <ul><li>On-Screen Rendering即GPU的渲染操作是在当前屏幕缓冲区进行的</li><li>Off-Screen Rendering即离屏渲染，指的是GPU的渲染是在当前屏幕缓冲区以外进行渲染操作，涉及上下文的切换，造成性能损失</li></ul></li></ul><p>为什么需要离屏渲染？<br>图形属性的混合体（圆角、阴影、遮罩）被指定为在未预合成之前不能再屏幕上绘制，即当主屏的还会被绘制好的时候，就需要在屏幕外渲染</p><h4 id="视图的基本属性"><a href="#视图的基本属性" class="headerlink" title="视图的基本属性"></a>视图的基本属性</h4><h5 id="frame和bounds-属性"><a href="#frame和bounds-属性" class="headerlink" title="frame和bounds 属性"></a>frame和bounds 属性</h5><ul><li>frame:保存视图的大小和相对父视图的位置；</li><li>bounds：用于确定绘制区域，避免绘制到图层之外 ，修改bounds的origin会影响它子视图的布局 </li></ul><h5 id="UIView-缩放、旋转、位移"><a href="#UIView-缩放、旋转、位移" class="headerlink" title="UIView 缩放、旋转、位移"></a>UIView 缩放、旋转、位移</h5><p>通过设置<code>UIView</code>的transform属性可以对视图进行缩放、旋转、位移操作，其实质是操作CGAffineTransform仿射转换结构体【代表一种仿射变换矩阵】  </p><pre><code> func testTransform() -&gt; Void {    let view = UIView(frame: CGRect(x: 0, y: 0, width: 200, height: 50))    view.center = self.view.center    view.backgroundColor = UIColor.orange    self.view.addSubview(view)    // 首先拿到视图的transform属性    let transform = view.transform    // view.transform = transform.translatedBy(x: 0, y: 100) 向下平移100    //view.transform = transform.scaledBy(x: 1.5, y: 1.5) 缩放视图    view.transform = transform.rotated(by: 3.14/4)  // 视图的旋转    // self.view.transform = CGAffineTransform(rotationAngle: &lt;#T##CGFloat#&gt;)}</code></pre><h5 id="像素和点"><a href="#像素和点" class="headerlink" title="像素和点"></a>像素和点</h5><p>在retina显示屏上，一个点相当于两个像素高和两个像素宽，非retina一个点相当于一个像素宽和一像素高；</p><h5 id="在drawRect-方法中自定义绘图"><a href="#在drawRect-方法中自定义绘图" class="headerlink" title="在drawRect:方法中自定义绘图"></a>在drawRect:方法中自定义绘图</h5><p>视图根据drawRect:方法将自己绘制到视图上，UIView的子类可以覆盖drawRect:完成自定义的绘图任务；</p><h4 id="运行循环和重绘视图"><a href="#运行循环和重绘视图" class="headerlink" title="运行循环和重绘视图"></a>运行循环和重绘视图</h4><h5 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h5><blockquote><p>iOS应用启动时就会开始一个运行循环（runloop），runloop的工作就是监听事件，例如触摸；runloop会为相应的事件找到合适的处理方法，只有当这些处理方法都执行完毕后控制权才返回给runloop；  </p></blockquote><h5 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h5><ul><li><p>详细：core animation 在Runloop中注册了一个Observer，负责监听BeforeWating和Exit事件。这个Observer优先级为200000，低于常见的Observer；当触摸事件到来时，Runloop会被唤醒，App中的一些代码会执行一些操作，比如创建和调整视图的层级、设置UIView的Frame，修改透明度，为视图添加动画，这些都会被CALayer所捕获，并通过CATransaction提交一个中间状态。当上述操作结束，Runloop即将进入休眠，负责监听的Observer会得到通知，注册的回调函数会被执行，把所有的中间状态合并提交GPU去显示，</p></li><li><p>大概：当业务处理方法执行完毕后，将控制权交还给runloop时，runloop首先会检查是否有等待重绘的视图（即当前循环收到过setNeedsDisplay消息的视图）；然后向等待绘制的视图发送drawRect:消息；最后所有视图组合成一个图像显示到屏幕中  </p><h5 id="为了界面的流畅iOS做了两方面的优化"><a href="#为了界面的流畅iOS做了两方面的优化" class="headerlink" title="为了界面的流畅iOS做了两方面的优化"></a>为了界面的流畅iOS做了两方面的优化</h5></li></ul><ul><li>不重绘显示内容没有改变的视图；</li><li>在每次事件处理周期中只发送一次drawRect:消息；iOS会在运行循环的最后阶段集中处理需要绘制的视图，尤其是对属性发生多次改变的视图； </li></ul><h4 id="UI事件传递-amp-响应"><a href="#UI事件传递-amp-响应" class="headerlink" title="UI事件传递&amp;响应"></a>UI事件传递&amp;响应</h4><h4 id="响应者链（Responder-Chain）的产生"><a href="#响应者链（Responder-Chain）的产生" class="headerlink" title="响应者链（Responder Chain）的产生"></a>响应者链（Responder Chain）的产生</h4><p>由于视图继承自UIResponder，因此他有一个nextResponder属性，结合视图的层次结构这样一个响应者链就产生了；子视图的nextResponder指向的是父视图；事件在传递的过程中根据nextResponder指针完成树状图的遍历直到有视图处理此次事件，否则就放弃事件的响应；  </p><h4 id="查找响应者-（Responder-Object）"><a href="#查找响应者-（Responder-Object）" class="headerlink" title="查找响应者 （Responder Object）"></a>查找响应者 （Responder Object）</h4><p>屏幕中点击了一个按钮，事件由UIApplication从runloop的事件队列中取出通过[UIApplication sendEvent:]传递给UIWindow；此时会触发Hit-Testing View也就是触发UIWindow中的<code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;</code>和<code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</code>方法；那么Hit-Testing View的过程是什么呢？</p><h5 id="Hit-Testing-View的过程"><a href="#Hit-Testing-View的过程" class="headerlink" title="Hit-Testing View的过程"></a>Hit-Testing View的过程</h5><p>Hit-Testing View实际是递归的使用<code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;</code>和<code>- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;</code>方法来找到<em>触摸点</em>所在的最上层视图然后返回；如下图所示： </p><center><br><img src="http://zhoon.github.io/img/artical/ios_event/iosevent_4.png" alt="图片来自网络"><br></center>  <p>Hit-Testing View 的执行流程图   </p><center><br><img src="http://zhoon.github.io/img/artical/ios_event/iosevent_5.png" alt="图片来自网络"><br></center> <p>当一个触摸事件产生后，事件传递链由UIApplication -&gt; UIWindow -&gt; UIView -&gt; subViews -&gt; lastView[hitTest-view];然后判断当前视图是否有处理事件的方法，如果没有则根据nextResponder指针将事件向上传递给父视图，如果一直没有找到则丢弃；</p><hr><blockquote><p>内容来自iOS高级编程（第4版）视图与层次结构<br><a href="https://www.cnblogs.com/feng9exe/p/8848663.html" target="_blank" rel="external">理解UIView的绘制</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在web开发中经常使用标签&lt;code&gt;div&lt;/code&gt;来进行页面的布局，而在iOS开发中界面可视化元素基本都是&lt;code&gt;UIView&lt;/code&gt;或是其子类元素构成，本文主要介绍如下内容： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UIView&lt;/code&gt;和&lt;code&gt;CALayer&lt;/code&gt;简介&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIView&lt;/code&gt;的生命周期和布局函数&lt;/li&gt;
&lt;li&gt;有了UIView为什么还要有CALayer &lt;/li&gt;
&lt;li&gt;UIWindow 简介&lt;/li&gt;
&lt;li&gt;视图的绘制过程&lt;/li&gt;
&lt;li&gt;视图的基本属性&lt;/li&gt;
&lt;li&gt;运行循环和重绘视图 &lt;/li&gt;
&lt;li&gt;UI事件传递&amp;amp;响应 &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;UIView和CALayer简介&quot;&gt;&lt;a href=&quot;#UIView和CALayer简介&quot; class=&quot;headerlink&quot; title=&quot;UIView和CALayer简介&quot;&gt;&lt;/a&gt;&lt;code&gt;UIView&lt;/code&gt;和&lt;code&gt;CALayer&lt;/code&gt;简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;UIView&lt;/code&gt;有两个主要功能：（1）负责渲染视图矩阵区域中的内容，但&lt;code&gt;UIView&lt;/code&gt;真正绘图的部分是由&lt;code&gt;CALayer&lt;/code&gt;类来管理的；设置&lt;code&gt;UIView&lt;/code&gt;的一些行为属性，其实质是设置&lt;code&gt;CALayer&lt;/code&gt;的相关属性。（2）视图通过层级关系管理子视图，响应该区域中发生的触碰事件；&lt;br&gt;&lt;code&gt;CALayer&lt;/code&gt;是&lt;code&gt;UIView&lt;/code&gt;的一个属性，&lt;code&gt;CALayer&lt;/code&gt;的contents用来显示内容（backing store –bitmap的位图），但&lt;code&gt;CALayer&lt;/code&gt;不能响应事件，可以通过操作&lt;code&gt;CALayer&lt;/code&gt;来设置视图的圆角、阴影、边框的颜色和宽度等。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>生活篇--说说三观</title>
    <link href="http://yoursite.com/2017/06/04/%E7%94%9F%E6%B4%BB%E7%AF%87--%E8%AF%B4%E8%AF%B4%E4%B8%89%E8%A7%82/"/>
    <id>http://yoursite.com/2017/06/04/生活篇--说说三观/</id>
    <published>2017-06-04T09:37:48.000Z</published>
    <updated>2018-06-23T04:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="人生观"><a href="#人生观" class="headerlink" title="人生观"></a>人生观</h3><blockquote><p>对于人生的根本态度与看法  </p></blockquote><p>   人生千姿百态，每个人都是一个演员在无剧本的人生舞台上做着自己的表演。有句话说<strong>意识决定形态</strong>，我个人浅显的理解就是你自己的意愿想通过哪种姿态展现自己， 那么在世人面前你就是以哪种姿态呈现。<br>有时候我们会感慨某某活成了我们自己想要的模样，其实本质上我们都有活成某种模样的意识但最终为什么差别很大？主要原因是缺乏行动，多数人都具有正确的人生观：积极生活、努力奋斗、追求幸福等；但又有多少勤勤恳恳的去实践自己的人生观呢？经常会听到说这人的做事态度不错，但请不要忘记最终衡量你的还是做事的结果。获取正确的人生观容易，困难的是通过正确的人生观来让生活极大丰富才是最困难的事情！<br><a id="more"></a></p><h4 id="人生观主要包含哪些"><a href="#人生观主要包含哪些" class="headerlink" title="人生观主要包含哪些"></a>人生观主要包含哪些</h4><ul><li>友谊观</li><li>恋爱观</li><li>审美观</li><li>道德观</li><li>苦乐观</li><li>幸福观</li></ul><h3 id="世界观"><a href="#世界观" class="headerlink" title="世界观"></a>世界观</h3><blockquote><p>它是人们对世界的基本看法和观点.世界观具有实践性，人的世界观是不断更新、不断完善、不断优化的；  </p></blockquote><p>世界观确实是在不断的更新中的，<strong>世界那么大，我想去看看</strong>本质上的追求是去丰富自己的世界观的，而不是仅仅看看风景，发发朋友圈而已。去一个地方应该在欣赏美景的同时去了解风土人情，通过比较差异来完善自己的认知，使得自己更为的丰富。</p><h3 id="价值观"><a href="#价值观" class="headerlink" title="价值观"></a>价值观</h3><blockquote><p> 用以区分好与坏的标准，是根据个人内心的尺度进行衡量和评价的，这些标准都可以称为价值观。  </p></blockquote><p>我们日常会听到<strong>某某的价值观出了问题</strong>，其实呢我们是在说某人对于问题的评判或者是做的某些行为严重的偏离了我们正常的认知；那么具体什么是正确的价值观呢？这个问题需要我们自己不断的去探寻、去学习。有些价值观是父母师长等人群灌输的；例如孝敬长者，尊师重道等基本的道德要求；真善美与假恶丑是需要自己去分辨的。特别是目前我们处于互联网时代，言论自由，你对于每一个事件的看法都是你价值观的体现；平时和朋友相处也是，交谈中你的价值观就被反应出来了，价值观一致的人才适合一起玩耍的！</p><h3 id="婚姻观"><a href="#婚姻观" class="headerlink" title="婚姻观"></a>婚姻观</h3><blockquote><p>对婚姻和家庭的看法和态度。</p></blockquote><p>我个人一直遵守家庭第一，其他第二的原则；把家庭照顾好了的前提下再向<em>大家</em>奉献，我觉得才是理想的状态。因为每个人的人生观不同所以也就没有评判对与错的必要；</p><h4 id="幸福婚姻应该包含哪些要素"><a href="#幸福婚姻应该包含哪些要素" class="headerlink" title="幸福婚姻应该包含哪些要素"></a>幸福婚姻应该包含哪些要素</h4><ul><li>童心</li><li>浪漫</li><li>幽默</li><li>亲昵</li><li>情话</li><li>沟通</li><li>欣赏</li></ul><p>日常我们经常听到<strong>三观尽毁</strong>和<strong>三观正才能一起玩耍</strong>；一直以来都没有好好的思考自己的<strong>三观</strong>到底是什么？其实我的日常生活中存在很多这样的习以为常的问题都被自己忽略了，真的很不应该，问题是应该被解决的，时间不会将它带走！追求简单生活，不要要逃避问题，而是要解决复杂的问题，这样生活才会简单！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;人生观&quot;&gt;&lt;a href=&quot;#人生观&quot; class=&quot;headerlink&quot; title=&quot;人生观&quot;&gt;&lt;/a&gt;人生观&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对于人生的根本态度与看法  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;   人生千姿百态，每个人都是一个演员在无剧本的人生舞台上做着自己的表演。有句话说&lt;strong&gt;意识决定形态&lt;/strong&gt;，我个人浅显的理解就是你自己的意愿想通过哪种姿态展现自己， 那么在世人面前你就是以哪种姿态呈现。&lt;br&gt;有时候我们会感慨某某活成了我们自己想要的模样，其实本质上我们都有活成某种模样的意识但最终为什么差别很大？主要原因是缺乏行动，多数人都具有正确的人生观：积极生活、努力奋斗、追求幸福等；但又有多少勤勤恳恳的去实践自己的人生观呢？经常会听到说这人的做事态度不错，但请不要忘记最终衡量你的还是做事的结果。获取正确的人生观容易，困难的是通过正确的人生观来让生活极大丰富才是最困难的事情！&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随感" scheme="http://yoursite.com/tags/%E9%9A%8F%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之AssociatedObject</title>
    <link href="http://yoursite.com/2017/03/10/OC%E5%9F%BA%E7%A1%80%E4%B9%8BAssociatedObject/"/>
    <id>http://yoursite.com/2017/03/10/OC基础之AssociatedObject/</id>
    <published>2017-03-10T05:55:00.000Z</published>
    <updated>2018-08-18T02:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AssociatedObject-关联对象"><a href="#AssociatedObject-关联对象" class="headerlink" title="AssociatedObject(关联对象)"></a>AssociatedObject(关联对象)</h3><p> 在既有类中使用关联对象存放自定义数据，分类中添加属性也会用到   </p><ul><li>给对象存储信息，通常会创建对象所属类的子类；但某些情况下无法创建子类（分类），只能通过关联属性值的方式</li><li>关联属性值可能会出现循环引用问题</li></ul><h3 id="AssociatedObject的本质"><a href="#AssociatedObject的本质" class="headerlink" title="AssociatedObject的本质"></a>AssociatedObject的本质</h3><p> 通过objc_setAssociatedObject给分类创建的属性放在了一个全局的AssociationManager中；<br> 通过对象的地址找到AssociationManager中的hashMap，然后通过属性的Key来获取属性的value；   </p><a id="more"></a><h3 id="AssociatedObject具体使用"><a href="#AssociatedObject具体使用" class="headerlink" title="AssociatedObject具体使用"></a>AssociatedObject具体使用</h3><pre><code>    #import &quot;AssociatedObject.h&quot;#import &lt;objc/runtime.h&gt;@implementation AssociatedObjectstatic void* associatedObjectKey = &quot;associatedObjectKey&quot;;-(void)askQuestion{    void (^block)(NSInteger index)= ^(NSInteger index){        if (0 == index) {            [self confrim];        }else if (1 == index){            [self cancel];        }    };    objc_setAssociatedObject(self, associatedObjectKey, block, OBJC_ASSOCIATION_COPY_NONATOMIC);}-(void)associated:(AssociatedObject*)associated index:(NSInteger)index{    void (^block)(NSInteger index) = objc_getAssociatedObject(associated, associatedObjectKey);    block(index);}-(void)confrim{  // Class test_class = [NSString class];}-(void)cancel{}@end</code></pre><p> 文章参考：<br> <a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AssociatedObject-关联对象&quot;&gt;&lt;a href=&quot;#AssociatedObject-关联对象&quot; class=&quot;headerlink&quot; title=&quot;AssociatedObject(关联对象)&quot;&gt;&lt;/a&gt;AssociatedObject(关联对象)&lt;/h3&gt;&lt;p&gt; 在既有类中使用关联对象存放自定义数据，分类中添加属性也会用到   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给对象存储信息，通常会创建对象所属类的子类；但某些情况下无法创建子类（分类），只能通过关联属性值的方式&lt;/li&gt;
&lt;li&gt;关联属性值可能会出现循环引用问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;AssociatedObject的本质&quot;&gt;&lt;a href=&quot;#AssociatedObject的本质&quot; class=&quot;headerlink&quot; title=&quot;AssociatedObject的本质&quot;&gt;&lt;/a&gt;AssociatedObject的本质&lt;/h3&gt;&lt;p&gt; 通过objc_setAssociatedObject给分类创建的属性放在了一个全局的AssociationManager中；&lt;br&gt; 通过对象的地址找到AssociationManager中的hashMap，然后通过属性的Key来获取属性的value；   &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之分类-Category</title>
    <link href="http://yoursite.com/2017/03/04/OC%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%86%E7%B1%BB-Category/"/>
    <id>http://yoursite.com/2017/03/04/OC基础之分类-Category/</id>
    <published>2017-03-04T14:57:54.000Z</published>
    <updated>2018-07-08T05:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>在Objective-C语言中Category可以在不修改原有类文件的情况下，为类添加方法；在Category文件中所添加的内容包括<strong>方法（实例方法、类方法）</strong>、<strong>协议</strong>、<strong>属性</strong>;其中属性的实现还需要根据关联对象来辅助实现；  </p><h3 id="分类的具体实现原理"><a href="#分类的具体实现原理" class="headerlink" title="分类的具体实现原理"></a>分类的具体实现原理</h3><p> 以下是runtime源码中对于分类具体实现的大致调用顺序   </p><pre><code>  // 加载所有头文件，并从头文件中获取分类列表void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){   // 重新调整宿主类的结构，包括：添加方法、属性、协议等   remethodizeClass(Class cls) {      // 将分类中的内容添加到宿主类中      attachCategories(Class cls, category_list *cats, bool flush_caches){            // 如何添加的具体实现            attachLists(List* const * addedLists, uint32_t addedCount){             }      }  } } </code></pre><a id="more"></a>      <h3 id="分类的常见问题"><a href="#分类的常见问题" class="headerlink" title="分类的常见问题"></a>分类的常见问题</h3><ul><li>分类中出现与宿主类同名的方法，会出现什么问题？ ==》宿主中的方法会失效，调用的时候会使用分类的方法，不建议定义相同的名称；</li><li>出现多个分类文件，分类文件中存在相同方法时，调用方法时会出现什么问题？==》最后被编译的分类文件中的方法会生效 ，具体原因查看<code>attachLists</code>的代码实现；  </li></ul><h3 id="分类实现原理的代码解析"><a href="#分类实现原理的代码解析" class="headerlink" title="分类实现原理的代码解析"></a>分类实现原理的代码解析</h3><h4 id="read-images"><a href="#read-images" class="headerlink" title="_read_images()"></a>_read_images()</h4><p>  <code>_read_images()</code> 方法在获取分类时，第一步：遍历加载的.h文件列表，然后获取分类列表；第二部：将分类列表中的方法转换为一个二维数组<code>[[method1,method2,method3],[method4,method5],[method6]]</code>;第三步将二维数组中的每个元素包含的方法再添加到宿主类的<code>method_list</code>中；<strong>分类中的方法是添加在<code>method_list</code>头部</strong>   </p><pre><code>  void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){/*   Discover categories.   + 遍历所有.h文件，获取分类列表   + 将分类列表中的方法通过倒序遍历得到一个二维数组==&gt;[[method1,method2,method3],[method4,method5],[method6]]; */for (EACH_HEADER) {    category_t **catlist =    _getObjc2CategoryList(hi, &amp;count);    bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();    for (i = 0; i &lt; count; i++) {        category_t *cat = catlist[i];        Class cls = remapClass(cat-&gt;cls);        if (!cls) {            // Category&apos;s target class is missing (probably weak-linked).            // Disavow any knowledge of this category.            catlist[i] = nil;            if (PrintConnecting) {                _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;                             &quot;missing weak-linked target class&quot;,                             cat-&gt;name, cat);            }            continue;        }        /*          将二维数组中的每一个数组中的method添加到原生方法列表中         */        bool classExists = NO;        if (cat-&gt;instanceMethods ||  cat-&gt;protocols            ||  cat-&gt;instanceProperties)        {            addUnattachedCategoryForClass(cat, cls, hi);            if (cls-&gt;isRealized()) {                remethodizeClass(cls);                classExists = YES;            }            if (PrintConnecting) {                _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,                             cls-&gt;nameForLogging(), cat-&gt;name,                             classExists ? &quot;on existing class&quot; : &quot;&quot;);            }        }        if (cat-&gt;classMethods  ||  cat-&gt;protocols            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties))        {            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);            if (cls-&gt;ISA()-&gt;isRealized()) {                remethodizeClass(cls-&gt;ISA());            }            if (PrintConnecting) {                _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,                             cls-&gt;nameForLogging(), cat-&gt;name);            }        }    }}ts.log(&quot;IMAGE TIMES: discover categories&quot;);// Category discovery MUST BE LAST to avoid potential races// when other threads call the new category code before}   #undef EACH_HEADER}   </code></pre><h4 id="remethodizeClass-Class-cls"><a href="#remethodizeClass-Class-cls" class="headerlink" title="remethodizeClass(Class cls)"></a>remethodizeClass(Class cls)</h4><p><code>remethodizeClass(Class cls)</code> 重新调整class，利用<code>attachCategories</code>将分类内容添加到宿主类中   </p><pre><code>static void remethodizeClass(Class cls){category_list *cats;bool isMeta;runtimeLock.assertWriting();isMeta = cls-&gt;isMetaClass();// Re-methodizing: check for more categoriesif ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {    if (PrintConnecting) {        _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,                      cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);    }    //     attachCategories(cls, cats, true /*flush caches*/);            free(cats);}}      </code></pre><hr><h4 id="attachCategories"><a href="#attachCategories" class="headerlink" title="attachCategories"></a>attachCategories</h4><p><code>attachCategories(Class cls, category_list *cats, bool flush_caches)</code>  将分类中的方法、属性、协议添加到宿主类中       </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"> static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123;</div><div class="line">if (!cats) return;</div><div class="line">if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class="line">bool isMeta = cls-&gt;isMetaClass();</div><div class="line">// fixme rearrange to remove these intermediate allocations</div><div class="line">method_list_t **mlists = (method_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*mlists));</div><div class="line">property_list_t **proplists = (property_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*proplists));</div><div class="line">protocol_list_t **protolists = (protocol_list_t **)</div><div class="line">    malloc(cats-&gt;count * sizeof(*protolists));</div><div class="line">// Count backwards through cats to get newest categories first</div><div class="line">int mcount = 0;</div><div class="line">int propcount = 0;</div><div class="line">int protocount = 0;</div><div class="line">int i = cats-&gt;count;</div><div class="line">bool fromBundle = NO;</div><div class="line">while (i--) &#123;</div><div class="line">    auto&amp; entry = cats-&gt;list[i];</div><div class="line">    method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</div><div class="line">    if (mlist) &#123;</div><div class="line">        mlists[mcount++] = mlist;</div><div class="line">        fromBundle |= entry.hi-&gt;isBundle();</div><div class="line">    &#125;</div><div class="line">    property_list_t *proplist = </div><div class="line">        entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</div><div class="line">    if (proplist) &#123;</div><div class="line">        proplists[propcount++] = proplist;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protocol_list_t *protolist = entry.cat-&gt;protocols;</div><div class="line">    if (protolist) &#123;</div><div class="line">        protolists[protocount++] = protolist;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">auto rw = cls-&gt;data();</div><div class="line">prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</div><div class="line">// 添加方法</div><div class="line">rw-&gt;methods.attachLists(mlists, mcount);</div><div class="line">free(mlists);</div><div class="line">if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</div><div class="line">// 添加属性</div><div class="line">rw-&gt;properties.attachLists(proplists, propcount);</div><div class="line">free(proplists);</div><div class="line">// 添加协议</div><div class="line">rw-&gt;protocols.attachLists(protolists, protocount);</div><div class="line">free(protolists);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h4 id="attachLists"><a href="#attachLists" class="headerlink" title="attachLists"></a>attachLists</h4><p><code>void attachLists(List* const * addedLists, uint32_t addedCount)</code>主要是将分类中的内容添加到宿主类中；以method为例；第一步<br>扩充宿主元素的method_list得容量，具体扩充多少，由 要添加多少新方法来决定；第二步将宿主方法列表中的元素向后移动位置；第三步：将分类中的方法一次填充到宿主元素的methodList中；   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</div><div class="line">    if (addedCount == 0) return;</div><div class="line">    if (hasArray()) &#123;</div><div class="line">        // many lists -&gt; many lists</div><div class="line">        uint32_t oldCount = array()-&gt;count;</div><div class="line">        uint32_t newCount = oldCount + addedCount;</div><div class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</div><div class="line">        array()-&gt;count = newCount;</div><div class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, </div><div class="line">                oldCount * sizeof(array()-&gt;lists[0]));</div><div class="line">        memcpy(array()-&gt;lists, addedLists, </div><div class="line">               addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">    &#125;</div><div class="line">    else if (!list  &amp;&amp;  addedCount == 1) &#123;</div><div class="line">        // 0 lists -&gt; 1 list</div><div class="line">        list = addedLists[0];</div><div class="line">    &#125; </div><div class="line">    else &#123;</div><div class="line">        // 1 list -&gt; many lists</div><div class="line">        List* oldList = list;</div><div class="line">        uint32_t oldCount = oldList ? 1 : 0;</div><div class="line">        uint32_t newCount = oldCount + addedCount;</div><div class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</div><div class="line">        array()-&gt;count = newCount;</div><div class="line">        if (oldList) array()-&gt;lists[addedCount] = oldList;</div><div class="line">        memcpy(array()-&gt;lists, addedLists, </div><div class="line">               addedCount * sizeof(array()-&gt;lists[0]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>文章参照  <a href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/" target="_blank" rel="external">Objective-C Category 的实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h3&gt;&lt;p&gt;在Objective-C语言中Category可以在不修改原有类文件的情况下，为类添加方法；在Category文件中所添加的内容包括&lt;strong&gt;方法（实例方法、类方法）&lt;/strong&gt;、&lt;strong&gt;协议&lt;/strong&gt;、&lt;strong&gt;属性&lt;/strong&gt;;其中属性的实现还需要根据关联对象来辅助实现；  &lt;/p&gt;
&lt;h3 id=&quot;分类的具体实现原理&quot;&gt;&lt;a href=&quot;#分类的具体实现原理&quot; class=&quot;headerlink&quot; title=&quot;分类的具体实现原理&quot;&gt;&lt;/a&gt;分类的具体实现原理&lt;/h3&gt;&lt;p&gt; 以下是runtime源码中对于分类具体实现的大致调用顺序   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  // 加载所有头文件，并从头文件中获取分类列表
void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){
   // 重新调整宿主类的结构，包括：添加方法、属性、协议等
   remethodizeClass(Class cls) {
      // 将分类中的内容添加到宿主类中
      attachCategories(Class cls, category_list *cats, bool flush_caches){
            // 如何添加的具体实现
            attachLists(List* const * addedLists, uint32_t addedCount){
             }
      }
  } } 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多线程初识(一)</title>
    <link href="http://yoursite.com/2016/12/12/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E8%AF%86-%E4%B8%80/"/>
    <id>http://yoursite.com/2016/12/12/JAVA多线程初识-一/</id>
    <published>2016-12-12T05:58:17.000Z</published>
    <updated>2017-02-21T03:48:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h4><blockquote><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流;<br><a id="more"></a></p></blockquote><h4 id="如何实现在一个单独的线程中执行一个任务"><a href="#如何实现在一个单独的线程中执行一个任务" class="headerlink" title="如何实现在一个单独的线程中执行一个任务"></a>如何实现在一个单独的线程中执行一个任务</h4><h5 id="（1）创建执行task的类实现Runnable接口的run方法"><a href="#（1）创建执行task的类实现Runnable接口的run方法" class="headerlink" title="（1）创建执行task的类实现Runnable接口的run方法"></a>（1）创建执行task的类实现Runnable接口的run方法</h5><pre><code>package Test.Thread;public class MyRunnable implements Runnable{        public void run(){        System.out.println(Thread.currentThread());    }}</code></pre><h5 id="2-调用端创建Thread实例对象调用start方法"><a href="#2-调用端创建Thread实例对象调用start方法" class="headerlink" title="(2)调用端创建Thread实例对象调用start方法"></a>(2)调用端创建Thread实例对象调用start方法</h5><pre><code>package Test.Thread;public class TestTread {public static void main(String[] args) {    // TODO Auto-generated method stub        // 当前线程    System.out.println(Thread.currentThread());    Runnable run = (Runnable) new MyRunnable();    Thread thread = new Thread(run);    thread.start();    System.out.println(&quot;task excute over!&quot;);  }}</code></pre><p>以上两个步骤就实现了新创建一个线程执行另外一个Task的操作；  </p><h4 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h4><p>线程的中断有两种情况（1）run方法正常执行完所有的操作；（2）run方法中出现没有捕获的异常；API中提供interrupt方法用来请求终止线程； </p><pre><code>package Test.Thread;public class MyRunnable implements Runnable{        public void run(){        System.out.println(Thread.currentThread());        // 新线程执行的任务        try {            // 测试线程是否被终止，不会改变线程的中断状态(线程被堵塞就无法判断)            if(!Thread.currentThread().isInterrupted()){                    Thread.currentThread();                Thread.sleep(3000);            }        } catch (InterruptedException e) {            System.out.println(e);            // TODO Auto-generated catch block            // 向线程发送中断请求。线程的中断状态会被置为true；如果线程目前被一个sleep阻塞，那么InterruptedException被抛出            Thread.currentThread().interrupt();            e.printStackTrace();        }        Thread.currentThread();        // 测试线程是否被终止，会改变线程的中断状态,线程的中断状态会被置为false        if(Thread.interrupted()){                System.out.println(&quot;isInterrupted&quot;);        }else{                System.out.println(&quot;not is Interrupted!!!&quot;);        }        // 此时因为调用了Thread.interrupted()，此时线程的中断状态被置为false        if(!Thread.currentThread().isInterrupted()){                System.out.println(&quot;thread is Interrupted!!!&quot;);        }        }}</code></pre><p>java 中提供了 void interrupt()、static boolen interrupted()、boolean isInterrupted()来发送中断请求具体的区别详细见上述代码注释；</p><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><ul><li>New（新创建）</li><li>Runnable(可运行)</li><li>Blocked(被阻塞)</li><li>Waiting(等待)</li><li>Timed waiting(计时等待)</li><li>Terminated(被终止)</li></ul><h5 id="新创建线程"><a href="#新创建线程" class="headerlink" title="新创建线程"></a>新创建线程</h5><p> 使用 new Thread(r)；创建一个Thread实例对象，此时线程处于新创建状态 </p><h5 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h5><p> 一旦调用start方法，线程就进入runnable状态（不一定立即运行这个取决于系统的分配的时间）</p><h5 id="被阻塞线程和等待线程"><a href="#被阻塞线程和等待线程" class="headerlink" title="被阻塞线程和等待线程"></a>被阻塞线程和等待线程</h5><p> 阻塞：线程访问资源遇到加锁机制，他需要等待锁对象被释放才能进入非堵塞状态；<br> 等待：一个线程等待另一个线程的通知调度才能进入非等待状态；</p><h5 id="被终止的线程"><a href="#被终止的线程" class="headerlink" title="被终止的线程"></a>被终止的线程</h5><p> （1）run方法的正常退出而自然死亡（2）一个没有捕获的异常终止run方法而意外死亡；</p><h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>java中的线程优先级定义在MIN_PRIORITY(1)到MAX_PRIORITY(10)之间任何值；NORM_PRIORITY被定义为5；<br>void setPriority(int newPriority)可以设置优先级，但并不推荐使用；</p><h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p>void setDaemon(boolean isDaemon);该方法可以将线程转化为守护线程；他唯一的作用是为其他线程提供服务；使用守护线程要避免访问固有的资源，如文件、数据库，因为他任意时候都可能在一个操作的中间发生中断； </p><h5 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h5><p>run方法中出现的异常是无法使用try…catch捕获，只能为线程添加未捕获异常的处理器；<br>该处理器需要重写UncaughtExceptionHandler接口中的<code>void uncaughtException(Thread arg0,Throwable arg1)</code>方法，具体参照下列代码； </p><pre><code>package Test.Thread;import java.lang.Thread.UncaughtExceptionHandler;public class MyCrashHandler implements UncaughtExceptionHandler {   @Override   public void uncaughtException(Thread arg0,Throwable arg1){       System.out.println(&quot;线程出现问题！&quot;);   }}</code></pre><p>调用端只要为当前创建的Thread实例添加未捕获异常处理器即可   </p><pre><code>package Test.Thread;public class TestTread {public static void main(String[] args) {    // TODO Auto-generated method stub        // 当前线程    System.out.println(Thread.currentThread());    Runnable run = (Runnable) new MyRunnable();    Thread thread = new Thread(run);    // 为线程添加未捕获异常处理器    thread.setUncaughtExceptionHandler(new MyCrashHandler());;    thread.start();    System.out.println(&quot;task excute over!&quot;);   }}</code></pre><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>多线程编程时遇到的一个问题是多个子线程访问同一个数据源，在读写操作的时候导致异常出现；为了避免出现这种问题就会对多线程采用同步处理数据资源的机制；  </p><h5 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h5><p>java中提供的ReentrantLock锁来处理这种资源竞争问题 </p><pre><code>// 具体使用类似下列代码块  myLock.lock();   try{   }catch(Exception e){   }finally{       myLock.unlock();   }</code></pre><p>这样就能保证任何时刻只有一个线程进入临界区，当一个线程持有了锁对象，其他线程就被阻塞；直到所对象被持有的线程释放；   </p><h5 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h5><p>所谓的条件对象就是给锁L加一个条件限制，当A线程被锁L阻塞且不满足条件时线程A被阻塞，同时线程A放弃对当前锁L的等待获取（即使锁L被其他线程释放，线程A也不会去持有锁L），线程A被加入到了条件限制的等待集中；直到条件调用了signalAll()方法才会重新激活线程A；    </p><pre><code>package unsynch;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Bank {    private final double[] accounts;    // 所对象    private Lock bankLock;    // 条件对象    private Condition sufficientFunds;    // 构造器    public Bank(int n,double initialBalance){            accounts = new double[n];        for (int i = 0; i &lt; accounts.length; i++) {            accounts[i] = initialBalance;        }        bankLock = new ReentrantLock();        // 为锁添加条件对象        sufficientFunds = bankLock.newCondition();    }public void transfer(int from,int to ,double amount){        bankLock.lock();// 添加锁对象    try{        // 只有当当前账户的金额大于转出金额才能进行转账操作        while(accounts[from] &lt; amount)             //调用await()使得不满足条件的线程放弃对当前锁对象的索取；            sufficientFunds.await();        System.out.println(Thread.currentThread());        accounts[from] -= amount;        System.out.printf(&quot;%10.2f from %d to %d&quot;,amount,from,to);        accounts[to] += amount;        System.out.printf(&quot;Total Balance:%10.2f%n&quot;,getTotalBalance());        // 将加入到条件集合中的线程激活        sufficientFunds.signalAll();    }catch(Exception e){    }finally{            // 解锁操作        bankLock.unlock();    }}public double getTotalBalance(){        double sum = 0;    for(double a : accounts){            sum += a;    }    return sum ;}public int size(){        return accounts.length; }}   </code></pre><h5 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h5><p>使用synchronized 修饰方法其功能和加锁并添加条件对象一样，但代码要简洁很多；但平时使用上并不建议使用Lock和Condition以及synchronized来处理这类问题；java中提供了阻塞队列来实现。</p><pre><code>package unsynch;public class Bank {    private final double[] accounts;    // 构造器    public Bank(int n,double initialBalance){            accounts = new double[n];        for (int i = 0; i &lt; accounts.length; i++) {            accounts[i] = initialBalance;        }    }    public synchronized void transfer(int from,int to ,double amount){        try{            // 只有当当前账户的金额大于转出金额才能进行转账操作            while(accounts[from] &lt; amount)                 //调用wait()使得不满足条件的线程放弃对当前锁对象的索取；                wait();            System.out.println(Thread.currentThread());            accounts[from] -= amount;            System.out.printf(&quot;%10.2f from %d to %d&quot;,amount,from,to);            accounts[to] += amount;            System.out.printf(&quot;Total Balance:%10.2f%n&quot;,getTotalBalance());            // 将加入到条件集合中的线程激活            notifyAll();        }catch(Exception e){        }}public double getTotalBalance(){        double sum = 0;    for(double a : accounts){            sum += a;    }    return sum ;}public int size(){        return accounts.length;}}   </code></pre><h5 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h5><p> volatile关键字为实例域的同步访问提供了一种免锁机制；这样多线程访问实例域对象时就能保证线程安全</p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><blockquote><p>上述内容是java并发程序设计基础的底层构建块，实际编程中应该远离这些API的使用，选择更高级的并发处理方式解决遇到的并发问题，这样才能使得编程方面，也更加的安全。   </p></blockquote><h5 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h5><blockquote><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p></blockquote><h5 id="JAVA中提供的阻塞队列"><a href="#JAVA中提供的阻塞队列" class="headerlink" title="JAVA中提供的阻塞队列"></a>JAVA中提供的阻塞队列</h5><ul><li>ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。  </li><li>LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。  </li><li>PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序排列，也可以通过比较器comparator来指定元素的排序规则。元素按照升序排列。  </li><li>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素；  <ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。我们可以将DelayQueue运用在以下应用场景  </li><li>定时任务调度。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。 </li></ul></li></ul><h4 id="Callable-与-Future"><a href="#Callable-与-Future" class="headerlink" title="Callable 与 Future"></a>Callable 与 Future</h4><p>Callable和Runnable类似，只是Callable接口有返回值并且是一个参数化的类型，它有一个call方法；  </p><pre><code>public interface Callable&lt;V&gt;{    V call() throws Exception;}</code></pre><p>Future保存异步计算的结果   </p><pre><code>public interface Future&lt;V&gt;{// 计算未完成调用会发生堵塞   V get() throws...;  // 计算完成之前调用会超时，并且抛出TimeoutException异常   V get(long timeout,TimeUnit unit)throws...;   // cancel可以取消该计算   void cancel(boolean mayInterrupt);   boolean isCancelled();   // 如果计算还在进行 isDone方法会返回false   boolean isDone();} </code></pre><p>FutureTask包装器可以将Callable转换成Future和Runnable它同时实现两者的接口；</p><pre><code>Callable&lt;Integer&gt;myCompution = ...;FutureTask&lt;Integer&gt; task = new  FutureTask&lt;Integer&gt; (myCompution) ;Thread thread = new Thread(task);thread.start();...Integer result = task.get();// 对get调用会阻塞线程，直到获取结果为止 </code></pre><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><h5 id="什么是线程池，以及线程池有什么作用？"><a href="#什么是线程池，以及线程池有什么作用？" class="headerlink" title="什么是线程池，以及线程池有什么作用？"></a>什么是线程池，以及线程池有什么作用？</h5><p>线程池是用来包含多个准备运行的空闲线程，线程池持有Runnable对象，此时就会有一个线程调用run方法，run方法执行完毕后，线程也不会死亡，而是在线程池中为下一个请求提供服务；线程池的另外一个作用是减少并发线程的数量；<br>执行器Excutor类有许多静态方法可以创建线程池；  </p><ul><li>newCachedTheadPool 必要时创建线程，空闲线程会被停留60秒；  </li><li>newFixedThreadPool 该池包含固定数量的线程，空闲线程会一直被保存；</li><li>newSingleThreadPool 只有一个线程池，该线程的顺序执行每一个任务</li><li>newScheduledThreadPool 用于预定执行而创建的固定线程池  </li><li>newSingleThreadScheduledExcutor 用于预定执行而创建的单线程池   </li></ul><h5 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h5><blockquote><p>Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p></blockquote><h6 id="使用Fork-Join框架"><a href="#使用Fork-Join框架" class="headerlink" title="使用Fork/Join框架"></a>使用Fork/Join框架</h6><blockquote><p>使用Fork／Join框架首先要考虑到的是如何分割任务，如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork／Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果   </p></blockquote><pre><code>package fork.join.text;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;import Test.Thread.MyCrashHandler;import Test.Thread.MyRunnable;public class CountTask extends RecursiveTask&lt;Integer&gt; {public static void main(String[] args){    ForkJoinPool forkJoinPool = new ForkJoinPool();    CountTask task = new CountTask(1, 4);    Future&lt;Integer&gt; result = forkJoinPool.submit(task);    try{        System.err.println(result.get());    }catch(InterruptedException e){    }catch(ExecutionException e){    }}private static final int THRESHOLD = 2;// 阈值private int start;private int end;public CountTask(int start,int end){        this.start = start;    this.end = end;}@Overrideprotected Integer compute(){    int sum = 0 ;    // 任务足够小就直接计算    boolean canCompute = (end - start) &lt;= THRESHOLD;    if(canCompute){        for(int i = start;i&lt;=end;i++){            sum+=i;        }    }else{            int middle = (start + end)/2;        CountTask leftTask = new CountTask(start, middle);        CountTask rightTask = new CountTask(middle+1,end);        // 执行子任务        leftTask.fork();        rightTask.fork();        // 等待子任务完成，并将结果合并         int leftResult = leftTask.join();        int rightResult = rightTask.join();        // 合并子任务         sum = leftResult + rightResult;    }    return sum;}}   </code></pre><blockquote><p>文章内容来源 <a href="http://www.infoq.com/cn/author/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank" rel="external">聊聊并发（七）——Java中的阻塞队列</a> ;<a href="http://www.infoq.com/cn/articles/fork-join-introduction" target="_blank" rel="external">Fork/Join框架介绍</a>《JAVA核心技术 卷1》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;线程是什么&quot;&gt;&lt;a href=&quot;#线程是什么&quot; class=&quot;headerlink&quot; title=&quot;线程是什么&quot;&gt;&lt;/a&gt;线程是什么&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读篇--SDWebImage</title>
    <link href="http://yoursite.com/2016/10/26/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AF%87--SDWebImage/"/>
    <id>http://yoursite.com/2016/10/26/源码阅读篇--SDWebImage/</id>
    <published>2016-10-26T09:49:27.000Z</published>
    <updated>2018-08-18T02:24:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage提供的简洁的获取远程URL图片的API；平时开发中使用最多场景就是列表中的cell中要显示远程图片的需求，在具体的实现中要避免加载图片造成的界面卡顿，列表卡顿等现象的出现；所以需要编码实现如下功能：  </p><ul><li>使用占位图片显示UI界面，异步线程加载图片成功后刷新控件</li><li>缓存机制，下载过的图片做内存缓存和磁盘缓存 </li><li>app内存吃紧的状态下移除缓存的内容 </li></ul><a id="more"></a>    <p><strong>对于上述的需求SDWebImage已经完全优雅的实现，并且提供了更多简洁的API供开发者使用</strong>   </p><h4 id="SDWebImage的框架结构"><a href="#SDWebImage的框架结构" class="headerlink" title="SDWebImage的框架结构"></a>SDWebImage的框架结构</h4><pre><code>    【UIImageView + WebCache】      【SDWebImageManager】【SDImageCache】 【SDWebImageDownloader】 </code></pre><h4 id="github上一个关于SDWebImage的时序图"><a href="#github上一个关于SDWebImage的时序图" class="headerlink" title="github上一个关于SDWebImage的时序图"></a>github上一个关于SDWebImage的时序图</h4><div align="center"><br><img src="https://raw.githubusercontent.com/rs/SDWebImage/master/Docs/SDWebImageSequenceDiagram.png" width="800" height="300" alt="SDWebImage浅析"><br></div>      <p>上述的时序图大致介绍了SDWebImage的工作流程，而SDWebImage框架的构成是由多个组件构成，下面就一一介绍SDWebImage提供的便利组件；</p><h4 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h4><p>SDImageCache这个类主要的任务就是对图像进行存储；内存缓存，本地磁盘缓存，使用处理后的URL作为key，便于查找，删除，存储操作；SDImageCache提供了如下API</p><pre><code>- (void)storeImage:(UIImage *)image forKey:(NSString *)key;- (void)storeImage:(UIImage *)image forKey:(NSString *)key toDisk:(BOOL)toDisk;- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;   </code></pre><h5 id="SDImageCacheType"><a href="#SDImageCacheType" class="headerlink" title="SDImageCacheType"></a>SDImageCacheType</h5><p>在使用SD时，SDImageCache提供了多种缓存类型来适应不同的场景需求  </p><pre><code>typedef NS_ENUM(NSInteger, SDImageCacheType) {/** * The image wasn&apos;t available the SDWebImage caches, but was downloaded from the web. */SDImageCacheTypeNone,/** * The image was obtained from the disk cache. */SDImageCacheTypeDisk,/** * The image was obtained from the memory cache. */SDImageCacheTypeMemory};   </code></pre><h5 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h5><ul><li>内存存储SD选用的存储类是NSCache；它具有的优点是线程安全，可控存储大小，内存吃紧时系统会自动回收缓存对象；而SD在创建NSCache时也监听了UIApplicationDidReceiveMemoryWarningNotification、UIApplicationWillTerminateNotification、UIApplicationDidEnterBackgroundNotification等通知，适当的时期移除了内存缓存的图像；  </li><li>SDImageCache 暴露了maxMemoryCost、maxMemoryCountLimit等属性来供使用者设置内存缓存的存储空间   </li></ul><h5 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h5><ul><li>SD对于磁盘存储同样开放自定义存储路径  </li><li>SD创建了一个serial queue 来异步执行耗时的磁盘存储任务；将NSData写到指定目录，同时默认不执行iCloud同步  </li></ul><h4 id="SDWebImageDecoder"><a href="#SDWebImageDecoder" class="headerlink" title="SDWebImageDecoder"></a>SDWebImageDecoder</h4><p><strong>一道面试题问道SD为什么要对图片进行解压缩？</strong>  </p><blockquote><p>“解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间”  </p></blockquote><p><strong>在图片解压操作中SD的一些优化处理</strong> </p><p>在下载大量图片时产生了 the bitmap context，为了避免管理内存 SD自创建autoreleasepool来管理；解压的过程实质是创建一个适合的画布将压缩的image对象绘制到画布上然后返回绘制的image对象  </p><p><strong>阿尔法通道(Alpha Channel)是指一张图片的透明和半透明度</strong> </p><h4 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h4><p>SDWebImageManager这个类负责了整个框架API的调用；（1）图片从缓存中获取（2）图片从服务端获取 （3）图片下载之后的缓存 （4）图片的解码 （5）未下载完成图片operation的取消 这些操作统一由 SDWebImageManager来调用各个组件进行完成；     </p><p>SDWebImageManager提供下面的API来完成图片的获取操作  </p><pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url                                     options:(SDWebImageOptions)options                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock                                   completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;   </code></pre><p> 具体的执行包括  </p><ul><li>缓存获取图片返回image对象  </li><li>缓存中未获取图片  <ul><li>有正在执行的任务cancel掉当前operation  </li><li>执行下载操作  </li><li>下载成功返回image对象</li><li>缓存图片</li></ul></li></ul><h4 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h4><p>SD基于NSURLSession实现下载图片任务，同时结合NSOperationQueue控制最大的并发task量为6；<br>默认的下载是first in frist out 新加入的operation执行要依赖最后添加到队列中的task；  </p><p>SDWebImageDownloader提供如下API来实现图片的下载操作 </p><pre><code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url                                     options:(SDWebImageDownloaderOptions)options                                    progress:(SDWebImageDownloaderProgressBlock)progressBlock                                   completed:(SDWebImageDownloaderCompletedBlock)completedBlock;   </code></pre><h4 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h4><p>执行下载操作的类，对网络请求的数据进行解析和处理操作   </p><h4 id="当某一个UIImageView执行下载图片但是它有下载任务还未完成该如何操作？"><a href="#当某一个UIImageView执行下载图片但是它有下载任务还未完成该如何操作？" class="headerlink" title="当某一个UIImageView执行下载图片但是它有下载任务还未完成该如何操作？"></a>当某一个UIImageView执行下载图片但是它有下载任务还未完成该如何操作？</h4><p>通常解决这类问题就是设置一个属性字段作为标识符但是在objective-c的分类中不能增加属性来标识当前UIImageView有下载任务；那么该如何解决？<br>SD的解决方案是运用运行时的关联对象的特性给UIImageView增加了一个可变字典属性  </p><pre><code>- (NSMutableDictionary *)operationDictionary {NSMutableDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);if (operations) {    return operations;}operations = [NSMutableDictionary dictionary];objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);return operations;}</code></pre><div align="center"><br><img src="https://raw.githubusercontent.com/rs/SDWebImage/master/SDWebImage_logo.png" width="300" height="100" alt="SDWebImage浅析"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImage提供的简洁的获取远程URL图片的API；平时开发中使用最多场景就是列表中的cell中要显示远程图片的需求，在具体的实现中要避免加载图片造成的界面卡顿，列表卡顿等现象的出现；所以需要编码实现如下功能：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用占位图片显示UI界面，异步线程加载图片成功后刷新控件&lt;/li&gt;
&lt;li&gt;缓存机制，下载过的图片做内存缓存和磁盘缓存 &lt;/li&gt;
&lt;li&gt;app内存吃紧的状态下移除缓存的内容 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS开源代码阅读" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>OC基础之引用循环</title>
    <link href="http://yoursite.com/2016/10/20/OC%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2016/10/20/OC基础之引用循环/</id>
    <published>2016-10-20T02:20:56.000Z</published>
    <updated>2018-06-23T03:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用面向对象的编程语言进行开发的过程中大都涉及到内存管理相关的问题；JAVA、C#等语言采用GC（垃圾回收）机制来管理内存的使用；而最早从事iOS开发的工程师则经历过MRC（手动管理）内存的阶段，后期apple推出了ARC（自动引用计数）的方式来简化内存的管理；那么ARC究竟是什么呢？ARC是如何进行内存管理的呢？<br><a id="more"></a></p><h4 id="自动引用计数（ARC）"><a href="#自动引用计数（ARC）" class="headerlink" title="自动引用计数（ARC）"></a>自动引用计数（ARC）</h4><ul><li>创建一个对象就是在内存中开辟了一块空间来存储对象的属性和行为，对象都有自己的生命周期，系统如何判断对象的生命周期完毕后就对它进行回收呢？  </li><li>iOS系统采用的是引用计数，在开辟的内存区域中存在一个NSInteger类型的变量，对象一旦创建它的值就为1，（通常情况下）有强引用指向它的值就会+1，强引用置为nil，它的值就会-1（retain消息会使得引用计数+1，release消息会使得引用计数-1）；在一次事件循环结束后如果对象的引用计数为0则系统就会回收该对象；那么一次的事件循环还发生了什么呢？  </li><li>首先要介绍自动释放池(autoReleasePool)：它的实质是一个NSMutableArray，一次的事件循环都会创建一个自动释放池，事件循环中产生的对象会被依次加入到autoReleasePool中，事件循环结束后自动释放池会一次向存储的对象发送release消息，使得对象的引用计数-1，当此操作完毕后，引用计数为0的对象就会被系统回收了； </li><li>总的来说自动引用计数（ARC）就是iOS系统用来进行内存管理手段，通过监控对象的引用计数值来决定对象是否应该回收；   </li></ul><h4 id="判断一个对象是否被回收的依据"><a href="#判断一个对象是否被回收的依据" class="headerlink" title="判断一个对象是否被回收的依据"></a>判断一个对象是否被回收的依据</h4><p>对象的引用计数为0时，Objective-C中会调用<code>-(void)dealloc</code>而Swift会调用<code>deinit {}</code>;当这两个方法被正常调用时说明对象的内存管理是正确的；但是也会出现对象不被正常释放的情况，例如：两个对象互相强引用造成循环引用，使用block或是闭包造成与self的循环引用等，那么该如何解决这种强引用循环呢？  </p><h4 id="循环强引用"><a href="#循环强引用" class="headerlink" title="循环强引用"></a>循环强引用</h4><h5 id="类的实例之间的循环强引用"><a href="#类的实例之间的循环强引用" class="headerlink" title="类的实例之间的循环强引用"></a>类的实例之间的循环强引用</h5><pre><code>@interface Person()@property(strong)Car* car;@end@interface Car()@property(strong)Person* owner;@end   </code></pre><p>上述代码中创建Person和Car的实例后，为属性赋值，就会造成两者互为强引用，这样就使得引用计数不能为0，ARC就无法对两者进行内存的释放； 那么该如何打破这种互相强引用呢？Objective-C和Swift都提供了weak关键字的机制来解决这个问题；使用weak修饰属性在赋值的时候不会使引用计数+1，没有了强引用那么对象就能正常释放！除了weak在Swift中还提供了unowned（无主引用）解决强循环引用；</p><h5 id="Swift中weak和unowned"><a href="#Swift中weak和unowned" class="headerlink" title="Swift中weak和unowned"></a>Swift中weak和unowned</h5><p>当两个实例出现互相强引用：（1）实例的值为nil对逻辑上不造成影响，那么选择weak（2）实例的值的一方必须存在，那么只能使用unowned；例如人和信用卡一样，信用卡的拥有者必须要实际存在；   </p><h4 id="block和闭包中出现强循环引用"><a href="#block和闭包中出现强循环引用" class="headerlink" title="block和闭包中出现强循环引用"></a>block和闭包中出现强循环引用</h4><pre><code>#import &quot;HZBlock.h&quot;typedef void (^TestBlock)(NSString* message);@interface HZBlock()@property(nonatomic,copy)TestBlock testBlock;@property(nonatomic,copy)NSString* name;@end@implementation HZBlock-(void)testBlcok{    self.testBlock = ^(NSString* message){       // 循环引用        NSString* nameNew = self.name;        NSLog(@&quot;%@&quot;,nameNew);    };}   </code></pre><p>上述代码中在block中使用self，编译器会报警告，告知此处会出现循环引用(Capturing ‘self’ strongly in this block is likely to lead to a retain cycle)；  </p><p>在Objective-C中可以weak化self来解决此问题   </p><pre><code>// weak化self__weak __typeof(self) weakSelf = self;// 在block体中为了避免self被释放，可以再次强引用__typeof(&amp;*weakSelf) strongSelf = weakSelf;    </code></pre><p> 在Swift中定义捕获列表解决闭包内的引用循环   </p><pre><code>class AutoRefManager: NSObject { let name: Stringlet text: String?lazy var asHTML: (Void) -&gt; String = {// 捕获列表    [unowned self] in   self.text!}init(name: String, text: String? = nil) {    self.name = name    self.text = text}}</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在开发中遇到类似的循环引用时要仔细思考，是否会造成内存泄露的问题，然后再选择合适的解决方案来解决出现的问题；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用面向对象的编程语言进行开发的过程中大都涉及到内存管理相关的问题；JAVA、C#等语言采用GC（垃圾回收）机制来管理内存的使用；而最早从事iOS开发的工程师则经历过MRC（手动管理）内存的阶段，后期apple推出了ARC（自动引用计数）的方式来简化内存的管理；那么ARC究竟是什么呢？ARC是如何进行内存管理的呢？&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS基础" scheme="http://yoursite.com/tags/iOS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
